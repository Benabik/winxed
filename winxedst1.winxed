#! winxed

// Winxed stage 1 compiler

//*********************************************
//          Character test functions
//*********************************************

function isspace(string c)
{
    return c == ' ' || c == "\n" || c == "\t";
}

function isdigit(string c)
{
    return indexof('0123456789', c) > -1;
}

function isidentstart(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_',
        c) > -1;
}

function isident(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_' +
        '0123456789',
        c) > -1;
}


//*********************************************
//        Error handling exceptions
//*********************************************

const int ERRORinternal  = 555;
const int ERRORtokenizer = 556;
const int ERRORparser    = 557;

function InternalError(string msg, var pos [optional], int has_pos [opt_flag])
{
    if (has_pos) {
        string desc = pos.show();
        msg = msg + ' near ' + desc;
    }
    var ex= Error(msg, 2, ERRORinternal);
    throw ex;
}

function TokenError(string msg, tk, int line)
{
   string sline= line;
   string file= tk.filename;
   string m= msg + ' in '+ file + ' line ' + sline;
   var ex= Error(m, 2, ERRORtokenizer);
   throw ex;
}

function SyntaxError(string msg, var pos)
{
    string sline= pos.line;
    string file= pos.file;
    string desc = pos.show();
    string m= msg + ' in '+ file + ' line ' + sline + ' near ' + desc;
    var ex= Error(m, 2, ERRORparser);
    throw ex;
}

function Expected(string msg, var t)
{
    SyntaxError("Expected '" + msg + "'", t);
}

function RequireOp(string name, var t)
{
    if (! t.isop(name))
        Expected(name, t);
}

function RequireKeyword(string name, var t)
{
    if (! t.iskeyword(name))
        Expected(name, t);
}

function ExpectOp(string name, var tk)
{
    var t = tk.get();
    RequireOp(name, t);
}

function ExpectKeyword(string name, var tk)
{
    var t = tk.get();
    RequireKeyword(name, t);
}

//*********************************************
//                Token
//*********************************************

const int TypeEof          = -1;
const int TypeComment      = 0;
const int TypeOp           = 1;
const int TypeQuoted       = 2;
const int TypeSingleQuoted = 3;
const int TypeIdentifier   = 4;
const int TypeInteger      = 5;
const int TypeFloat        = 6;

class Token
{
    var type;
    var str;
    var file;
    var line;
    function get_bool[vtable]()
    {
        return self.type != TypeEof;
    }
    function iseof()     { return self.type == TypeEof; }
    function iscomment() { return self.type == TypeComment; }
    function isint()     { return self.type == TypeInteger; }
    function isfloat()   { return self.type == TypeFloat; }
    function isstring()
    {
        return self.type == TypeQuoted || self.type == TypeSingleQuoted;
    }
    function isidentifier() { return self.type == TypeIdentifier; }
    function getidentifier()
    {
        if (self.type == TypeIdentifier)
            return self.str;
        else
            Expected('Identifier', self);
    }
    function iskeyword(string name)
    {
        return self.type == TypeIdentifier && self.str == name;
    }
    function checkkeyword()
    {
        string name = '';
        if (self.type == TypeIdentifier)
            name = self.str;
        return name;
    }
    function isop(string name)
    {
        return self.type == TypeOp && self.str == name;
    }
    function checkop()
    {
        string name = '';
        if (self.type == TypeOp)
            name = self.str;
        return name;
    }

    function get_string[vtable]()
    {
        string str= self.str;
        switch (self.type) {
        case TypeQuoted:
            str= '"' + str + '"';
            break;
        case TypeSingleQuoted:
            str= "'" + str + "'";
            break;
        }
        return str;
    }

    function show()
    {
        string str = self.str;
        string r;
        switch (self.type) {
        case TypeEof:
            r = '(End of file)'; break;
        case TypeOp:
        case TypeIdentifier:
        case TypeInteger:
        case TypeFloat:
            r = str; break;
        case TypeQuoted:
            r = '"' + str + '"'; break;
        case TypeSingleQuoted:
            r = "'" + str + "'"; break;
        default:
            r = '(unknown)';
        }
        return r;
    }
}

function newToken(int type, string s, string file, int line)
{
    var t= new Token();
    t.type= type; t.str= s; t.file= file; t.line= line;
    return t;
}

function newTokenFrom(int type, string s, var old)
{
    var t= new Token();
    t.type= type; t.str= s; t.file= old.file; t.line= old.line;
    return t;
}

//*********************************************
//       Tokenizer auxiliar functions
//*********************************************

function getquoted(tk, string start, int line)
{
    string s;
    string c= tk.getchar();
    while (c != '"') {
        if (c == '' || c == "\n")
            TokenError('Unterminated string', tk, line);
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeQuoted, s, tk.filename, line);
}

function getsinglequoted(tk, string start, int line)
{
    string s;
    string c= tk.getchar();
    while (c != "'") {
        if (c == '' || c == "\n")
            TokenError('Unterminated string', tk, line);
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeSingleQuoted, s, tk.filename, line);
}

function getident(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
    while (isident(c)) {
        s+= c;
        c= tk.getchar();
    }
    tk.ungetchar(c);
    return newToken(TypeIdentifier, s, tk.filename, line);
}

function getnumber(tk, string start, int line)
{
    string s;
    string c = start;
    do {
        s+= c;
        c= tk.getchar();
    } while (isdigit(c));
    if (c == '.') {
        do {
            s+= c;
            c= tk.getchar();
        } while (isdigit(c));
        tk.ungetchar(c);
        return newToken(TypeFloat, s, tk.filename, line);
    }
    else {
        tk.ungetchar(c);
        return newToken(TypeInteger, s, tk.filename, line);
    }
}

function getlinecomment(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
    while (c != '' && c != "\n") {
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeComment, s, tk.filename, line);
}

function getcomment(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
next:
    while (c != '' && c != '*')
    { s+= c; c= tk.getchar(); }
    if (c == '')
        TokenError("Unclosed comment", tk, line);
    c= tk.getchar();
    if (c == '')
        TokenError("Unclosed comment", tk, line);
    if (c != '/')
    { s+= '*' + c; goto next; }
    s+= '*/';
    return newToken(TypeComment, s, tk.filename, line);
}

function getop(tk, string start, int line)
{
    string s= start;
    return newToken(TypeOp, s, tk.filename, line);
}

//*********************************************
//              Tokenizer
//*********************************************

class Tokenizer
{
    var h;
    var pending;
    var select;
    var stacked;
    var filename;
    var line;
    function init(handle, string filename)
    {
        self.h= handle;
        self.pending= new 'String';
        self.stacked= [];
        self.filename= filename;
        self.line= 1;
        var select = {
            '"': { '': getquoted },
            "'": { '': getsinglequoted },
            '=': { '=': getop, ':': getop },
            '+': { '+': getop, '=': getop },
            '-': { '-': getop, '=': getop },
            '|': { '|': getop },
            '&': { '&': getop },
            '<': { '<': getop, '=': getop },
            '>': { '>': getop, '=': getop },
            '!': { '=': getop },
            '%': { '%': getop },
            '/': { '/': getlinecomment, '*': getcomment },
            '#': { '': getlinecomment }
        };
        self.select= select;
    }
    function getchar()
    {
        string pending= self.pending;
        if (pending != '') {
            self.pending= '';
            return pending;
        }
        var h= self.h;
        string c= h.read(1);
        if (c == "\n") {
                int l=self.line;
                ++l;
                self.line= l;
        }
        return c;
    }
    function ungetchar(string c)
    {
        self.pending= c;
    }
    function get_token()
    {
        if (self.stacked) {
            var t= self.stacked.pop();
            return t;
        }
        string c= self.getchar();
        while (isspace(c))
                c= self.getchar();
        int line= self.line;
        if (c == '') {
            var t= new Token();
            t.type= TypeEof;
            return t;
        }
        if (isidentstart(c))
            return getident(self, c, line);
        if (isdigit(c))
            return getnumber(self, c, line);
        var select = self.select;
        var current= select[c];
        if (current) {
            string c2= self.getchar();
            var current2= current[c2];
            if (current2) {
                c+= c2;
                return current2(self, c, line);
            }
            else {
                self.ungetchar(c2);
                current2= current[''];
                if (current2)
                    return current2(self, c, line);
            }
        }
        return getop(self, c, line);
    }
    function get(int withcomments [optional])
    {
        var t= self.get_token();
        while (!t.iseof() && ! withcomments && t.iscomment() )
           t= self.get_token();
        return t;
    }
    function unget(t) { self.stacked.push(t); }
}

//*********************************************
//            Emit
//*********************************************

class Emit
{
    var handle;
    var file;
    var line;
    var pendingf;
    var pendingl;
    function initialize(var handle)
    {
        self.handle= handle;
        self.file= '';
        self.line= 0;
        self.pendingf= 0;
        self.pendingl= 0;
    }
    function close()
    {
        self.handle = null;
    }
    function updateannot()
    {
        if (self.pendingf) {
            self.handle.print(".annotate 'file', '");
            self.handle.print(self.file);
            self.handle.print("'");
            self.handle.print("\n");
            self.pendingf= 0;
        }
        if (self.pendingl) {
            self.handle.print(".annotate 'line', ");
            self.handle.print(self.line);
            self.handle.print("\n");
            self.pendingl= 0;
        }
    }
    function vprint(var args)
    {
        for (var s in args)
            self.handle.print(s);
    }
    function print(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
    }
    function say(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
        self.handle.print("\n");
    }
    function annotate(var t)
    {
        if (self.file != t.file) {
            self.file= t.file;
            self.pendingf= 1;
            self.line= 0;
        }
        if (self.line != t.line) {
            self.line= t.line;
            self.pendingl= 1;
        }
    }
    function comment(string s)
    {
        self.handle.print('# ' + s + "\n");
    }
}

//*********************************************
//         Predefined functions
//*********************************************

class PredefFunction
{
    var name;
    var body;
    var typeresult;
    var type0;
    var type1;
    var type2;
    var nargs;

    function name()
    {
        string name = self.name;
        return name;
    }
    function result()
    {
        return self.typeresult;
    }
    function args() { return self.nargs; }
    function argtype(int i)
    {
        string type;
        switch(i) {
        case 0: type = self.type0; break;
        case 1: type = self.type1; break;
        case 2: type = self.type2; break;
        default:
            InternalError('Invalid predef arg');
        }
        return type;
    }
    function set(string name, body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional])
    {
        self.name = name;
        self.body = body;
        self.typeresult = typeresult;
        int n = 0;
        if (type0 != null) {
            self.type0 = type0;
            if (type0 == '*')
                n = -1;
            else {
                n = 1;
                if (type1 != null) {
                    self.type1 = type1;
                    ++n;
                }
                if (type2 != null) {
                    self.type2 = type2;
                    ++n;
                }
            }
        }
        self.nargs = n;
        return self;
    }
    function expand(e, start, string result, args)
    {
        if (self.body instanceof 'String') {
            string body = self.body;
            int pos;
            while ((pos = indexof(body, '{res}')) != -1)
                body = substr(body, 0, pos) + result + substr(body, pos + 5);
            int n = args;
            for (int i = 0; i < n; ++i) {
                string argmark = '{arg' + i + '}';
                string arg = args[i];
                while ((pos = indexof(body, argmark)) != -1)
                    body = substr(body, 0, pos) + arg + substr(body, pos + 6);
            }
            e.annotate(start);
            e.say(body);
        }
        else {
            var fun = self.body;
            fun(e, start, result, args);
        }
    }
}

class Predef_say
{
    function invoke [vtable](e, start, result, args)
    {
        e.annotate(start);
        int n = args;
        if (args > 0) {
            for (int i = 0; i < n - 1; ++i)
                e.say('print ', args[i]);
            e.say('say ', args[n - 1]);
        }
        else
            e.say(" say ''");
    }
}

class Predef_print
{
    function invoke [vtable](e, start, result, args)
    {
        e.annotate(start);
        int n = args;
        for (int i = 0; i < n; ++i)
            e.say('print ', args[i]);
    }
}

function getpredefs()
{
    var predef_say = new Predef_say();
    var predef_print = new Predef_print();
    var predefs = [
        new PredefFunction().set('die',
            'die {arg0}',
            'P', 'S'
        ),
        new PredefFunction().set('Error',
            "root_new {res}, ['parrot';'Exception']\n" +
            "{res}['message'] = {arg0}",
            'P', 'S'
        ),
        new PredefFunction().set('Error',
            "root_new {res}, ['parrot';'Exception']\n" + 
            "{res}['message'] = {arg0}\n" +
            "{res}['severity'] = {arg1}",
            'P', 'S', 'I'
        ),
        new PredefFunction().set('Error',
            "root_new {res}, ['parrot';'Exception']\n" +
            "{res}['message'] = {arg0}\n" +
            "{res}['severity'] = {arg1}\n" +
            "{res}['type'] = {arg2}",
            'P', 'S', 'I', 'I'
        ),
        new PredefFunction().set('length',
            'length {res}, {arg0}',
            'I', 'S'
        ),
        new PredefFunction().set('chr',
            "chr {res}, {arg0}\n" +
            "find_encoding $I0, 'utf8'\n" +
            "trans_encoding {res}, $I0",
            'S', 'I'
        ),
        new PredefFunction().set('ord',
            'ord {res}, {arg0}',
            'I', 'S'
        ),
        new PredefFunction().set('ord',
            'ord {res}, {arg0}, {arg1}',
            'I', 'S', 'I'
        ),
        new PredefFunction().set('substr',
            'substr {res}, {arg0}, {arg1}',
            'S', 'S', 'I'
        ),
        new PredefFunction().set('substr',
            'substr {res}, {arg0}, {arg1}, {arg2}',
            'S', 'S', 'I', 'I'
        ),
        new PredefFunction().set('indexof',
            'index {res}, {arg0}, {arg1}',
            'I', 'S', 'S'
        ),
        new PredefFunction().set('indexof',
            'index {res}, {arg0}, {arg1}, {arg2}',
            'I', 'S', 'S', 'I'
        ),
        new PredefFunction().set('join',
            'join {res}, {arg0}, {arg1}',
            'S', 'S', 'P'
        ),
        new PredefFunction().set('split',
            'split {res}, {arg0}, {arg1}',
            'P', 'S', 'S'
        ),
        new PredefFunction().set('chomp',
            "load_bytecode 'String/Utils.pbc'\n" +
            ".local pmc util_chomp\n" + 
            "util_chomp = get_root_global ['parrot';'String';'Utils'], 'chomp\n" +
            "{res} = util_chomp({arg0})",
            'S', 'S'
        ),
        new PredefFunction().set('chomp',
            "load_bytecode 'String/Utils.pbc'\n" +
            ".local pmc util_chomp\n" +
            "util_chomp = get_root_global ['parrot';'String';'Utils'], 'chomp'\n" +
            "{res} = util_chomp({arg0}, {arg1})",
            'S', 'S', 'S'
        ),
        new PredefFunction().set('sqrt',
            'sqrt {res}, {arg0}',
            'N', 'N'
        ),
        new PredefFunction().set('pow',
            'pow {res}, {arg0}, {arg1}',
            'N', 'N', 'N'
        ),
        new PredefFunction().set('sin',
            'sin {res}, {arg0}',
            'N', 'N'
        ),
        new PredefFunction().set('cos',
            'cos {res}, {arg0}',
            'N', 'N'
        ),
        new PredefFunction().set('tan',
            'tan {res}, {arg0}',
            'N', 'N'
        ),
        new PredefFunction().set('asin',
            'asin {res}, {arg0}',
            'N', 'N'
        ),
        new PredefFunction().set('acos',
            'acos {res}, {arg0}',
            'N', 'N'
        ),
        new PredefFunction().set('atan',
            'atan {res}, {arg0}',
            'N', 'N'
        ),
        new PredefFunction().set('getinterp',
            'getinterp {res}',
            'P'
        ),
        new PredefFunction().set('clone',
            'clone {res}, {arg0}',
            'P', 'P'
        ),
        new PredefFunction().set('loadlib',
            'loadlib {res}, {arg0}',
            'P', 'S'
        ),
        new PredefFunction().set('dlfunc',
            'dlfunc {res}, {arg0}, {arg1}, {arg2}',
            'P', 'P', 'S', 'S'
        ),
        new PredefFunction().set('print',
            predef_print,
            'P', '*'
        ),
        new PredefFunction().set('say',
            predef_say,
            'P', '*'
        )
    ];
    for (;;)
        yield predefs;
}

function findpredef(string name, int nargs)
{
    //say(name, '(', nargs, ')');

    var predefs = getpredefs();
    int n = predefs;
    for (int i = 0; i < n; ++i) {
        var p = predefs[i];
        int pargs = p.nargs;
        if (p.name == name && (pargs == -1 || pargs == nargs))
            return p;
    }
    return null;
}

//*********************************************
//            Modifiers
//*********************************************

class Modifier
{
    var name;
    var args;

    function getname() { return self.name; }
    function numargs()
    {
        int nargs = self.args;
        return nargs;
    }
    function getarg(int argnum)
    {
        var args = self.args;
        int n = args;
        if (argnum < n)
            return args[argnum];
        else
            InternalError('Wrong modifier arg number');
    }
    function set(string name, var args)
    {
        self.name = name;
        if (args != null)
            self.args = args;
        return self;
    }
    function optimize()
    {
        var args = self.args;
        if (args != null) {
            int n = args;
            for (int i= 0; i < n; ++i)
                args[i] = args[i].optimize();
        }
    }
}

class ModifierList
{
    var list;

    function parse(tk, owner)
    {
        var t;
        self.list = [];
        do {
            t = tk.get();
            string name = t.getidentifier();
            t = tk.get();
            var args;
            if (t.isop('(')) {
                args = [];
                do {
                    var value = parseExpr(tk, owner);
                    args.push(value);
                } while ((t= tk.get()).isop(','));
                RequireOp(')', t);
                t= tk.get();
            }
            self.list.push(new Modifier().set(name, args));
        } while (t.isop(','));
        RequireOp(']', t);

        return self;
    }
    function optimize()
    {
        for (var arg in self.list)
            arg.optimize();
    }
    function getlist() { return self.list; }
}

//*********************************************
//       Auxiliary classes and functions
//*********************************************

function getkey(var path)
{
    string s = "[ ";
    string sep= " '";
    for (string n in path) {
        s+= sep;
        sep=" ; '";
        s+= n + "'";
    }
    s+= " ]";
    return s;
}

function namespacekey(var path)
{
    string s = '.namespace [';
    string sep= " '";
    for (string n in path) {
        s+= sep;
        sep=" ; '";
        s+= n + "'";
    }
    s+= " ]";
    return s;
}

class Item
{
    function isNamespace() { return 0; }
    function isClass() { return 0; }
}

function parseUsing(t, tk, owner)
{
    var taux = tk.get();
    if (taux.iskeyword('extern'))
        return new ExternStatement().parse(t, tk, owner);
    else {
        tk.unget(taux);
        return new UsingStatement().parse(t, tk, owner);
    }
}

function parseStatement(tk, owner)
{
    var t= tk.get();
    if (t.isop(';'))
        return new EmptyStatement();
    if (t.isop('{'))
        return new CompoundStatement().parse(t, tk, owner);
    string key = t.checkkeyword();
    var st;
    switch (key) {
    case 'using':
        return parseUsing(t, tk, owner);
    case 'const':
        st = new ConstStatement();
        break;
    case 'var':
        st = new VarStatement();
        break;
    case 'string':
        st = new StringStatement();
        break;
    case 'int':
        st = new IntStatement();
        break;
    case 'float':
        st = new FloatStatement();
        break;
    case 'return':
        st = new ReturnStatement();
        break;
    case 'yield':
        st = new YieldStatement();
        break;
    case 'goto':
        st = new GotoStatement();
        break;
    case 'if':
        st = new IfStatement();
        break;
    case 'while':
        st = new WhileStatement();
        break;
    case 'do':
        st = new DoStatement();
        break;
    case 'continue':
        st = new ContinueStatement();
        break;
    case 'break':
        st = new BreakStatement();
        break;
    case 'switch':
        st = new SwitchStatement();
        break;
    case 'for':
        return parseFor(t, tk, owner);
    case 'throw':
        st = new ThrowStatement();
        break;
    case 'try':
        st = new TryStatement();
        break;
    default:
        if (t.isidentifier()) {
            var t2= tk.get();
            if (t2.isop(':'))
                return new LabelStatement().set(t, owner);
            tk.unget(t2);
        }
        tk.unget(t);
        st = new ExprStatement();
    }
    if (st == null)
        InternalError('parseStatement failure');
    st = st.parse(t, tk, owner);
    return st;
}

//*********************************************
//            Statement
//*********************************************

class Statement : Item
{
    var start;
    var owner;

    function initstatement(start, owner)
    {
        self.start = start;
        self.owner = owner;
    }
    function isempty() { return 0; }
    function annotate(e)
    {
        e.annotate(self.start);
    }
    function createreg(string type)
    {
        return self.owner.createreg(type);
    }
    function tempreg(string type)
    {
        return self.owner.tempreg(type);
    }
    function freetemps()
    {
        self.owner.freetemps();
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function getlabel(name)
    {
        return self.owner.getlabel(name);
    }
    function createlabel(name)
    {
        return self.owner.createlabel(name);
    }
    function createconst(name, string type, value)
    {
        return self.owner.createconst(name, type, value);
    }
    function createvar(name, string type)
    {
        return self.owner.createvar(name, type);
    }
    function getvar(name)
    {
        return self.owner.getvar(name);
    }
    function getcontinuelabel(pos)
    {
        return self.owner.getcontinuelabel(pos);
    }
    function getbreaklabel(pos)
    {
        return self.owner.getbreaklabel(pos);
    }
    function optimize()
    {
        // Return unchanged by default
        return self;
    }
}

class EmptyStatement : Statement
{
    function isempty() { return 1; }
    function annotate(e)
    {
        InternalError('Attempt to annotate empty statement');
    }
    function emit(e)
    {
        // Do nothing
    }
}

//*********************************************
//            ExternStatement
//*********************************************

class ExternStatement : Statement
{
    var path;
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        string path[];
        var t;
        do {
            t= tk.get();
            string s= t.getidentifier();
            path.push(s);
        } while ((t= tk.get()).isop('.'));
        RequireOp(';', t);
        self.path = path;
        return self;
    }
    function emit(e)
    {
        string file;
        string sep = '';
        for (string p in self.path) {
            file += sep;
            file += p;
            sep = '/';
        }
        self.annotate(e);
        e.say("load_bytecode '", file, ".pbc'");
    }
}

//*********************************************
//            UsingStatement
//*********************************************

class UsingStatement : Statement
{
    var path;
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        string path[];
        var t;
        do {
            t= tk.get();
            string s= t.getidentifier();
            path.push(s);
        } while ((t= tk.get()).isop('.'));
        RequireOp(';', t);
        self.path = path;
        return self;
    }
    function emit(e)
    {
        var path = self.path;
        string name = path.pop();
        self.annotate(e);
        e.say('.local pmc ', name);
        e.print('get_hll_global ', name, ', ');
        int n = path;
        switch (n) {
        case 0:
            e.say("'", name, "'");
            break;
        default:
            e.print('[');
            string sep = '';
            for (string p in path) {
                e.print(sep, "'", p, "'");
                sep = '; ';
            }
            e.say(" ], '", name, "'");
        }
    }
}

//*********************************************
//            ExprStatement
//*********************************************

class ExprStatement : Statement
{
    var expr;
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.expr = parseExpr(tk, self);
        ExpectOp(';', tk);
        return self;
    }
    function optimize()
    {
        self.expr = self.expr.optimize();
        return self;
    }
    function emit(e)
    {
        var expr = self.expr;
        self.expr.emit_get(e);
    }
}

//*********************************************
//            VarContainer
//*********************************************

class VarContainer
{
    var locals;
    function init [vtable] ()
    {
        self.locals = new 'Hash';
    }
    function createvar(var name, string type)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        string reg= self.createreg(type);
        var descriptor= new 'Hash';
        descriptor['type'] = type;
        descriptor['reg'] = reg;
        descriptor['const']= 0;
        locals[sname]= descriptor;
        return reg;
    }
    function createconst(var name, string type, value)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        var descriptor= new 'Hash';
        descriptor['type'] = type;
        descriptor['value'] = value;
        descriptor['reg'] = '**WRONG**';
        descriptor['const']= 1;
        locals[sname]= descriptor;
    }
    function getvar(var name)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist == null && self.owner != null)
            exist = self.owner.getvar(name);
        return exist;
    }
}

//*********************************************
//            BlockStatement
//*********************************************

// A BlockStatement is a Statement that can have local variables.

class BlockStatement : VarContainer, Statement
{
}

//*********************************************
//            Expr
//*********************************************

class Expr
{
    var owner;
    var start;

    function issimple() { return 0; }
    function isliteral() { return 0; }
    function isintegerliteral() { return 0; }
    function isfloatliteral() { return 0; }
    function isstringliteral() { return 0; }
    function isidentifier() { return 0; }
    function isnull() { return 0; }
    function hascompilevalue() { return 0; }
    function initexpr(owner, start)
    {
        self.owner = owner;
        self.start = start;
    }
    function tempreg(type)
    {
        return self.owner.tempreg(type);
    }
    function optimize()
    {
        // By default return same expression unchanged
        return self;
    }
    function emit_get(e)
    {
        string type = self.checkResult();
        string reg = self.tempreg(type);
        self.emit(e, reg);
        return reg;
    }
    function emit_assign_get(e, expr)
    {
        SyntaxError('Not a left-side expression', self.start);
    }
}

class SimpleExpr : Expr
{
    function issimple() { return 1; }
}

//*********************************************

class StringLiteral : SimpleExpr
{
    var strval;
    function isliteral() { return 1; }
    function isstringliteral() { return 1; }
    function checkResult() { return 'S'; }
    function hascompilevalue() { return 1; }
    function set(owner, t)
    {
        self.initexpr(owner, t);
        self.strval = t;
        return self;
    }
    function getPirString()
    {
        var strtok = self.strval;
        string str = strtok;
        var s = str;
        for (int code in s) {
            if (code > 127) {
                if (strtok.type == TypeSingleQuoted) {
                    string straux = strtok.str;
                    str = '"';
                    var saux = straux;
                    for (string c in saux) {
                        if (c == '\')
                            c = '\\';
                        str += c;
                    }
                    str += '"';
                }
                str = 'utf8:unicode:' + str;
                break;
            }
        }
        return str;
    }
    function emit(e, result)
    {
        e.say('set ', result, ', ', self.getPirString());
    }
    function emit_get(e)
    {
        return self.getPirString();
    }
}

//*********************************************

class IntegerLiteral : SimpleExpr
{
    var pos;
    var numval;
    function isliteral() { return 1; }
    function isintegerliteral() { return 1; }
    function checkResult() { return 'I'; }
    function hascompilevalue() { return 1; }
    function set(owner, t, value [optional], int has_value [opt_flag])
    {
        self.initexpr(owner, t);
        self.pos = t;
        int n;
        if (has_value)
            n = value;
        else {
            string aux = t;
            n = aux;
        }
        self.numval = n;
        return self;
    }
    function getIntegerValue()
    {
        string aux= self.numval;
        int i= aux;
        return i;
    }
    function emit(e, result)
    {
        e.say('set ', result, ', ', self.getIntegerValue());
    }
    function emit_get(e)
    {
        return self.getIntegerValue();
    }
}

//*********************************************

class FloatLiteral : SimpleExpr
{
    var numval;
    function isliteral() { return 1; }
    function isfloatliteral() { return 1; }
    function checkResult() { return 'N'; }
    function hascompilevalue() { return 1; }
    function set(owner, t)
    {
        self.initexpr(owner, t);
        self.numval = t;
        return self;
    }
    function getFloatValue()
    {
        string aux= self.numval;
        var n= new 'Float';
        n =: aux;
        return n;
    }
    function emit(e, result)
    {
        var n= self.getFloatValue();
        e.say('set ', result, ', ', n);
    }
    function emit_get(e)
    {
        return self.getFloatValue();
    }
}

//*********************************************

class IdentifierExpr : SimpleExpr
{
    var name;
    function isidentifier() { return 1; }
    function set(owner, t)
    {
        self.initexpr(owner, t);
        self.name = t;
        return self;
    }
    function isnull()
    {
        return self.name.iskeyword('null');
    }
    function checkResult()
    {
        var desc = self.owner.getvar(self.name);
        if (desc != null)
            return desc['type'];
        else {
            switch (self.name) {
            case 'self':
            case 'null':
                return 'P';
            default:
                return '';
            }
        }
    }
    function getName()
    {
        string s = self.name;
        return s;
    }
    function checkIdentifier()
    {
        var name = self.name;
        var desc = self.owner.getvar(name);
        string s;
        if (desc == null) {
            string sname = name;
            switch (sname) {
            case 'self':
                s = 'self'; break;
            case 'null':
                s = 'null'; break;
            default:
                s = '';
            }
        }
        else
            s= desc['reg'];
        return s;
    }
    function getIdentifier()
    {
        var value = self.checkIdentifier();
        if (value == '') {
            string name = self.name;
            SyntaxError("Variable '" + name + "' is not defined", self.name);
        }
        return value;
    }
    function optimize()
    {
        var name = self.name;
        var desc = self.owner.getvar(name);
        if (desc != null) {
            if (desc['const'])
                return desc['value'];
        }
        return self;
    }
    function emit(e, result)
    {
        e.annotate(self.name);
        e.say('set ', result, ', ', self.getIdentifier());
    }
    function emit_get(e)
    {
        return self.getIdentifier();
    }
    function emit_assign_get(e, expr)
    {
        string typeright = expr.checkResult();
        string rreg = expr.emit_get(e);
        string typeleft = self.checkResult();
        string lreg = self.emit_get(e);
        e.annotate(self.start);
        if (typeleft == 'P' && typeright != 'P')
            e.say('box ', lreg, ', ', rreg);
        else
            e.say('set ', lreg, ', ', rreg);
        return lreg;
    }
}

//*********************************************

class OpExpr : Expr
{
    function initop(owner, start)
    {
        self.initexpr(owner, start);
    }
}

//*********************************************

class OpUnaryExpr : OpExpr
{
    var subexpr;
    function initunary(owner, start, subexpr)
    {
        self.initop(owner, start);
        self.subexpr = subexpr;
    }
    function optimizearg()
    {
        self.subexpr = self.subexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
}

//*********************************************

class OpBinaryExpr : OpExpr
{
    var lexpr;
    var rexpr;
    function initbinary(owner, start, lexpr, rexpr)
    {
        self.initop(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
    }
    function set(owner, t, eleft, eright)
    {
        self.initbinary(owner, t, eleft, eright);
        return self;
    }
    function optimizearg()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
}

//*********************************************

class OpUnaryMinusExpr : OpUnaryExpr
{
    function checkResult()
    {
        return self.subexpr.checkResult();
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        self.optimizearg();
        if (self.subexpr.isintegerliteral()) {
            var numval = self.subexpr.numval;
            int n = numval;
            n = - n;
            return new IntegerLiteral().set(self.owner, self.subexpr.start, n);
        }
        return self;
    }
    function emit(e, result)
    {
        string reg = self.subexpr.emit_get(e);
        e.annotate(self.start);
        e.say('neg ', result, ', ', reg);
    }
}

//*********************************************

class OpNotExpr : OpUnaryExpr
{
    function checkResult()
    {
        return 'I';
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function emit(e, result)
    {
        string reg = self.subexpr.emit_get(e);
        e.annotate(self.start);
        string type = self.subexpr.checkResult();
        switch (type) {
        case 'I':
            e.say('not ', result, ', ', reg);
            break;
        case 'P':
            e.say('isfalse ', result, ', ', reg);
            break;
        default:
            e.say('isfalse ', result, ', ', reg);
        }
    }
}

//*********************************************

class OpPreIncExpr : OpUnaryExpr
{
    function checkResult()
    {
        return self.subexpr.checkResult();
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        self.subexpr = subexpr;
        return self;
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        if (result != '')
            e.say('set ', result, ', ', reg);
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        e.annotate(self.start);
        e.say('inc ', reg);
        return reg;
    }
}

//*********************************************

class OpPostIncExpr : OpUnaryExpr
{
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function checkResult()
    {
        return self.subexpr.checkResult();
    }
    function emit(e, result)
    {
        string reg = self.subexpr.emit_get(e);
        e.annotate(self.start);
        e.say('set ', result, ', ', reg);
        e.say('inc ', reg);
        return reg;
    }
}

//*********************************************

class OpPreDecExpr : OpUnaryExpr
{
    function checkResult()
    {
        return self.subexpr.checkResult();
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        if (result != '')
            e.say('set ', result, ', ', reg);
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        e.annotate(self.start);
        e.say('dec ', reg);
        return reg;
    }
}

//*********************************************

class OpPostDecExpr : OpUnaryExpr
{
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function checkResult()
    {
        return self.subexpr.checkResult();
    }
    function emit(e, result)
    {
        string reg = self.subexpr.emit_get(e);
        e.annotate(self.start);
        e.say('set ', result, ', ', reg);
        e.say('dec ', reg);
        return reg;
    }
}

//*********************************************

class OpBaseAssignExpr : Expr
{
    var eleft;
    var eright;
    function set(owner, start, lexpr, rexpr)
    {
        self.initexpr(owner, start);
        self.eleft = lexpr;
        self.eright = rexpr;
        return self;
    }
    function optimize_base()
    {
        self.eleft = self.eleft.optimize();
        self.eright = self.eright.optimize();
        return self;
    }
    function optimize()
    {
        return self.optimize_base();
    }
}

class OpAssignExpr : OpBaseAssignExpr
{
    function checkResult()
    {
        if (self.eleft.isidentifier())
            return self.eleft.checkResult();
        else
            InternalError('Unimplemented');
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        e.annotate(self.start);
        if (result != '')
            e.say('set ', result, ', ', reg);
    }
    function emit_get(e)
    {
        var eleft = self.eleft;
        return eleft.emit_assign_get(e, self.eright);
    }
}

//*********************************************

class OpAssignToExpr : OpBaseAssignExpr
{
    function checkResult()
    {
        if (self.eleft.isidentifier())
            return self.eleft.checkResult();
        else
            InternalError('Unimplemented');
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        e.annotate(self.start);
        e.say('assign ', result, ', ', reg);
    }
    function emit_get(e)
    {
        e.annotate(self.start);
        string reg = self.eleft.emit_get(e);
        string reg2 = self.eright.emit_get(e);
        e.say('assign ', reg, ', ', reg2);
        return reg;
    }
}

//*********************************************

class OpAddToExpr : OpBaseAssignExpr
{
    function checkResult()
    {
        if (self.eleft.isidentifier())
            return self.eleft.checkResult();
        else
            InternalError('Unimplemented');
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        if (result != '')
            e.say('set ', result, ', ', reg);
    }
    function emit_get(e)
    {
        string type = self.eleft.checkResult();
        string reg = self.eleft.emit_get(e);
        string reg2 = self.eright.emit_get(e);
        e.annotate(self.start);
        if (type == 'S')
            e.say('concat ', reg, ', ', reg2);
        else
            e.say('add ', reg, ', ', reg2);
        return reg;
    }
}

//*********************************************

class OpSubToExpr : OpBaseAssignExpr
{
    function checkResult()
    {
        if (self.eleft.isidentifier())
            return self.eleft.checkResult();
        else
            InternalError('Unimplemented');
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        if (result != '')
            e.say('set ', result, ', ', reg);
    }
    function emit_get(e)
    {
        string type = self.eleft.checkResult();
        string reg = self.eleft.emit_get(e);
        string reg2 = self.eright.emit_get(e);
        e.annotate(self.start);
        e.say('sub ', reg, ', ', reg2);
        return reg;
    }
}

//*********************************************

class ComparatorBaseExpr : OpBinaryExpr
{
    function checkResult() { return 'I'; }
    function emit_comparator(e, result)
    {
        string rl = self.lexpr.checkResult();
        string rr = self.rexpr.checkResult();
        string regl = self.lexpr.emit_get(e);
        string regr = self.rexpr.emit_get(e);
        e.annotate(self.start);
        string aux;
        if (rl == 'N' || rr == 'N')
        {
            if (rl == 'I') {
                aux = self.tempreg('N');
                e.say('set ', aux, ', ', regl);
                regl = aux;
            }
            if (rr == 'I') {
                aux = self.tempreg('N');
                e.say('set ', aux, ', ', regr);
                regr = aux;
            }
        }
        else if (rr == 'I' && rl == 'P') {
            aux = self.tempreg('I');
            e.say('set ', aux, ', ', regl);
            regl = aux;
        }
        else if (rr == 'P' && rl == 'I') {
            aux = self.tempreg('I');
            e.say('set ', aux, ', ', regr);
            regr = aux;
        }
        else if (rr == 'S' && rl == 'P') {
            aux = self.tempreg('P');
            e.say('box ', aux, ', ', regr);
            regr = aux;
        }
        else if (rr == 'P' && rl == 'S') {
            aux = self.tempreg('P');
            e.say('box ', aux, ', ', regl);
            regl = aux;
        }
 
        self.emitop(e, result, regl, regr);
    }
    function emit(e, result)
    {
        self.emit_comparator(e, result);
    }
}

//*********************************************

// Null checkers, created during optimize of Equal and NotEqual
// to simplify his emit functions.

class NullCheckerExpr : Expr
{
    var expr;

    function checkResult() { return 'I'; }
    function set(base, expr)
    {
        self.initexpr(base.owner, base.start);
        self.expr = expr;
        return self;
    }
}

class OpIsNullExpr : NullCheckerExpr
{
    function emit(e, result)
    {
        string reg = self.expr.emit_get(e);
        e.annotate(self.start);
        e.say('isnull ', result, ', ', reg);
    }
}

class OpNotNullExpr : NullCheckerExpr
{
    function emit(e, result)
    {
        string reg = self.expr.emit_get(e);
        e.annotate(self.start);
        e.say('isnull ', result, ', ', reg);
        e.say('not ', result);
    }
}

//*********************************************

class OpEqualExpr : ComparatorBaseExpr
{
    function optimize()
    {
        self.optimizearg();
        int lnull = self.lexpr.isnull();
        int rnull = self.rexpr.isnull();
        if (lnull && rnull)
            return new IntegerLiteral().set(self.owner, self.start, 1);
        else if (lnull)
            return new OpIsNullExpr().set(self, self.rexpr);
        else if (rnull)
            return new OpIsNullExpr().set(self, self.lexpr);
        else
            return self;
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.say('iseq ', result, ', ', regl, ', ', regr);
    }
    function emit(e, result)
    {
        self.emit_comparator(e, result);
    }
}

//*********************************************

class OpNotEqualExpr : ComparatorBaseExpr
{
    function optimize()
    {
        self.optimizearg();
        int lnull = self.lexpr.isnull();
        int rnull = self.rexpr.isnull();
        if (lnull && rnull)
            return new IntegerLiteral().set(self.owner, self.start, 0);
        else if (lnull)
            return new OpNotNullExpr().set(self, self.rexpr);
        else if (rnull)
            return new OpNotNullExpr().set(self, self.lexpr);
        else
            return self;
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.say('isne ', result, ', ', regl, ', ', regr);
    }
    function emit(e, result)
    {
        self.emit_comparator(e, result);
    }
}

//*********************************************

class OpLessExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('islt ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpGreaterExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('isgt ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpLessEqualExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('isle ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpGreaterEqualExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('isge ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpBoolAndExpr : OpBinaryExpr
{
    function checkResult()
    {
        return 'I';
    }
    function set(owner, t, eleft, eright)
    {
        self.owner = owner;
        self.start = t;
        self.lexpr = eleft;
        self.rexpr = eright;
        return self;
    }
    function emit(e, result)
    {
        string res;
        if (result != null)
            res = result;
        else
            res = self.tempreg('I');
        string op1 = self.tempreg('I');
        string op2 = self.tempreg('I');
        self.lexpr.emit(e, op1);
        self.rexpr.emit(e, op2);
        e.say('and ', res, ', ', op1, ', ', op2);
    }
}

//*********************************************

class OpBoolOrExpr : OpBinaryExpr
{
    function checkResult()
    {
        return 'I';
    }
    function set(owner, t, eleft, eright)
    {
        self.owner = owner;
        self.start = t;
        self.lexpr = eleft;
        self.rexpr = eright;
        return self;
    }
    function emit(e, result)
    {
        string res;
        if (result != null)
            res = result;
        else
            res = self.tempreg('I');
        string op1 = self.tempreg('I');
        string op2 = self.tempreg('I');
        self.lexpr.emit(e, op1);
        self.rexpr.emit(e, op2);
        e.say('or ', res, ', ', op1, ', ', op2);
    }
}

//*********************************************

class OpBinAndExpr : OpBinaryExpr
{
    function checkResult()
    {
        return 'I';
    }
    function set(owner, t, eleft, eright)
    {
        self.owner = owner;
        self.start = t;
        self.lexpr = eleft;
        self.rexpr = eright;
        return self;
    }
    function emit(e, result)
    {
        string res;
        if (result != null)
            res = result;
        else
            res = self.tempreg('I');
        string op1 = self.tempreg('I');
        string op2 = self.tempreg('I');
        self.lexpr.emit(e, op1);
        self.rexpr.emit(e, op2);
        e.say('band ', res, ', ', op1, ', ', op2);
    }
}

//*********************************************

class OpBinOrExpr : OpBinaryExpr
{
    function checkResult()
    {
        return 'I';
    }
    function set(owner, t, eleft, eright)
    {
        self.owner = owner;
        self.start = t;
        self.lexpr = eleft;
        self.rexpr = eright;
        return self;
    }
    function emit(e, result)
    {
        string res;
        if (result != null)
            res = result;
        else
            res = self.tempreg('I');
        string op1 = self.tempreg('I');
        string op2 = self.tempreg('I');
        self.lexpr.emit(e, op1);
        self.rexpr.emit(e, op2);
        e.say('bor ', res, ', ', op1, ', ', op2);
    }
}

//*********************************************

class OpAddExpr : OpBinaryExpr
{
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkResult();
            string rtype = rexpr.checkResult();
            if (ltype == 'S' && rtype == 'S') {
                var etok = lexpr.strval;
                var rtok = rexpr.strval;
                var t;
                int newtype;
                if (etok.type == TypeSingleQuoted && rtok.type == TypeSingleQuoted)
                    newtype = TypeSingleQuoted;
                else
                    newtype = TypeQuoted;
                string es = etok.str;
                string rs = rtok.str;
                t = newTokenFrom(newtype, es + rs, etok);
                return new StringLiteral().set(self.owner, t);
            }
            if (ltype == 'I' && rtype == 'I') {
                var lval = lexpr.numval;
                int ln = lval;
                var rval = rexpr.numval;
                int rn = rval;
                return new IntegerLiteral().set(self.owner, self.start, ln + rn);
            }
        }
        return self;
    }
    function checkResult()
    {
        string rl = self.lexpr.checkResult();
        string rr = self.rexpr.checkResult();
        if (rl == 'S' && rr == 'S')
            return 'S';
        if (rl == 'I' && rr == 'S')
            return 'S';
        if (rl == 'S' && rr == 'I')
            return 'S';
        if (rl == 'N' && rr == 'N')
            return 'N';
        if (rl == 'I' && rr == 'N')
            return 'N';
        if (rl == 'N' && rr == 'I')
            return 'N';
        return 'I';
    }
    function emit(e, result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string restype = self.checkResult();
        string ltype = lexpr.checkResult();
        string rtype = rexpr.checkResult();

        string rleft = lexpr.emit_get(e);
        string rright = rexpr.emit_get(e);
        if (restype == 'S') {
            if (ltype != 'S' || rtype != 'S') {
                string aux = self.tempreg('S');
                if (ltype != 'S') {
                    e.say(aux, ' = ', rleft);
                    rleft = aux;
                }
                else {
                    e.say(aux, ' = ', rright);
                    rright = aux;
                }
            }
            e.say('concat ', result, ', ', rleft, ', ', rright);
        }
        else {
            if (restype == 'I' && (ltype != 'I' || rtype != 'I')) {
                string l;
                if (ltype == 'I') l = rleft;
                else {
                    l = self.tempreg('I');
                    e.say('set ', l, ', ', rleft);
                }
                string r;
                if (rtype == 'I') r = rright;
                else {
                    r = self.tempreg('I');
                    e.say('set ', r, ', ', rright);
                }
                e.say('add ', result, ', ', l, ', ', r);
            }
            else
                e.say('add ', result, ', ', rleft, ', ', rright);
        }
    }
}

//*********************************************

class OpSubExpr : OpBinaryExpr
{
    function checkResult()
    {
        string rl = self.lexpr.checkResult();
        string rr = self.rexpr.checkResult();
        if (rl == 'N' && rr == 'N')
            return 'N';
        if (rl == 'I' && rr == 'N')
            return 'N';
        if (rl == 'N' && rr == 'I')
            return 'N';
        return 'I';
    }
    function emit(e, result)
    {
        string lreg = self.lexpr.emit_get(e);
        string rreg = self.rexpr.emit_get(e);
        e.say('sub ', result, ', ', lreg, ', ', rreg);
    }
}

//*********************************************

class OpMulExpr : OpBinaryExpr
{
    function checkResult()
    {
        var lexpr = self.lexpr;
        var ltype = lexpr.checkResult();
        if (ltype == 'S')
            return 'S';
        if (ltype == 'I' && self.rexpr.checkResult() == 'I')
            return 'I';
        else
            return 'N';
    }
    function emit(e, result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        var ltype = lexpr.checkResult();
        if (ltype == 'S') {
            string lreg = lexpr.emit_get(e);
            string rreg = rexpr.emit_get(e);
            string rval;
            switch (rexpr.checkResult()) {
            case 'I':
                rval = rreg;
                break;
            default:
                rval = self.tempreg('I');
                e.say('set ', rval, ', ', rreg);
            }
            e.annotate(self.start);
            e.say('repeat ', result, ', ', lreg, ', ', rval);
            return;
        }
        string rleft;
        string rright;
        int nleft;
        int nright;
        if ((!lexpr.issimple()) || lexpr.isidentifier()) {
            rleft= self.tempreg(self.checkResult());
            lexpr.emit(e, rleft);
        }
        else {
            nleft= lexpr.getIntegerValue();
            rleft= nleft;
        }
        if ((!rexpr.issimple()) || rexpr.isidentifier()) {
            rright= self.tempreg(self.checkResult());
            rexpr.emit(e, rright);
        }
        else {
            string type = rexpr.checkResult();
            switch(type) {
            case 'S':
                rright= self.tempreg(self.checkResult());
                rexpr.emit(e, rright);
                break;
            case 'I':
            default:
                nright= rexpr.getIntegerValue();
                rright= nright;
                break;
            }
        }
        e.annotate(self.start);
        e.say('mul ', result, ', ', rleft, ', ', rright);
    }
}

//*********************************************

class OpDivExpr : OpBinaryExpr
{
    function checkResult()
    {
        return 'N';
    }
    function emit(e, result)
    {
        var lexpr = self.lexpr;
        var lreg;
        if (lexpr.checkResult() == 'N')
            lreg = lexpr.emit_get(e);
        else {
            lreg = self.tempreg('N');
            lexpr.emit(e, lreg);
        }
        var rexpr = self.rexpr;
        var rreg;
        if (rexpr.checkResult() == 'N')
            rreg = rexpr.emit_get(e);
        else {
            rreg = self.tempreg('N');
            rexpr.emit(e, rreg);
        }
        e.annotate(self.start);
        e.say('div ', result, ', ', lreg, ', ', rreg);
    }
}

//*********************************************

class OpModExpr : OpBinaryExpr
{
    function checkResult()
    {
        return 'I';
    }
    function emit(e, result)
    {
        var lexpr = self.lexpr;
        var lreg;
        if (lexpr.checkResult() == 'I')
            lreg = lexpr.emit_get(e);
        else {
            lreg = self.tempreg('I');
            lexpr.emit(e, lreg);
        }
        var rexpr = self.rexpr;
        var rreg;
        if (rexpr.checkResult() == 'I')
            rreg = rexpr.emit_get(e);
        else {
            rreg = self.tempreg('I');
            rexpr.emit(e, rreg);
        }
        e.annotate(self.start);
        e.say('mod ', result, ', ', lreg, ', ', rreg);
    }
}

//*********************************************

class OpCModExpr : OpBinaryExpr
{
    function checkResult()
    {
        return 'I';
    }
    function emit(e, result)
    {
        var lexpr = self.lexpr;
        var lreg;
        if (lexpr.checkResult() == 'I')
            lreg = lexpr.emit_get(e);
        else {
            lreg = self.tempreg('I');
            lexpr.emit(e, lreg);
        }
        var rexpr = self.rexpr;
        var rreg;
        if (rexpr.checkResult() == 'I')
            rreg = rexpr.emit_get(e);
        else {
            rreg = self.tempreg('I');
            rexpr.emit(e, rreg);
        }
        e.annotate(self.start);
        e.say('cmod ', result, ', ', lreg, ', ', rreg);
    }
}

//*********************************************

class CallPredefExpr : Expr
{
    var predef;
    var args;

    function init(owner, start, predef, args)
    {
        self.initexpr(owner, start);
        self.predef = predef;
        self.args = args;
        return self;
    }
    function checkResult()
    {
        return self.predef.result();
    }
    function emit(e, result)
    {
        var predef = self.predef;
        var args = self.args;
        string argreg[];
        var arg;
        int np = predef.args();
        if (np == -1) {
            for (arg in args) {
                string reg = arg.emit_get(e);
                argreg.push(reg);
            }
        }
        else {
            int n = self.args;
            for (int i = 0; i < n; ++i) {
                arg = args[i];
                string type = predef.argtype(i);
                string argr = self.tempreg(type);
                if (type == 'P') {
                    string rtype = arg.checkResult();
                    string nreg = '';
                    switch (rtype) {
                    case 'I': nreg = 'Integer'; break;
                    case 'N': nreg = 'Float'; break;
                    case 'S': nreg = 'String'; break;
                    }
                    if (nreg != '')
                        e.say('new ', argr, ", '", nreg , "'");
                }
                arg.emit(e, argr);
                argreg.push(argr);
            }
        }
        self.predef.expand(e, self.start, result, argreg);
    }
}

//*********************************************

class CallExpr : Expr
{
    var funref;
    var args;

    function parse(tk, owner, start, subexp)
    {
        self.initexpr(owner, start);
        self.funref = subexp;
        self.args = [];
        var t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            do {
                var expr = parseExpr(tk, owner);
                self.args.push(expr);
            } while ((t = tk.get()).isop(','));
            if (! t.isop(')'))
                SyntaxError("Expected ')' or ','", t);
        }
        return self;
    }
    function checkResult() { return 'P'; }
    function optimize()
    {
        self.funref = self.funref.optimize();
        var args = self.args;
        int n = args;
        for (int i= 0; i < n; ++i)
            args[i] = args[i].optimize();

        // Check for predefined functions
        var funref = self.funref;
        if (funref.isidentifier()) {
            string call = funref.getName();
            var predef = findpredef(call, n);
            if (predef != null)
                return new CallPredefExpr().init(self.owner, self.start, predef, self.args);
        }

        return self;
    }
    function emit(e, result)
    {
        var funref = self.funref;
        string call;
        if (funref.isidentifier()) {
            call = funref.checkIdentifier();
            if (call == '')
                call = funref.getName();
        }
        else {
            if (funref instanceof MemberExpr) {
                call = funref.emit_left_get(e);
            }
            else
                call = funref.emit_get(e);
        }
        string argreg[];
        for (var arg in self.args) {
            string reg;
            if (arg.isnull()) {
                reg = self.tempreg('P');
                e.say('null ', reg);
            }
            else
                reg = arg.emit_get(e);
            argreg.push(reg);
        }
        e.annotate(self.start);
        if (result != null)
            e.print(result, ' = ');

        if (funref instanceof MemberExpr)
            e.print(call, ".'", funref.get_member(), "'");
        else
            e.print(call);
        e.print('(');

        string sep = '';
        for (string a in argreg) {
            e.print(sep, a);
            sep = ', ';
        }
        e.say(')');
    }
}

//*********************************************

class MemberExpr : Expr
{
    var left;
    var right;

    function checkResult() { return 'P'; }
    function parse(tk, owner, start, subexp)
    {
        self.initexpr(owner, start);
        self.left = subexp;
        self.right = tk.get();
        return self;
    }
    function optimize()
    {
        self.left = self.left.optimize();
        return self;
    }
    function get_member()
    {
        return self.right;
    }
    function emit_left_get(e)
    {
        return self.left.emit_get(e);
    }
    function emit_get(e)
    {
        string obj = self.left.emit_get(e);
        string ident = self.right.getidentifier();
        string result = self.tempreg('P');
        e.say('getattribute ', result, ', ', obj, ", '", ident, "'");
        return result;
    }
    function emit(e, result)
    {
        string obj = self.left.emit_get(e);
        string ident = self.right.getidentifier();
        e.say('getattribute ', result, ', ', obj, ", '", ident, "'");
    }
    function emit_assign(e, string typeright, string rreg)
    {
        string obj = self.left.emit_get(e);
        string ident = self.right.getidentifier();
        string value;
        if (typeright == 'P') {
            // Special case temporarily
            if (rreg == 'null') {
                rreg = self.tempreg('P');
                e.say('null ', rreg);
            }
            value = rreg;
        }
        else {
            value = self.tempreg('P');
            e.say('box ', value, ', ', rreg);
        }
        e.say("setattribute ", obj, ", '", ident, "', ", value);
    }
    function emit_assign_get(e, expr)
    {
        string obj = self.left.emit_get(e);
        string ident = self.right.getidentifier();
        string value = self.tempreg('P');
        if (expr.isnull())
            e.say('null ', value);
        else {
            string rreg = expr.emit_get(e);
            if (expr.checkResult() != 'P')
                e.say('box ', value, ', ', rreg);
            else
                value = rreg;
        }
        e.say("setattribute ", obj, ", '", ident, "', ", value);
        return value;
    }
}

//*********************************************

class IndexExpr : Expr
{
    var left;
    var args;

    function checkResult() { return 'P'; }
    function parse(tk, owner, start, subexp)
    {
        self.initexpr(owner, start);
        self.left = subexp;
        self.args = new 'ResizablePMCArray';
        var t;
        do {
            var arg = parseExpr(tk, owner);
            self.args.push(arg);
        } while ( (t= tk.get()).isop(','));
        if (! t.isop(']'))
            SyntaxError("Expected ']' or ',' in index expr", t);
        return self;
    }
    function emit(e, result)
    {
        var regleft;
        if (self.left.isidentifier())
            regleft = self.left.getIdentifier();
        else
            regleft = self.left.emit_get(e);
        string argregs[];
        for (var arg in self.args) {
            string argreg = arg.emit_get(e);
            argregs.push(argreg);
        }
        e.print(result, ' = ', regleft, '[');
        string sep = '';
        for (string reg in argregs) {
            e.print(sep, reg);
            sep = ', ';
        }
        e.say(']');
    }
    function emit_assign(e, string typeright, string rreg)
    {
        var regleft = self.left.emit_get(e);
        string argregs[];
        for (var arg in self.args) {
            string argreg = arg.emit_get(e);
            argregs.push(argreg);
        }
        e.annotate(self.start);
        e.print(regleft, '[');
        string sep = '';
        for (string reg in argregs) {
            e.print(sep, reg);
            sep = ', ';
        }
        e.say('] = ', rreg);
    }
    function emit_assign_get(e, expr)
    {
        var regleft = self.left.emit_get(e);
        string argregs[];
        for (var arg in self.args) {
            string argreg = arg.emit_get(e);
            argregs.push(argreg);
        }
        string rreg;
        if (expr.isnull()) {
            rreg = self.tempreg('P');
            e.say('null ', rreg);
        }
        else
            rreg = expr.emit_get(e);
        e.annotate(self.start);
        e.print(regleft, '[');
        string sep = '';
        for (string reg in argregs) {
            e.print(sep, reg);
            sep = ', ';
        }
        e.say('] = ', rreg);
        return rreg;
    }
}

//*********************************************

class ArrayExpr : Expr
{
    var values;

    function checkResult() { return 'P'; }
    function parse(tk, owner, start)
    {
        self.initexpr(owner, start);
        self.values = [];
        var t = tk.get();
        if (! t.isop(']')) {
            tk.unget(t);
            do {
                var item = parseExpr(tk, owner);
                self.values.push(item);
            } while ((t= tk.get()).isop(','));
            if (!t.isop(']'))
                SyntaxError("Expected ']' or ','", t);
        }
        return self;
    }
    function emit(e, result)
    {
        string value = self.emit_get(e);
        e.say('set ', result, ', ', value);
    }
    function emit_get(e)
    {
        e.annotate(self.start);
        string container = self.tempreg('P');
        e.say('root_new ', container, ", ['parrot';'ResizablePMCArray']");
        string it_p = self.tempreg('P');
        string itemreg;
        for (var item in self.values) {
            string type = item.checkResult();
            switch (type) {
            case 'I': case 'N': case 'S':
                string aux = item.emit_get(e);
                e.say('box ', it_p, ', ', aux);
                itemreg = it_p;
                break;
            default:
                itemreg = item.emit_get(e);
            }
            e.annotate(self.start);
            e.say(container, ".'push'(", itemreg, ")");
        }
        return container;
    }
}

//*********************************************

class HashExpr : Expr
{
    var values;

    function checkResult() { return 'P'; }
    function parse(tk, owner, start)
    {
        self.initexpr(owner, start);
        var t = tk.get();
        var values = new 'Hash';
        if (!t.isop('}')) {
            tk.unget(t);
            do {
                t = tk.get();
                if (!(t.isstring() || t.isidentifier()))
                    SyntaxError("Expected key", t);
                string key = t;
                ExpectOp(':', tk);
                var value = parseExpr(tk, owner);
                values[key] = value;
            } while ((t = tk.get()).isop(','));
            if (! t.isop('}'))
                SyntaxError("Expected ',' or '}'", t);
        }
        self.values = values;
        return self;
    }
    function emit(e, result)
    {
        e.annotate(self.start);
        e.say('root_new ', result, ", ['parrot';'Hash']");
        var values = self.values;
        for (string item in values) {
            var value = values[item];
            string itemreg;
            if (value.isidentifier()) {
                if (value.checkIdentifier() != '')
                    itemreg = value.emit_get(e);
                else {
                    string id = value.getName();
                    itemreg = self.tempreg('P');
                    e.say('get_hll_global ', itemreg, ", '", id, "'");
                }
            }
            else
                itemreg = value.emit_get(e);
            if (result == itemreg)
                InternalError('Failure in temp register allocation');
            e.say(result, '[', item, '] = ', itemreg);
        }
    }
    function emit_get(e)
    {
        string container = self.tempreg('P');
        self.emit(e, container);
        return container;
    }
}

//*********************************************

class NewExpr : Expr
{
    var value;
    var initializer;

    function checkResult() { return 'P'; }
    function parse(tk, owner, start)
    {
        self.initexpr(owner, start);
        self.owner = owner;

        var value = tk.get();
        if (! (value.isstring() || value.isidentifier()))
            SyntaxError("Unimplemented", value);
        var t = tk.get();
        if (value.isidentifier() ) {
            if (t.isop('.')) {
                string values [];
                values.push(value);
                do {
                    value = tk.get();
                    if (! value.isidentifier() )
                        Expected('identifier', value);
                    values.push(value);
                } while ((t= tk.get()).isop('.'));
                self.value = values;
            }
            else
                self.value = value;
        }
        else
            self.value = value;

        if (t.isop('(')) {
            t = tk.get();
            if (! t.isop(')')) {
                tk.unget(t);
                self.initializer = parseExpr(tk, owner);
                ExpectOp(')', tk);
            }
        }
        else
            tk.unget(t);
        return self;
    }
    function emit(e, result)
    {
        e.annotate(self.start);
        string reginit = '';
        if (self.initializer != null) {
            reginit = self.initializer.emit_get(e);
            reginit = ', ' + reginit;
        }
        if (self.value instanceof 'ResizableStringArray') {
            e.print('new ', result, ", [");
            string sep = '';
            for (string value in self.value) {
                e.print(sep, "'", value, "'");
                sep = ';';
            }
            e.say("]", reginit);
        }
        else if (self.value.isstring())
            e.say('root_new ', result, ", ['parrot'; ", self.value, " ]", reginit);
        else if (self.value.isidentifier())
            e.say('new ', result, ", ['", self.value, "']", reginit);
        else
            InternalError('Unexpected type in new');
    }
}

//*********************************************

class OpInstanceOfExpr : Expr
{
    var eleft;
    var checked;

    function checkResult() { return 'I'; }
    function parse(owner, start, eleft, tk)
    {
        self.initexpr(owner, start);
        self.eleft = eleft;
        self.checked= tk.get();
        return self;
    }
    function emit(e, result)
    {
        var checked = self.checked;
        string checkedval;
        if (checked.isidentifier()) {
           checkedval = checked.getidentifier();
           checkedval = "'" + checkedval + "'";
        }
        else
            checkedval = checked;
        string r = self.eleft.emit_get(e);
        e.annotate(self.start);
        e.say('isa ', result, ', ', r, ', ', checkedval);
    }
}

//*********************************************
//           Expressions parser
//*********************************************

const int Code_none          =  0;
const int Code_paren         =  1;
const int Code_bracket       =  2;
const int Code_dot           =  3;
const int Code_assign        =  4;
const int Code_assign_to     =  5;
const int Code_add_assign    =  6;
const int Code_add           =  7;
const int Code_minus         =  8;
const int Code_inc           =  9;
const int Code_dec           = 10;
const int Code_not           = 11;
const int Code_equal         = 12;
const int Code_not_equal     = 13;
const int Code_less          = 14;
const int Code_less_equal    = 15;
const int Code_greater       = 16;
const int Code_greater_equal = 17;
const int Code_sub_assign    = 18;
const int Code_mul           = 19;
const int Code_div           = 20;
const int Code_mod           = 21;
const int Code_cmod          = 22;

function getOpCode_2(t)
{
    switch (t.checkop()) {
    case '(': return Code_paren;
    case '[': return Code_bracket;
    case '.': return Code_dot;
    default:  return Code_none;
    }
}

function getOpCode_4(t)
{
    switch (t.checkop()) {
    case '-':  return Code_minus;
    case '!':  return Code_not;
    case '++': return Code_inc;
    case '--': return Code_dec;
    default:   return Code_none;
    }
}

function getOpCode_5(t)
{
    switch (t.checkop()) {
    case '*':  return Code_mul;
    case '/':  return Code_div;
    case '%':  return Code_mod;
    case '%%': return Code_cmod;
    default:   return Code_none;
    }
}

function getOpCode_9(t)
{
    switch (t.checkop()) {
    case '<':  return Code_less;
    case '>':  return Code_greater;
    case '<=': return Code_less_equal;
    case '>=': return Code_greater_equal;
    default:   return Code_none;
    }
}

function getOpCode_16(t)
{
    switch (t.checkop()) {
    case '=':  return Code_assign;
    case '=:': return Code_assign_to;
    case '+=': return Code_add_assign;
    case '-=': return Code_sub_assign;
    default:   return Code_none;
    }
}

function parseExpr_0(tk, owner)
{
    var t= tk.get();
    var expr;
    if (t.isop('(')) {
        expr = parseExpr(tk, owner);
        ExpectOp(')', tk);
        return expr;
    }
    if (t.isop('['))
        return new ArrayExpr().parse(tk, owner, t);
    if (t.isop('{'))
        return new HashExpr().parse(tk, owner, t);
    if (t.iskeyword('new'))
        return new NewExpr().parse(tk, owner, t);
    if (t.isstring())
        return new StringLiteral().set(owner, t);
    if (t.isint())
        return new IntegerLiteral().set(owner, t);
    if (t.isfloat())
        return new FloatLiteral().set(owner, t);
    if (t.isidentifier())
        return new IdentifierExpr().set(owner, t);
    SyntaxError('Lots of things unsupported', t);
}

function parseExpr_2(tk, owner)
{
    var subexp = parseExpr_0(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_2(t = tk.get())) != Code_none ) {
        switch(code) {
        case Code_paren:
            subexp = new CallExpr().parse(tk, owner, t, subexp);
            break;
        case Code_bracket:
            subexp = new IndexExpr().parse(tk, owner, t, subexp);
            break;
        case Code_dot:
            subexp = new MemberExpr().parse(tk, owner, t, subexp);
            break;
        default:
            InternalError('Unexpected code in parseExpr_2');
        }
    }
    tk.unget(t);
    return subexp;
}

function parseExpr_3(tk, owner)
{
    var subexp = parseExpr_2(tk, owner);
    var t = tk.get();
    if (t.isop('++'))
        return new OpPostIncExpr().set(owner, t, subexp);
    else if (t.isop('--'))
        return new OpPostDecExpr().set(owner, t, subexp);
    else
    {
        tk.unget(t);
        return subexp;
    }
}

function parseExpr_4(tk, owner)
{
    var t = tk.get();
    int code = getOpCode_4(t);
    var subexpr;
    if  (code != Code_none) {
        subexpr = parseExpr_4(tk, owner);
        var oper;
        switch (code) {
        case Code_minus:
            oper = new OpUnaryMinusExpr();
            break;
        case Code_not:
            oper = new OpNotExpr();
            break;
        case Code_inc:
            oper = new OpPreIncExpr();
            break;
        case Code_dec:
            oper = new OpPreDecExpr();
            break;
        default:
            InternalError('Invalid code in parseExpr_4', t);
        }
        subexpr = oper.set(owner, t, subexpr);
    }
    else {
        tk.unget(t);
        subexpr =  parseExpr_3(tk, owner);
    }
    return subexpr;
}

function parseExpr_5(tk, owner)
{
    var eleft= parseExpr_4(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_5(t= tk.get())) != Code_none) {
        var eright= parseExpr_4(tk, owner);
        var aux;
        switch (code) {
        case Code_mul:
            aux = new OpMulExpr();
            break;
        case Code_div:
            aux = new OpDivExpr();
            break;
        case Code_mod:
            aux = new OpModExpr();
            break;
        case Code_cmod:
            aux = new OpCModExpr();
            break;
        default:
            InternalError('Invalid code in parseExpr_5', t);
        }
        aux.set(owner, t, eleft, eright);
        eleft = aux;
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_6(tk, owner)
{
    var eleft= parseExpr_5(tk, owner);
    var t;
    while ((t= tk.get()).isop('+') || t.isop('-')) {
        var eright= parseExpr_5(tk, owner);
        var expr;
        if (t.isop('+'))
            expr= new OpAddExpr().set(owner, t, eleft, eright);
        else
            expr= new OpSubExpr().set(owner, t, eleft, eright);
        eleft= expr;
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_8(tk, owner)
{
    var eleft = parseExpr_6(tk, owner);
    var t;
    while ((t= tk.get()).isop('==') || t.isop('!=') || t.iskeyword('instanceof')) {
        if (t.isop('==')) {
            var eright = parseExpr_6(tk, owner);
            eleft = new OpEqualExpr().set(owner, t, eleft, eright);
        }
        else if (t.isop('!=')) {
            var eright = parseExpr_6(tk, owner);
            eleft = new OpNotEqualExpr().set(owner, t, eleft, eright);
        }
        else { // instanceof
            eleft = new OpInstanceOfExpr().parse(owner, t, eleft, tk);
        }
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_9(tk, owner)
{
    var eleft = parseExpr_8(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_9(t= tk.get())) != Code_none) {
        var eright = parseExpr_8(tk, owner);
        switch (code) {
        case Code_less:
            eleft = new OpLessExpr().set(owner, t, eleft, eright);
            break;
        case Code_greater:
            eleft = new OpGreaterExpr().set(owner, t, eleft, eright);
            break;
        case Code_less_equal:
            eleft = new OpLessEqualExpr().set(owner, t, eleft, eright);
            break;
        case Code_greater_equal:
            eleft = new OpGreaterEqualExpr().set(owner, t, eleft, eright);
            break;
        default:
            InternalError('Invalid code in parseExpr_9', t);
        }
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_10(tk, owner)
{
    var eleft = parseExpr_9(tk, owner);
    var t;
    while ((t = tk.get()).isop('&')) {
        var eright = parseExpr_9(tk, owner);
        eleft = new OpBinAndExpr().set(owner, t, eleft, eright);
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_12(tk, owner)
{
    var eleft = parseExpr_10(tk, owner);
    var t;
    while ((t = tk.get()).isop('|')) {
        var eright = parseExpr_10(tk, owner);
        eleft = new OpBinOrExpr().set(owner, t, eleft, eright);
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_13(tk, owner)
{
    var eleft = parseExpr_12(tk, owner);
    var t;
    while ((t= tk.get()).isop('&&')) {
        var eright = parseExpr_12(tk, owner);
        eleft = new OpBoolAndExpr().set(owner, t, eleft, eright);
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_14(tk, owner)
{
    var eleft = parseExpr_13(tk, owner);
    var t;
    while ((t= tk.get()).isop('||')) {
        var eright = parseExpr_12(tk, owner);
        eleft = new OpBoolOrExpr().set(owner, t, eleft, eright);
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_16(tk, owner)
{
    var eleft = parseExpr_14(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_16(t = tk.get())) != Code_none ) {
        var eright = parseExpr_16(tk, owner);
        var expr;
        switch (code) {
        case Code_assign:
            expr = new OpAssignExpr();
            break;
        case Code_assign_to:
            expr = new OpAssignToExpr();
            break;
        case Code_add_assign:
            expr = new OpAddToExpr();
            break;
        case Code_sub_assign:
            expr = new OpSubToExpr();
            break;
        default:
            InternalError('Unexpected code in parseExpr_16', t);
        }
        expr.set(owner, t, eleft, eright);
        eleft = expr;
    }
    tk.unget(t);
    return eleft;
}

function parseExpr(tk, owner)
{
    return parseExpr_16(tk, owner);
}

//*********************************************
//         Breakable and Continuable
//*********************************************

// Abstract base class for statments that can contain break
// and continue statments. Continuable is always breakable.

class Breakable
{
    var brlabel;

    function genbreaklabel()
    {
        if (self.brlabel != null)
            InternalError('attempt to generate break label twice');
        string label = self.genlabel();
        self.brlabel = label;
        return label;
    }
    function getbreaklabel(pos)
    {
        var label = self.brlabel;
        if (label == null)
            InternalError('attempt to get break label before creating it');
        return label;
    }
}

class Continuable : Breakable
{
    var cntlabel;

    function gencontinuelabel()
    {
        if (self.cntlabel != null)
            InternalError('attempt to generate continue label twice');
        string label = self.genlabel();
        self.cntlabel = label;
        return label;
    }
    function getcontinuelabel(pos)
    {
        var label = self.cntlabel;
        if (label == null)
            InternalError('attempt to get continue label before creating it');
        return label;
    }
}

//*********************************************
//            ReturnYieldStatement
//*********************************************

// Return and Yield statements and a base class
// that does almost all.

class ReturnYieldStatement : Statement
{
    var values;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        var values = [];
        if (! t.isop(';')) {
            tk.unget(t);
            do {
                var expr = parseExpr(tk, self);
                values.push(expr);
            } while ((t = tk.get()).isop(','));
        }
        RequireOp(';', t);
        self.values = values;
        return self;
    }
    function optimize()
    {
        var values = self.values;
        int n = values;
        for (int i= 0; i < n; ++i)
            values[i] = values[i].optimize();
        return self;
    }
    function emit(e)
    {
        var args = [];
        var values = self.values;
        int n = values;
        for (int i= 0; i < n; ++i) {
            var value = values[i];
            string reg;
            if (value.isnull()) {
                reg = self.tempreg('P');
                e.say('null ', reg);
            }
            else
                reg = value.emit_get(e);
            args.push(reg);
        }
        self.annotate(e);
        self.emitret(e);
        string sep = '';
        for (string arg in args) {
            e.print(sep, arg);
            sep= ', ';
        }
        e.say(')');
    }
}

class ReturnStatement : ReturnYieldStatement
{
    function emitret(e)
    {
        e.print('.return(');
    }
}

class YieldStatement : ReturnYieldStatement
{
    function emitret(e)
    {
        e.print('.yield(');
    }
}

//*********************************************
//            LabelStatement
//*********************************************

class LabelStatement : Statement
{
    var name;
    var value;
    function set(n, owner)
    {
        self.initstatement(n, owner);
        self.name= n;
        string value= self.owner.createlabel(n);
        self.value= value;
        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        e.say(self.value, ': # label ', self.name);
    }
}

//*********************************************
//            GotoStatement
//*********************************************

class GotoStatement : Statement
{
    var label;
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t= tk.get();
        if (!t.isidentifier())
            SyntaxError('Identifier expected', t);
        string s= t;
        self.label= t;
        ExpectOp(';', tk);
        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        string value= self.getlabel(self.label);
        e.say('goto ', value, ' # goto ', self.label);
    }
}

//*********************************************
//            IfStatement
//*********************************************

class IfStatement : Statement
{
    var condition;
    var truebranch;
    var falsebranch;
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t= tk.get();
        RequireOp('(', t);
        self.condition = parseExpr(tk, self);
        ExpectOp(')', tk);
        self.truebranch = parseStatement(tk, self);
        t = tk.get();
        if (t.iskeyword("else"))
            self.falsebranch = parseStatement(tk, self);
        else {
            self.falsebranch = new EmptyStatement();
            tk.unget(t);
        }
        return self;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        self.truebranch = self.truebranch.optimize();
        self.falsebranch = self.falsebranch.optimize();
        return self;
    }
    function emit(e)
    {
        var truebranch = self.truebranch;
        var falsebranch = self.falsebranch;
        int t_empty = truebranch.isempty();
        int f_empty = falsebranch.isempty();
        string elselabel = '';
        if (! f_empty)
            elselabel = self.genlabel();
        string endlabel = self.genlabel();
        string cond_false;
        if (elselabel == '')
            cond_false = endlabel;
        else
            cond_false = elselabel;
        self.annotate(e);
        var condition = self.condition;
        string type = condition.checkResult();

        //string reg = self.tempreg(type);
        //condition.emit(e, reg);
        string reg = condition.emit_get(e);

        switch(type) {
        case 'S':
        case 'P':
            e.say('if_null ', reg, ', ', cond_false);
        case 'I':
        case 'N':
            e.say('unless ', reg, ' goto ', cond_false);
            break;
        default:
            InternalError('Invalid if condition');
        }

        truebranch.emit(e);

        if (! f_empty) {
            e.say('goto ', endlabel);
            e.say(elselabel, ': # else');
            falsebranch.emit(e);
        }
        e.say(endlabel, ': # endif');
    }
}

//*********************************************
//            WhileStatement
//*********************************************

class WhileStatement : Continuable, Statement
{
    var condition;
    var body;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t= tk.get();
        RequireOp('(', t);
        self.start = t;
        self.condition = parseExpr(tk, self);
        ExpectOp(')', tk);
        self.body = parseStatement(tk, self);
        return self;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        string breaklabel = self.genbreaklabel();
        string continuelabel = self.gencontinuelabel();

        self.annotate(e);
        e.say(continuelabel, ': # while');

        var condition = self.condition;
        string type = condition.checkResult();
        string reg = condition.emit_get(e);
        switch(type) {
        case 'S':
        case 'P':
            e.say('if_null ', reg, ', ', breaklabel);
        case 'I':
        case 'N':
            e.say('unless ', reg, ' goto ', breaklabel);
            break;
        default:
            InternalError('Invalid if condition');
        }

        self.body.emit(e);
        e.say('goto ', continuelabel);
        e.say(breaklabel, ': # endwhile');
    }
}

//*********************************************
//            DoStatement
//*********************************************

class DoStatement : Continuable, Statement
{
    var condition;
    var body;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t= tk.get();
        tk.unget(t);

        self.body = parseStatement(tk, self);
        ExpectKeyword('while', tk);
        ExpectOp('(', tk);
        self.condition = parseExpr(tk, self);
        ExpectOp(')', tk);
        return self;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        string looplabel = self.genlabel();
        string breaklabel = self.genbreaklabel();
        string continuelabel = self.gencontinuelabel();

        self.annotate(e);
        e.say(looplabel, ': # do');

        self.body.emit(e);

        var condition = self.condition;
        string type = condition.checkResult();
        e.say(continuelabel, ': # do while condition');
        string reg = condition.emit_get(e);
        switch(type) {
        case 'S':
        case 'P':
            e.say('if_null ', reg, ', ', breaklabel);
        case 'I':
        case 'N':
            e.say('if ', reg, ' goto ', looplabel);
            break;
        default:
            InternalError('Invalid if condition');
        }
        e.say(breaklabel, ': # enddo');
    }
}

//*********************************************
//            ContinueStatement
//*********************************************

class ContinueStatement : Statement
{
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        ExpectOp(';', tk);
        return self;
    }
    function emit(e)
    {
        string label = self.getcontinuelabel(self.start);
        e.say('goto ', label, ' # continue');
    }
}

//*********************************************
//            BreakStatement
//*********************************************

class BreakStatement : Statement
{
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        ExpectOp(';', tk);
        return self;
    }
    function emit(e)
    {
        string label = self.getbreaklabel(self.start);
        e.say('goto ', label, ' # break');
    }
}

//*********************************************
//            SwitchStatement
//*********************************************

class SwitchStatement : Breakable, Statement
{
    var condition;
    var case_value;
    var case_st;
    var default_st;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        if (! t.isop('('))
            SyntaxError("Expected '(' in switch", t);
        self.condition = parseExpr(tk, self);
        t = tk.get();
        if (! t.isop(')'))
            SyntaxError("Expected ')' in switch", t);
        t = tk.get();
        if (! t.isop('{'))
            SyntaxError("Expected '{' in switch", t);
        self.case_value = [];
        self.case_st = [];
        self.default_st = [];
        while ((t = tk.get()).iskeyword('case') || t.iskeyword('default')) {
            if (t.iskeyword('case')) {
                self.case_value.push(parseExpr(tk, self));
                t = tk.get();
                if (! t.isop(':'))
                    SyntaxError("Expected ':' in case", t);
                var st = [];
                while (! ((t = tk.get()).isop('}') || t.iskeyword('case') || t.iskeyword('default'))) {
                    tk.unget(t);
                    st.push(parseStatement(tk, self));
                }
                self.case_st.push(st);
                tk.unget(t);
            }
            else {
                t = tk.get();
                if (! t.isop(':'))
                    SyntaxError("Expected ':' in default", t);
                while (! ((t = tk.get()).isop('}') || t.iskeyword('case') || t.iskeyword('default'))) {
                    tk.unget(t);
                    self.default_st.push(parseStatement(tk, self));
                }
                tk.unget(t);
            }
        }
        return self;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        var caseval = self.case_value;
        int n = caseval;
        int i;
        for (i = 0; i < n; ++i)
            caseval[i] = caseval[i].optimize();
        for (var casest in self.case_st) {
            n = casest;
            for (i = 0; i < n; ++i)
                casest[i] = casest[i].optimize();
        }
        var defaultst = self.default_st;
        n = defaultst;
        for (i = 0; i < n; ++i)
            defaultst[i] = defaultst[i].optimize();
        return self;
    }
    function emit(e)
    {
        // Get case common type
        string type = '';
        for (var value in self.case_value) {
            string t = value.checkResult();
            if (t == 'N')
                SyntaxError("Invalid type in case", self.start);
            if (type == '')
                type = t;
            else if (type != t)
                type = 'P';
        }
        // Evaluate condition
        string reg = self.tempreg(type);
        if (self.condition.checkResult() == type)
            self.condition.emit(e, reg);
        else {
            string regcond = self.condition.emit_get(e);
            e.say('set ', reg, ', ', regcond);
        }

        // Prpeare labels and check values
        self.genbreaklabel();
        string defaultlabel = self.genlabel();
        string caselabel[];
        string regval = self.tempreg(type);
        for (var caseval in self.case_value) {
            string label = self.genlabel();
            caselabel.push(label);
            caseval.emit(e, regval);
            e.say('if ', reg, ' == ', regval, ' goto ', label);
        }
        e.say('goto ', defaultlabel);

        // Emit cases
        e.comment('switch');
        self.annotate(e);
        var case_st = self.case_st;
        int n = case_st;
        for (int i= 0; i < n; ++i) {
            string l = caselabel[i];
            e.say(l, ': # case');
            var casest = case_st[i];
            for (var st in casest)
                st.emit(e);
        }
        // Emit default
        e.say(defaultlabel, ': # default');
        for (var dst in self.default_st)
            dst.emit(e);

        e.say(self.getbreaklabel(self.start), ':');
        e.comment('switch end');
    }
}

//*********************************************
//            ForStatement
//*********************************************

class ForStatement : Continuable, BlockStatement
{
    var initializer;
    var condition;
    var iteration;
    var body;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            self.initializer = parseStatement(tk, self);
        }
        t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            self.condition = parseExpr(tk, self);
            ExpectOp(';', tk);
        }
        t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            self.iteration = parseExpr(tk, self);
            ExpectOp(')', tk);
        }
        self.body = parseStatement(tk, self);
        return self;
    }
    function optimize()
    {
        if (self.initializer != null)
            self.initializer = self.initializer.optimize();
        if (self.condition != null)
            self.condition = self.condition.optimize();
        if (self.iteration != null)
            self.iteration = self.iteration.optimize();
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        e.comment('for loop');
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        string condlabel = self.genlabel();
        if (self.initializer != null)
            self.initializer.emit(e);
        e.say('goto ', condlabel);

        e.say(continuelabel, ': # for iteration');
        if (self.iteration != null)
            string unused = self.iteration.emit_get(e);

        e.say(condlabel, ': # for condition');
        if (self.condition != null) {
            string regcond = self.condition.emit_get(e);
            e.say('unless ', regcond, ' goto ', breaklabel, ' # for end');
        }

        self.body.emit(e);
        e.say('goto ', continuelabel, ' # for iteration');

        e.say(breaklabel, ': # for end');
    }
}

//*********************************************
//            ForeachStatement
//*********************************************

class ForeachStatement : Continuable, BlockStatement
{
    var varname;
    var container;
    var body;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var name = tk.get();
        string sname = name;
        string type = '';
        switch (sname)
        {
        case 'int':
            type = 'I'; break;
        case 'float':
            type = 'N'; break;
        case 'string':
            type = 'S'; break;
        case 'var':
            type = 'P'; break;
        }
        if (type != '') {
            name = tk.get();
            sname = name;
            self.createvar(sname, type);
        }
        var aux= tk.get();
        self.varname = name;
        self.container = parseExpr(tk, self);
        aux = tk.get();
        if (!aux.isop(')'))
            SyntaxError("Expected ')'", aux);
        self.body = parseStatement(tk, self);

        return self;
    }
    function optimize()
    {
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        string regcont = self.container.emit_get(e);
        var itvar = self.getvar(self.varname);
        string iterator = self.createreg('P');
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        e.say('iter ', iterator, ', ', regcont);
        e.say('set ', iterator, ', 0');
        e.say(continuelabel, ': # for iteration');
        e.say('unless ', iterator, " goto ", breaklabel);
        e.say('shift ', itvar['reg'], ', ', iterator);
        self.body.emit(e);
        e.say('goto ', continuelabel);
        e.say(breaklabel, ': # endfor');
    }
}

//*********************************************

function parseFor(t, tk, owner)
{
    ExpectOp('(', tk);
    var aux = tk.get();
    var in1 = tk.get();
    var in2 = tk.get();
    tk.unget(in2);
    tk.unget(in1);
    tk.unget(aux);
    if (in1.iskeyword('in') || in2.iskeyword('in'))
        return new ForeachStatement().parse(t, tk, owner);
    else
        return new ForStatement().parse(t, tk, owner);
}

//*********************************************
//            ThrowStatement
//*********************************************

class ThrowStatement : Statement
{
    var excep;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.excep = parseExpr(tk, self);
        return self;
    }
    function optimize()
    {
        self.excep = self.excep.optimize();
        return self;
    }
    function emit(e)
    {
        string reg = self.excep.emit_get(e);
        self.annotate(e);
        e.say('throw ', reg);
    }
}

//*********************************************
//            TryStatement
//*********************************************

class TryStatement : BlockStatement
{
    var stry;
    var modifiers;
    var exname;
    var scatch;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        if (t.isop('[')) {
            self.modifiers = new ModifierList().parse(tk, self);
        }
        else
            tk.unget(t);

        self.stry = parseStatement(tk, self);
        t = tk.get();
        if (! t.iskeyword('catch'))
            SyntaxError("Expected 'catch'", t);
        t = tk.get();
        if (! t.isop('('))
            SyntaxError("Excpected '(' after 'catch'", t);
        t = tk.get();
        if (! t.isop(')')) {
            string exname = t.getidentifier();
            self.exname = t;
            self.createvar(exname, 'P');
            t = tk.get();
            if (! t.isop(')'))
                SyntaxError("Excpected ')' in 'catch'", t);
        }
        self.scatch = parseStatement(tk, self);
        return self;
    }
    function optimize()
    {
        if (self.modifiers != null)
            self.modifiers.optimize();
        self.stry = self.stry.optimize();
        self.scatch = self.scatch.optimize();
        return self;
    }
    function emit(e)
    {
        string reghandler = self.tempreg('P');
        string labelhandler = self.genlabel();
        string labelpasthandler = self.genlabel();
        string exreg;
        if (self.exname != null) {
            var exname = self.getvar(self.exname);
            exreg = exname['reg'];
        }
        else
            exreg = self.tempreg('P');

        self.annotate(e);

        e.say('new ', reghandler, ", 'ExceptionHandler'");
        e.say('set_addr ', reghandler, ', ', labelhandler);

        if (self.modifiers != null) {
            var modiflist = self.modifiers.getlist();
            for (var modif in modiflist) {
                string modifname = modif.getname();
                int nargs = modif.numargs();
                switch (modifname) {
                case 'min_severity':
                case 'max_severity':
                    if (nargs != 1)
                        SyntaxError('Wrong modifier args', self.start);
                    var arg = modif.getarg(0);
                    string argreg = arg.emit_get(e);
                    e.say(reghandler, ".'", modifname, "'(", argreg, ")");
                    break;
                case 'handle_types':
                    string argregs [];
                    for (int i= 0; i < nargs; ++i) {
                        var arg = modif.getarg(i);
                        argregs.push(arg.emit_get(e));
                    }
                    e.print(reghandler, ".'", modifname, "'(");
                    string sep = '';
                    for (string argreg in argregs) {
                        e.print(sep, argreg);
                        sep = ', ';
                    }
                    e.say(")");
                    break;
                default:
                    SyntaxError('Unexpected modifier in try', self.start);
                }
            }
        }

        e.say('push_eh ', reghandler);

        self.stry.emit(e);
        self.annotate(e);
        e.say('goto ', labelpasthandler);

        e.say(labelhandler, ':');
        e.say('.get_results(', exreg, ')');
        e.say('pop_eh');
        self.scatch.emit(e);

        e.say(labelpasthandler, ':');
    }
}

//*********************************************
//            DeclareStatement
//*********************************************

class DeclareStatement : Statement
{
    var name;
    var t_reg;
    var t_name;
    var t_array;
    var reg;
    var typearray;
    var size;
    var init;
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t= tk.get();
        if (!t.isidentifier())
            SyntaxError('Identifier expected', t);
        self.name= t;
        string reg;

        t= tk.get();
        if (t.isop('[')) {
            // Array
            self.typearray = 1;
            reg= self.createvar(self.name, 'P');
            t= tk.get();
            if (t.isop(']')) {
                // Variable length
                t= tk.get();
            }
            else {
                tk.unget(t);
                self.size = parseExpr(tk, self);
                t= tk.get();
                if (! t.isop(']'))
                    SyntaxError("Expected ']'", t);
                t= tk.get();
            }
        }
        else {
            // Simple
            self.typearray = 0;
            reg= self.createvar(self.name, self.t_reg);
            if (t.isop('=')) {
                // Simple initializer
                self.init = parseExpr(tk, self);
                t= tk.get();
            }
        }

        self.reg= reg;
        if (t.isop('=')) {
            //say('Initializer');
            t = tk.get();
            if (! t.isop('['))
                SyntaxError("Array initializer expected", t);
            self.init = new 'ResizablePMCArray';
            t = tk.get();
            if (! t.isop(']')) {
                tk.unget(t);
                do {
                    var item = parseExpr(tk, self);
                    self.init.push(item);
                } while ((t = tk.get()).isop(','));
                if (! t.isop(']'))
                    SyntaxError("Expected ',' or ']'", t);
            }
            t = tk.get();
        }
        if (!t.isop(';'))
            SyntaxError("Expected ';'", t);

        return self;
    }
    function optimize()
    {
        var init = self.init;
        if (init != null) {
            if (self.typearray == 0)
                self.init = init.optimize();
            else {
                int n = init;
                for (int i = 0; i < n; ++i)
                    init[i] = init[i].optimize();
            }
        }
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        string tname = self.t_name;
        string name = self.name;
        string reg = self.reg;
        string t_reg = self.t_reg;
        e.comment(tname + ' ' + name + ': ' + reg);

        if (self.typearray == 0) {
            if (self.init == null)
                self.defaultinit(e);
            else {
                e.comment('init');
                string itype = self.init.checkResult();
                if (itype == t_reg) {
                    e.comment('init same type');
                    self.init.emit(e, reg);
                }
                else {
                    if (self.init instanceof IndexExpr) {
                        // Use the declared type for the indexing
                        self.init.emit(e, reg);
                    }
                    else {
                        e.comment('init other type: ' + itype);
                        string ireg = self.tempreg(itype);
                        self.init.emit(e, ireg);
                        if (t_reg == 'S' && itype == 'P') {
                            string auxlabel = self.genlabel();
                            e.say('null ', reg);
                            e.say('if_null ', ireg, ', ', auxlabel);
                            e.say('set ', reg, ', ', ireg);
                            e.say(auxlabel, ':');
                        }
                        else
                            e.say('set ', reg, ', ', ireg);
                    }
                }
            }
        }
        else {
            var size = self.size;
            if (size != null) {
                // Fixed size array
                string regsize = size.emit_get(e);
                e.say('root_new ', self.reg, ", ['parrot'; 'Fixed", self.t_array, "Array']");
                e.say('set ', self.reg, ', ', regsize);
            }
            else {
                // Variable size array
                e.say('root_new ', self.reg, ", ['parrot'; 'Resizable", self.t_array, "Array']");
            }
            if (self.init != null) {
                string reg = self.tempreg(t_reg);
                int n = self.init;
                if (size == null) {
                    if (n > 0) {
                        // Allocate initializers size
                        e.say('set ', self.reg, ', ', n);
                    }
                }
                int i= 0;
                for (var item in self.init) {
                    item.emit(e, reg);
                    e.say(self.reg, '[', i , '] = ', reg);
                    ++i;
                }
            }
        }
    }
    function defaultinit(var e)
    {
        InternalError('DeclareStatement.defaultinit must be overriden');
    }
}

//*********************************************
//            ConstStatement
//*********************************************

class ConstStatement : Statement
{
    var start;
    var type;
    var name;
    var value;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        self.type = t;
        t = tk.get();
        self.name = t;
        ExpectOp('=', tk);
        self.value = parseExpr(tk, owner);
        ExpectOp(';', tk);
        return self;
    }
    function optimize()
    {
        self.value = self.value.optimize();
        var value = self.value;
        if (! value.hascompilevalue()) {
            SyntaxError('Value for const is not evaluable at compile time',
                self.start);
        }
        string type;
        switch (self.type) {
        case 'int':
            type = 'I';
            break;
        case 'float':
            type = 'N';
            break;
        case 'string':
            type = 'S';
            break;
        default:
            SyntaxError('Invalid type for const', self.start);
        }
        self.createconst(self.name, type, value);
        return self;
    }
    function emit(e)
    {
        // Put a hint in the generated code
        string name = self.name;
        e.comment('Constant ' + name + ' evaluted at compile time');
    }
}

//*********************************************
//            VarStatement
//*********************************************

class VarStatement : Statement
{
    var name;
    var reg;
    var init;
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t= tk.get();
        if (!t.isidentifier())
            SyntaxError('Identifier expected', t);
        self.name= t;
        string reg= self.createvar(t, 'P');
        self.reg= reg;
        t= tk.get();
        if (t.isop('=')) {
            self.init = parseExpr(tk, self);
            t= tk.get();
        }
        if (!t.isop(';'))
            SyntaxError("Expected ';'", t);
        return self;
    }
    function optimize()
    {
        if (self.init != null)
            self.init = self.init.optimize();
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        string name=  self.name;
        string reg = self.reg;
        e.comment('var ' + name + ': ' + reg);
        if (self.init != null) {
            string type = self.init.checkResult();
            switch (type) {
            case 'P':
                self.init.emit(e, reg);
                break;
            case 'S':
            case 'I':
            case 'N':
                string value = self.tempreg(type);
                self.init.emit(e, value);
                e.say('box ', reg, ', ', value);
                break;
            default:
                SyntaxError("Invalid var initializer", self.name);
            }
        }
        else
            e.say('null ', reg);
    }
}

//*********************************************
//            StringStatement
//*********************************************

class StringStatement : DeclareStatement
{
    function init [vtable] ()
    {
        self.t_reg = 'S';
        self.t_name = 'string';
        self.t_array = 'String';
    }
    function defaultinit(var e)
    {
        e.say('null ', self.reg);
    }
}

//*********************************************
//            IntStatement
//*********************************************

class IntStatement : DeclareStatement
{
    function init [vtable] ()
    {
        self.t_reg = 'I';
        self.t_name = 'int';
        self.t_array = 'Integer';
    }
    function defaultinit(var e)
    {
        e.say('set ', self.reg, ', 0');
    }
}

//*********************************************
//            FloatStatement
//*********************************************

class FloatStatement : DeclareStatement
{
    function init [vtable] ()
    {
        self.t_reg = 'N';
        self.t_name = 'float';
        self.t_array = 'Number';
    }
    function defaultinit(var e)
    {
        e.say('set ', self.reg, ', 0.0');
    }
}

//*********************************************
//            CompoundStatement
//*********************************************

class CompoundStatement : BlockStatement
{
    var statements;
    var end;
    var labels;
    //var locals;

    function init [vtable] ()
    {
        self.labels= new 'Hash';
    }
    function getlabel(var name)
    {
        string s= name;
        var labels= self.labels;
        string exist= labels[s];
        if (exist == null || exist == '')
            exist = self.owner.getlabel(name);
        return exist;
    }
    function createlabel(var name)
    {
        string s= name;
        var labels= self.labels;
        string exist= labels[s];
        if (exist != null && exist != '')
            SyntaxError('Label already defined', name);
        string value= self.genlabel();
        labels[s]= value;
        return value;
    }
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.statements= [];
        var t;
        while (! (t= tk.get()).isop('}')) {
            tk.unget(t);
            var c = parseStatement(tk, self);
            if (c == null)
                throw InternalError('Unexpected null statement');
            self.statements.push(c);
        }
        self.end= t;
        return self;
    }
    function getend() { return self.end; }
    function optimize()
    {
        var st = self.statements;
        int n = st;
        for (int i = 0; i < n; ++i)
            st[i] = st[i].optimize();
        return self;
    }
    function emit(var e)
    {
        e.comment('{');
        for (var st in self.statements) {
            st.emit(e);
            self.freetemps();
        }
        e.comment('}');
    }
}

//*********************************************
//            RegisterStore
//*********************************************

class RegisterStore
{
    var type;
    var nreg;
    var tempreg;
    var freereg;
    function init [vtable]()
    {
        // Registers number 0 are reserved for temporary usage in predefs.
        self.nreg = 1;
        self.tempreg= new 'ResizableStringArray';
        self.freereg= new 'ResizableStringArray';
    }
    function settype(string type)
    {
        self.type = type;
        return self;
    }
    function createreg()
    {
        var n = self.nreg;
        int i = n;
        string reg= i++;
        n =: i;
        string type = self.type;
        reg = '$' + type + reg;
        return reg;
    }
    function tempreg()
    {
        var freg = self.freereg;
        var treg = self.tempreg;
        int n= freg;
        string reg;
        if (n > 0)
            reg= freg.pop();
        else {
            reg= self.createreg();
            treg.push(reg);
        }
        return reg;
    }
    function freetemps()
    {
        for (string s in self.tempreg)
            self.freereg.unshift(s);
        self.tempreg= new 'ResizableStringArray';
    }
}

//*********************************************
//            FunctionStatement
//*********************************************

class FunctionStatement : BlockStatement
{
    var name;
    var modifiers;
    var args;
    var body;
    var regstI;
    var regstN;
    var regstS;
    var regstP;
    var nlabel;

    function init [vtable]()
    {
        self.regstI = new RegisterStore().settype('I');
        self.regstN = new RegisterStore().settype('N');
        self.regstS = new RegisterStore().settype('S');
        self.regstP = new RegisterStore().settype('P');
        self.nlabel= 0;
    }
    function ismethod() { return 0; }
    function createreg(string type)
    {
        var store;
        switch(type) {
        case 'I':
            store = self.regstI; break;
        case 'N':
            store = self.regstN; break;
        case 'S':
            store = self.regstS; break;
        case 'P':
            store = self.regstP; break;
        default:
            InternalError('Invalid type in createreg');
        }
        string reg = store.createreg();
        return reg;
    }
    function tempreg(string type)
    {
        var store;
        switch(type) {
        case 'I':
            store = self.regstI; break;
        case 'N':
            store = self.regstN; break;
        case 'S':
            store = self.regstS; break;
        case 'P':
            store = self.regstP; break;
        default:
            InternalError("Invalid type in tempreg");
        }
        string reg = store.tempreg();
        return reg;
    }
    function freetemps()
    {
        for (var st in [ self.regstI, self.regstN, self.regstS, self.regstP ] )
            st.freetemps();
    }
    function genlabel()
    {
        var nlabel = self.nlabel;
        int n= nlabel;
        string s= '__label_' + n++;
        nlabel =: n;
        return s;
    }

    function optimize()
    {
        self.body = self.body.optimize();
        return self;
    }

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t= tk.get();
        self.name= t;
        t= tk.get();
        if (t.isop('[')) {
            var modifiers = new ModifierList().parse(tk, self);
            self.modifiers= modifiers;
            t= tk.get();
        }
        if (! t.isop('('))
            Expected('(', t);
        self.args = new 'ResizablePMCArray';
        t= tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            do {
                t= tk.get();
                string type = '';
                if (t.iskeyword('int'))
                    type = 'I';
                else if (t.iskeyword('float'))
                    type = 'F';
                else if (t.iskeyword('string'))
                    type = 'S';
                else if (t.iskeyword('var'))
                    type = 'P';
                if (type != '')
                    t= tk.get();
                else
                    type = 'P';
                self.createvar(t, type);

                string varname = t;
                var arg = { };
                arg['name'] = varname;
                t= tk.get();
                if (t.isop('[')) {
                    var modifiers = new ModifierList().parse(tk, self);
                    arg['modifiers'] = modifiers;
                    t = tk.get();
                }
                self.args.push(arg);
            } while (t.isop(','));
            if (!t.isop(')'))
                SyntaxError("Expected ')'", t);
        }

        t= tk.get();
        if (!t.isop('{'))
            Expected('{', t);
        self.body= new CompoundStatement().parse(t, tk, self);
        return self;
    }
    function emit(var e)
    {
        string name = self.name;
        e.say();
        e.print(".sub '", name, "'");
        if (self.ismethod())
            e.print(' :method');
        var modifiers= self.modifiers;
        if (modifiers != null) {
            var mlist = modifiers.getlist();
            for (var m in mlist)
                e.print(' :', m.getname());
        }
        else {
            if (name == 'main')
                e.print(' :main');
        }
        e.say();
        var args = self.args;
        var arg;
        string argname;
        var a;
        for (arg in args) {
            argname = arg['name'];
            a = self.getvar(argname);
            string type = a['type'];
            string ptype = 'pmc';
            switch (type) {
            case 'I': ptype = 'int'; break;
            case 'N': ptype = 'num'; break;
            case 'S': ptype = 'string'; break;
            }
            e.print('.param ', ptype, ' ', argname);
            var modarg = arg['modifiers'];
            if (modarg != null) {
                var modarglist = modarg.getlist();
                for (var mod in modarglist)
                    e.print(' :', mod.getname());
            }
            e.say('');
        }
        for (arg in args) {
            argname = arg['name'];
            a = self.getvar(argname);
            e.say('set ', a['reg'], ', ', argname);
        }
        e.say();
        e.annotate(self.name);
        e.comment('Body');
        self.body.emit(e);

        e.annotate(self.body.getend());
        e.say("\n.end # ", name, "\n");
    }
    function getbreaklabel(pos)
    {
        SyntaxError('break not allowed here', pos);
    }
    function getcontinuelabel(pos)
    {
        SyntaxError('continue not allowed here', pos);
    }
}

//*********************************************
//            MethodStatement
//*********************************************

class MethodStatement : FunctionStatement
{
    function ismethod() { return 1; }
}

//*********************************************
//            ClassStatement
//*********************************************

class ClassStatement : Item
{
    var parent;
    var name;
    var bases;
    var functions;
    var members;

    function isClass() { return 1; }
    function init [vtable] ()
    {
        self.functions = [];
        self.members = [];
        self.bases= [];
    }

    function getvar(name)
    {
        // Nothing for a now.
        return self.parent.getvar(name);
    }
    function parse(tk, parent)
    {
        self.parent= parent;
        var t= tk.get();
        self.name= t;
        t= tk.get();
        if (t.isop(':')) {
            var bases= self.bases;
            for (;;) {
                t= tk.get();
                bases.push(t);
                t= tk.get();
                if (!t.isop(',')) break;
            }
        }
        if (!t.isop('{'))
            Expected('{', t);
        t= tk.get();
        while (!t.isop('}')) {
            if (t.iskeyword('function')) {
                var f= new MethodStatement().parse(t, tk, self);
                var functions= self.functions;
                functions.push(f);
            }
            else if (t.iskeyword('var')) {
                var name = tk.get();
                if (! name.isidentifier())
                    SyntaxError("Expected member identifier", name);
                self.members.push(name);
                t = tk.get();
                if (! t.isop(';'))
                    SyntaxError("Expected ';' in member declaration", t);
            }
            t= tk.get();
        }
    }
    function optimize()
    {
        var f = self.functions;
        int n = f;
        for (int i = 0; i < n; ++i)
            f[i] = f[i].optimize();
        return self;
    }
    function emit(var e)
    {
        var classns= self.parent.getpath();
        classns.push(self.name);
        e.say(namespacekey(classns));
        for (var f in self.functions)
            f.emit(e);

        e.say('.sub Winxed_class_init :anon :load :init');

        e.say('newclass $P0, ', getkey(classns) );
        int n = 1;
        for (var base in self.bases) {
            string reg = "$P" + n++;
            e.print('get_class ', reg, ', ');
            if (base.isstring())
                e.say(base);
            else
                e.say("'", base, "'");
            e.comment(base);
            e.say('addparent $P0, ', reg);
        }
        for (var member in self.members) {
            e.annotate(member);
            e.say("addattribute $P0, '", member, "'");
        }

        e.say('.end');
    }
}

//*********************************************
//            Namespace
//*********************************************

class Namespace : Item, VarContainer
{
    var parent;
    var owner;
    var name;
    var namespaces;
    var classes;
    var functions;
    var items;

    function isNamespace() { return 1; }
    function init [vtable] ()
    {
        self.namespaces= [];
        self.classes= [];
        self.functions = [];
        self.items = [];
    }
    function init_child(parent, string name)
    {
        self.parent= parent;
        self.owner = parent;
        self.name= name;
    }
    function getpath()
    {
        if (self.parent != null) {
            var path=self.parent.getpath();
            path.push(self.name);
            return path;
        }
        else
        {
            string path[];
            return path;
        }
    }
    function parse(tk)
    {
        string namespace[];
        int balance1= 0;
        int balance2= 0;
        int balance3= 0;
        var t;
        while (t= tk.get())
        {
            if (t.iskeyword('namespace'))
            {
                t= tk.get();
                string name= t;
                namespace.push(name);
                t= tk.get();
                if (!t.isop('{'))
                    Expected('{', t);
                var child= new Namespace();
                child.init_child(self, name);
                self.namespaces.push(child);
                self.items.push(child);
                child.parse(tk);
            }
            else if (t.iskeyword('const')) {
                var cst = new ConstStatement().parse(t, tk, self);
                self.items.push(cst);
            }
            else if (t.iskeyword('function'))
            {
                var f= new FunctionStatement().parse(t, tk, self);
                var functions= self.functions;
                functions.push(f);
                self.items.push(f);
            }
            else if (t.iskeyword('class'))
            {
                var c= new ClassStatement();
                c.parse(tk, self);
                var classes= self.classes;
                classes.push(c);
                self.items.push(c);
            }
            else if (t.isop('}'))
            {
                int n= namespace;
                if (n < 1)
                {
                    if (self.parent != null) return;
                    string line= t.line;
                    SyntaxError('Unclosed namespace', t);
                }
                namespace.pop();
            }
            else
                SyntaxError("Unexpected token", t);
        }
    }
    function optimize()
    {
        var items = self.items;
        int n = items;
        for (int i = 0; i < n; ++i)
           items[i] = items[i].optimize();
        return self;
    }
    function emit(var e)
    {
        var path= self.getpath();
        string s= namespacekey(path);

        int activate= 1;
        for (var item in self.items) {
            if (item.isNamespace() || item.isClass())
                activate= 1;
            else
                if (activate) {
                    e.say(s);
                    activate= 0;
                }
            item.emit(e);
        }
    }
}

//*********************************************
//            MiniWinxed
//*********************************************

class MiniWinxed
{
    var rootns;
    function init [vtable] ()
    {
        self.rootns= new Namespace();
    }
    function parse(tk)
    {
        self.rootns.parse(tk);
    }
    function optimize()
    {
        self.rootns = self.rootns.optimize();
    }
    function emit(var e)
    {
        self.rootns.emit(e);
    }
}

function miniwinxed_parser(tk, string outputfile)
{
    var winxed= new MiniWinxed();
    winxed.parse(tk);

    winxed.optimize();

    var handle;
    if (outputfile == '-')
        handle = getinterp().stdhandle(1);
    else
        handle = new 'FileHandle'.open(outputfile, 'w');
    var emit= new Emit();
    emit.initialize(handle);
    winxed.emit(emit);
    emit.close();
    handle.close();
}

//*********************************************
//            Main functions
//*********************************************

function stage1(argv)
{
    using extern Getopt.Obj;
    var getopts = new Getopt.Obj();
    getopts.notOptStop(1);
    getopts.push_string('o=s');
    getopts.push_string('e=s');
    getopts.push_string('c');
    getopts.push_string('noan');

    argv.shift();
    var opts = getopts.get_options(argv);
    var opt_o = opts['o'];
    var opt_e = opts['e'];
    var opt_c = opts['c'];
    var noan  = opts['noan'];

    int argc= argv;
    string filename;
    string expr;
    var file;
    if (opt_e == null) {
        if (argc == 0)
            throw Error('No file');

        filename= argv[0];
        file = new 'FileHandle';
        file.open(filename); // Must throw on error
    }
    else {
        expr = opt_e;
        expr = 'function main[main](argv){' + expr + ';}';
        file = new 'StringHandle';
        file.open('__eval__', 'w');
        file.puts(expr);
        file.close();
        file.open('__eval__');
    }

    var t= new Tokenizer();
    t.init(file, filename);

    string outputfile = '';
    if (opt_o != null)
        outputfile = opt_o;
    miniwinxed_parser(t, outputfile);

    file.close();
}

function main(argv)
{
    try
            [
                min_severity(2),
                max_severity(2),
                handle_types(ERRORinternal, ERRORtokenizer, ERRORparser)
            ]
        stage1(argv);
    catch (e)
    {
        string msg= e['message'];
        say('Error: ', msg);
        var bt= e.backtrace();
        int i= 1;
        for (var t in bt) {
            var sub= t['sub'];
            string subname;
            if (sub != null) {
                subname= sub;
                string ns= sub.get_namespace();
                if (ns != '' && ns != 'parrot') subname= ns + '.' + subname;
            }
            var ann= t['annotations'];
            string file= ann['file'];
            if (file != '') {
                int line= ann['line'];
                say(' ' * (2 * i++), "at ", subname, " in '", file, "' line ", line);
            }
        }
    }
}

// End
