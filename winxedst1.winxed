#! winxed

/***********************************************************************
                   Winxed stage 1 compiler
***********************************************************************/

//*********************************************
//          Character test functions
//*********************************************

function isspace(string c)
{
    return c == ' ' || c == "\n" || c == "\t";
}

function isdigit(string c)
{
    return indexof('0123456789', c) > -1;
}

function hexdigit(string c)
{
    int i = indexof('0123456789abcdef0123456789ABCDEF', c);
    if (i >= 0) i = i % 16;
    return i;
}

function isidentstart(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_',
        c) > -1;
}

function isident(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_$' +
        '0123456789',
        c) > -1;
}


//*********************************************
//        Error handling exceptions
//*********************************************

const int
    ERRORinternal  = 555,
    ERRORtokenizer = 556,
    ERRORparser    = 557;

function Warn(string msg, var pos [optional], int has_pos [opt_flag])
{
    var stderr = getstderr();
    stderr.print('WARNING: ');
    stderr.print(msg);
    if (has_pos) {
        stderr.print(' near ');
        stderr.print(pos.show());
    }
    stderr.print("\n");
}

function InternalError(string msg, var pos [optional], int has_pos [opt_flag])
{
    if (has_pos) {
        string desc = pos.show();
        msg = msg + ' near ' + desc;
    }
    throw Error(msg, 2, ERRORinternal);
}

function TokenError(string msg, tk, int line)
{
   throw Error(msg + ' in '+ string(tk.filename) + ' line ' + string(line),
           2, ERRORtokenizer);
}

function SyntaxError(string msg, var pos)
{
    string sline= pos.line;
    string file= pos.file;
    string desc = pos.viewable();
    throw Error(msg + ' in '+ file + ' line ' + sline + ' near ' + desc,
            2, ERRORparser);
}

function Expected(string msg, var t)
{
    SyntaxError("Expected " + msg, t);
}

function ExpectedIdentifier(var t)
{
    SyntaxError("Expected identifier", t);
}

function ExpectedOp(string msg, var t)
{
    SyntaxError("Expected '" + msg + "'", t);
}

function RequireOp(string name, var t)
{
    if (! t.isop(name))
        ExpectedOp(name, t);
}

function RequireKeyword(string name, var t)
{
    if (! t.iskeyword(name))
        ExpectedOp(name, t);
}

function RequireIdentifier(var t)
{
    if (! t.isidentifier())
        ExpectedIdentifier(t);
}

function ExpectOp(string name, var tk)
{
    var t = tk.get();
    RequireOp(name, t);
}

function ExpectKeyword(string name, var tk)
{
    var t = tk.get();
    RequireKeyword(name, t);
}

//*********************************************
//                Token
//*********************************************

class Token
{
    var file;
    var line;
    function Token(string file, int line)
    {
        self.file = file;
        self.line = line;
    }
    function get_bool[vtable]()
    {
        return true;
    }
    function get_integer[vtable]()
    {
        return 1;
    }

    function iseof()        { return false; }
    function iscomment()    { return false; }
    function isidentifier() { return false; }
    function isint()        { return false; }
    function isfloat()      { return false; }
    function isstring()     { return false; }

    function rawstring()
    {
        InternalError('Not a literal string', self);
    }
    function getidentifier()
    {
        ExpectedIdentifier(self);
    }
    function iskeyword(string name) { return false; }
    function checkkeyword()         { return false; }
    function isop(string name)      { return false; }
    function checkop() { return ''; }
    function viewable() { return '(unknown)'; }
    function show()
    {
        string r = self.viewable();
        return r + ' at ' + string(self.file) + ' line ' + string(self.line);
    }
}

class TokenEof : Token
{
    function TokenEof(string file)
    {
        self.Token(file, 0);
    }
    function get_bool[vtable]()
    {
        return false;
    }
    function get_integer[vtable]()
    {
        return 0;
    }
    function iseof() { return true; }
    function viewable() { return '(End of file)'; }
}

class TokenWithVal : Token
{
    var str;
    function TokenWithVal(string file, int line, string str)
    {
        self.Token(file, line);
        self.str = str;
    }
    function get_string[vtable]() { return self.str; }
    function viewable()
    {
        return self.str;
    }
}

class TokenComment : TokenWithVal
{
    function TokenComment(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function iscomment() { return true; }
}

class TokenOp : TokenWithVal
{
    function TokenOp(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isop(string name)
    {
        return self.str == name;
    }
    function checkop()
    {
        return string(self.str);
    }
}

class TokenIdentifier : TokenWithVal
{
    function TokenIdentifier(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isidentifier() { return true; }
    function getidentifier()
    {
        return self.str;
    }
    function checkkeyword()
    {
        return string(self.str);
    }
    function iskeyword(string name)
    {
        return self.str == name;
    }
}

class TokenString : TokenWithVal
{
    function isstring() { return true; }
    function rawstring()
    {
        return self.str;
    }
}

class TokenQuoted : TokenString
{
    function TokenQuoted(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function get_string[vtable]()
    {
        return '"' + string(self.str) + '"';
    }
    function viewable()
    {
        return '"' + string(self.str) + '"';
    }
}

class TokenSingleQuoted : TokenString
{
    function TokenSingleQuoted(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function get_string[vtable]()
    {
        return "'" + string(self.str) + "'";
    }
    function viewable()
    {
        return "'" + string(self.str) + "'";
    }
}

class TokenInteger : TokenWithVal
{
    function TokenInteger(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isint() { return true; }
}

class TokenFloat : TokenWithVal
{
    function TokenFloat(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isfloat() { return true; }
}


//*********************************************
//       Tokenizer auxiliar functions
//*********************************************

function getquoted(tk, string start, int line)
{
    string s = '';
    string c= tk.getchar();
    while (c != '"') {
        if (c == '' || c == "\n")
            TokenError('Unterminated string', tk, line);
        // Quick fix for escaped double quotes.
        if (c == '\') {
            string c2 = tk.getchar();
            if (c2 == '' || c2 == "\n")
                TokenError('Unterminated string', tk, line);
            s+= c + c2;
        }
        else
            s+= c;
        c= tk.getchar();
    }
    return new TokenQuoted(tk.filename, line, s);
}

function getsinglequoted(tk, string start, int line)
{
    string s = '';
    string c= tk.getchar();
    while (c != "'") {
        if (c == '' || c == "\n")
            TokenError('Unterminated string', tk, line);
        s+= c;
        c= tk.getchar();
    }
    return new TokenSingleQuoted(tk.filename, line, s);
}

function getheredoc(tk, string start, int linenum)
{
    string mark = '';
    string c = tk.getchar();
    while (c != "\n" && c != '') {
        // Encode the mark the same way as the heredoc content
        // to simplify its detection
        if (c == '"' || c ==  '\')
            c = '\' + c;
        mark = mark + c;
        c = tk.getchar();
    }
    if (c == '')
        TokenError('Unterminated heredoc', tk, linenum);
    mark = mark + ':>>';

    string content = '';
    string line;
    do {
        line = '';
        c = tk.getchar();
        while (c != "\n" && c != '') {
            if (c == '"' || c ==  '\')
                c = '\' + c;
            line += c;
            c = tk.getchar();
        }
        if (c == '')
            TokenError('Unterminated heredoc', tk, linenum);
        if (line != mark)
            content += line + '\n';
    } while (line != mark);
    return new TokenQuoted(tk.filename, linenum, content);
}

function getident(tk, string start, int line)
{
    string s = start;
    string c = tk.getchar();
    while (isident(c)) {
        s += c;
        c = tk.getchar();
    }
    tk.ungetchar(c);
    return new TokenIdentifier(tk.filename, line, s);
}

function getnumber(tk, string start, int line)
{
    string s;
    string c = start;
    do {
        s += c;
        c = tk.getchar();
    } while (isdigit(c));
    if (s == '0' && (c == 'x' || c == 'X')) {
        int hexval = 0, h;
        c = tk.getchar();
        while ((h = hexdigit(c)) >= 0) {
            hexval = hexval * 16 + h;
            s+= c;
            c = tk.getchar();
        }
        tk.ungetchar(c);
        s = hexval;
        return new TokenInteger(tk.filename, line, s);
    }
    if (c == '.') {
        do {
            s += c;
            c = tk.getchar();
        } while (isdigit(c));
        if (c == 'e' || c == 'E') {
            s += 'E';
            if ((c = tk.getchar()) == '+' || c == '-') {
                s += c;
                c = tk.getchar();
            }
            while (isdigit(c)) {
                s += c;
                c = tk.getchar();
            }
        }
        tk.ungetchar(c);
        return new TokenFloat(tk.filename, line, s);
    }
    else {
        if (c == 'e' || c == 'E') {
            s += 'E';
            if ((c = tk.getchar()) == '+' || c == '-') {
                s += c;
                c = tk.getchar();
            }
            while (isdigit(c)) {
                s += c;
                c = tk.getchar();
            }
            tk.ungetchar(c);
            return new TokenFloat(tk.filename, line, s);
        }
        else {
            tk.ungetchar(c);
            return new TokenInteger(tk.filename, line, s);
        }
    }
}

function getlinecomment(tk, string start, int line)
{
    string s = start;
    string c = tk.getchar();
    while (c != '' && c != "\n") {
        s += c;
        c = tk.getchar();
    }
    return new TokenComment(tk.filename, line, s);
}

function getcomment(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
    do {
        while (c != '' && c != '*') {
            s += c;
            c = tk.getchar();
        }
        if (c == '')
            TokenError("Unclosed comment", tk, line);
        s += c;
        c = tk.getchar();
        if (c == '')
            TokenError("Unclosed comment", tk, line);
    } while (c != '/');
    s += '/';
    return new TokenComment(tk.filename, line, s);
}

function getop(tk, string start, int line)
{
    string s= start;
    return new TokenOp(tk.filename, line, s);
}

//*********************************************
//              Tokenizer
//*********************************************

class Tokenizer
{
    var h;
    var pending;
    var select;
    var stacked;
    var filename;
    var line;
    function Tokenizer(handle, string filename)
    {
        using static getop;

        self.h = handle;
        self.pending = '';
        self.stacked = [];
        self.filename = filename;
        self.line= 1;
        var select = {
            '$': { '': getident, '{': getop },
            '"': getquoted,
            "'": getsinglequoted,
            '=': {
                '=': { '': getop, '=': getop },
                ':': getop
            },
            '+': { '+': getop, '=': getop },
            '-': { '-': getop, '=': getop },
            '*': { '=': getop },
            '|': { '|': getop },
            '&': { '&': getop },
            '<': {
                '<': { '': getop, ':': getheredoc },
                '=': getop
            },
            '>': { '>': getop, '=': getop },
            '!': {
                '=': { '': getop, '=': getop }
            },
            '%': { '%': getop, '=': getop },
            '/': { '=': getop, '/': getlinecomment, '*': getcomment },
            '#': getlinecomment
        };
        self.select = select;
    }
    function getchar()
    {
        var pending = self.pending;
        string c = pending;
        if (c != '')
            pending =: '';
        else {
            var h = self.h;
            c = h.read(1);
            if (c == "\n") {
                int l = self.line;
                ++l;
                self.line= l;
            }
        }
        return c;
    }
    function ungetchar(string c)
    {
        self.pending =: c;
    }
    function get_token()
    {
        using static isspace;
        using static isidentstart;
        using static isdigit;
        using static getop;
        using static getident;
        using static getnumber;

        if (self.stacked) {
            var t = self.stacked.pop();
            return t;
        }
        string c = self.getchar();
        while (isspace(c))
                c = self.getchar();
        int line = self.line;
        if (c == '')
            return new TokenEof(self.filename);
        if (isidentstart(c))
            return getident(self, c, line);
        if (isdigit(c))
            return getnumber(self, c, line);

        string op = c;
        var select = self.select;
        var current = select[c];

        while (current != null && (current instanceof 'Hash')) {
            c = self.getchar();
            select = current;
            current = select[c];
            if (current == null) {
                self.ungetchar(c);
                current = select[''];
            }
            else
                op += c;
        }
        if (current)
            return current(self, op, line);
        return getop(self, op, line);
    }
    function get(int withcomments [optional])
    {
        var t = self.get_token();
        while (!t.iseof() && !withcomments && t.iscomment())
           t = self.get_token();
        return t;
    }
    function unget(t)
    {
        push(self.stacked, t);
    }
}

//*********************************************
//          PIR generation values
//*********************************************

// Register types
const string
    REGint =     'I',
    REGfloat =   'N',
    REGstring =  'S',
    REGvar =     'P',
// Pseudotypes for predefined functions
    REGarglist = '*',
    REGany     = '?',
    REGraw1    = '!', // raw mode one arg
    REGnone    = 'v'; // void return

function typetoregcheck(string type)
{
    switch (type) {
    case 'int':    return REGint;
    case 'float':  return REGfloat;
    case 'string': return REGstring;
    case 'var':    return REGvar;
    default:       return '';
    }
}

function typetopirname(string regtype)
{
    switch(regtype) {
    case REGint:    return 'int';
    case REGfloat:  return 'num';
    case REGstring: return 'string';
    case REGvar:    return 'pmc';
    default:        InternalError('Invalid reg type');
    }
}

//*********************************************
//            Emit
//*********************************************

class Emit
{
    var handle;
    var file;
    var line;
    var pendingf;
    var pendingl;
    var noan;

    function initialize(var handle)
    {
        self.handle = handle;
        self.file = '';
        self.line = 0;
        self.pendingf = false;
        self.pendingl = false;
    }
    function disable_annotations()
    {
        self.noan = 1;
    }
    function close()
    {
        self.handle = null;
    }
    function updateannot()
    {
        if (self.pendingf) {
            self.handle.print(join("", [
                ".annotate 'file', '",
                self.file,
                "'\n" ]
            ));
            self.pendingf =: false;
        }
        if (self.pendingl) {
            self.handle.print(join("", [
                ".annotate 'line', ",
                self.line,
                "\n" ]
            ));
            self.pendingl =: false;
        }
    }
    function vprint(var args)
    {
        for (var s in args)
            self.handle.print(s);
    }
    function print(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
    }
    function say(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
        self.handle.print("\n");
    }
    function annotate(var t)
    {
        if (self.noan == null)
        {
            var file = self.file;
            var line = self.line;
            string tfile = t.file;
            int tline = t.line;
            if (file != tfile) {
                file =: tfile;
                self.pendingf =: true;
                line =: 0;
            }
            if (line != tline) {
                line =: tline;
                self.pendingl =: true;
            }
        }
    }
    function comment(string s)
    {
        self.updateannot();
        self.handle.print('# ' + s + "\n");
    }
    function emitlabel(string label, string comment [optional])
    {
        var handle = self.handle;
        handle.print(label);
        handle.print(':');
        if (comment != null) {
            handle.print(' # ' + comment);
        }
        handle.print("\n");
    }
    function emitgoto(string label, string comment [optional])
    {
        var handle = self.handle;
        handle.print('goto ');
        handle.print(label);
        if (comment != null) {
            handle.print(' # ');
            handle.print(comment);
        }
        handle.print("\n");
    }

    function emitif(string value, string label)
    {
        self.say('if ', value, ' goto ', label);
    }
    function emitunless(string value, string label)
    {
        self.say('unless ', value, ' goto ', label);
    }

    function emitif_null(string value, string label)
    {
        self.say('if_null ', value, ', ', label);
    }
    function emitnull(string dst)
    {
        self.say("null ", dst);
    }
    function emitinc(string arg)
    {
        self.say('inc ', arg);
    }

    function emitdec(string arg)
    {
        self.say('dec ', arg);
    }
    function emitset(string dst, string src)
    {
        self.say("set ", dst, ", ", src);
    }
    function emitassign(string dst, string src)
    {
        self.say("assign ", dst, ", ", src);
    }
    function emitbox(string dst, string src)
    {
        self.say("box ", dst, ", ", src);
    }
    function emitunbox(string dst, string src)
    {
        self.say("unbox ", dst, ", ", src);
    }
    function emitbinop(string op, string res, string dst, string src)
    {
        self.say(op, " ", res, ", ", dst, ", ", src);
    }
    function emitaddto(string dst, string src)
    {
        self.say("add ", dst, ", ", src);
    }
    function emitsubto(string dst, string src)
    {
        self.say("sub ", dst, ", ", src);
    }
    function emitadd(string dst, string src1, string src2)
    {
        self.say("add ", dst, ", ", src1, ", ", src2);
    }
    function emitmul(string dst, string src1, string src2)
    {
        self.say("mul ", dst, ", ", src1, ", ", src2);
    }
    function emitconcat1(string dst, string src)
    {
        self.say("concat ", dst, ", ", dst, ", ", src);
    }
    function emitconcat(string dst, string src1, string src2)
    {
        self.say("concat ", dst, ", ", src1, ", ", src2);
    }
    function emitprint(string arg)
    {
        self.say('print ', arg);
    }
    function emitsay(string arg)
    {
        self.say('say ', arg);
    }
}

//*********************************************
//         Helper functions and constants
//*********************************************

function integerValue(var owner, var start, int value)
{
    return new IntegerLiteral(owner, start, value);
}

function floatValue(var owner, var start, float value)
{
    var t = new TokenFloat(start.file, start.line, value);
    return new FloatLiteral(owner, t);
}

function floatresult(string r1, string r2)
/*
    Check if the passed types can give a float result in arithmetic
    operations.
*/
{
    int result = (r1 == REGfloat && (r2 == REGfloat || r2 == REGint)) ||
           (r2 == REGfloat && (r1 == REGfloat || r1 == REGint));
    return result;
}

const string NULL = 'null', SELF = 'self';

// Var flags
const int
    VAR_is_volatile = 1,
    VAR_is_lexical  = 2;

//*********************************************
//         Predefined functions
//*********************************************

const int PREDEF_arglist = -1, PREDEF_raw1 = -2;

// Invokable object generated from a string body
class Predef_frombody
{
    const string resultmark = '{res}';
    var body;
    var typeresult;
    function Predef_frombody(string typeresult, string bodystr)
    {
        int pos = indexof(bodystr, resultmark);
        if (typeresult == REGnone && pos != -1)
            InternalError('void predef with {res}');
        if (typeresult != REGnone && pos == -1)
            InternalError('non void predef without {res}');
        self.body = bodystr;
        self.typeresult = typeresult;
    }
    function invoke [vtable](e, start, string result, args)
    {
        string body = self.body;
        string typeresult = self.typeresult;

        int pos;
        if (typeresult == REGnone) {
            if (result != null && result != '')
                SyntaxError('using return value from void predef');
        }
        else {
            if (result == null || result == '')
                InternalError('Bad result in non void predef');
            while ((pos = indexof(body, resultmark)) != -1)
                body = replace(body, pos, length(resultmark), result);
        }

        int n = args;
        for (int i = 0; i < n; ++i) {
            string argmark = '{arg' + i + '}';
            int l = length(argmark);
            string arg = args[i];
            while ((pos = indexof(body, argmark)) != -1)
                body = replace(body, pos, l, arg);
        }
        e.annotate(start);
        e.say(body);
    }
}

class PredefFunction
{
    var name;
    var body;
    var evalfun;
    var typeresult;
    var type0;
    var type1;
    var type2;
    var type3;
    var nparams;

    function name()
    {
        string name = self.name;
        return name;
    }
    function result()
    {
        return self.typeresult;
    }
    function params() { return self.nparams; }
    function paramtype(int i)
    {
        string type;
        switch (i) {
        case 0: type = self.type0; break;
        case 1: type = self.type1; break;
        case 2: type = self.type2; break;
        case 3: type = self.type3; break;
        default:
            InternalError('Invalid predef arg');
        }
        return type;
    }
    function set(string name, body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.name = name;
        if (body instanceof 'String')
            self.body = new Predef_frombody(typeresult, body);
        else
            self.body = body;
        self.typeresult = typeresult;
        int n = 0;
        if (type0 != null) {
            self.type0 = type0;
            switch (type0) {
              case REGarglist:
                n = PREDEF_arglist;
                break;
              case REGraw1:
                n = PREDEF_raw1;
                if (type1 != null)
                    InternalError("Invalid predef '" + name + '"');
                break;
              default:
                n = 1;
                if (type1 != null) {
                    self.type1 = type1;
                    ++n;
                }
                if (type2 != null) {
                    self.type2 = type2;
                    ++n;
                }
                if (type3 != null) {
                    self.type3 = type3;
                    ++n;
                }
            }
        }
        self.nparams = n;
        return self;
    }
    function set_eval(string name,
        var evalfun,
        string body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.evalfun = evalfun;
        self.set(name, body, typeresult, type0, type1, type2, type3);
        return self;
    }
    function expand(var e, var owner, var start, string result, args)
    {
        e.comment('predefined ' + string(self.name));
        string typeresult = self.typeresult;
        if (typeresult != REGnone && result == '')
            result = owner.tempreg(typeresult);
        var fun = self.body;
        fun(e, start, result, args);
    }
}

class Predef_typecast
{
    var type;
    function Predef_typecast(string type)
    {
        self.type = type;
    }
    function invoke [vtable](e, start, result, args)
    {
        string type = self.type;
        if (elements(args) != 1)
            InternalError("Invalid Predef_typecast.invoke call");
        var rawarg = args[0];
        string argtype = rawarg.checkresult();
        if (argtype == type || (rawarg instanceof IndexExpr))
            rawarg.emit(e, result);
        else {
            string arg = rawarg.emit_get(e);
            e.annotate(start);
            // Special case
            if (arg == NULL)
                e.emitnull(result);
            else
                e.emitset(result, arg);
        }
    }
}

class Predef_say
{
    function invoke [vtable](e, start, result, args)
    {
        e.annotate(start);
        int n = int(args) - 1;
        if (n >= 0) {
            for (int i = 0; i < n; ++i)
                e.emitprint(args[i]);
            e.emitsay(args[n]);
        }
        else
            e.emitsay("''");
    }
}

class Predef_cry
{
    function invoke [vtable](e, start, result, args)
    {
        e.annotate(start);
        e.say("getstderr $P0");
        int n = int(args);
        for (int i = 0; i < n; ++i)
            e.say("print $P0, ", args[i]);
        e.say("print $P0, \"\\n\"");
    }
}

class Predef_print
{
    function invoke [vtable](e, start, result, args)
    {
        e.annotate(start);
        int n = args;
        for (int i = 0; i < n; ++i)
            e.emitprint(args[i]);
    }
}

function predefeval_length(var owner, var start, var args)
{
    var arg = args[0].arg;
    string s = arg.get_value();
    return integerValue(owner, start, length(s));
}

function predefeval_bytelength(var owner, var start, var args)
{
    var arg = args[0].arg;
    string s = arg.get_value();
    return integerValue(owner, start, bytelength(s));
}

function predefeval_ord(var owner, var start, var args)
{
    var arg = args[0].arg;
    string s = arg.get_value();
    return integerValue(owner, start, ord(s));
}

function predefeval_ord_n(var owner, var start, var args)
{
    var arg = args[0].arg;
    string s = arg.get_value();
    var argn = args[1].arg;
    int n = argn.numval;
    return integerValue(owner, start, ord(s, n));
}

function predefeval_chr(var owner, var start, var args)
{
    var arg = args[0].arg;

    int n = arg.numval;
    string s = chr(n);

    var t = new TokenQuoted(start.file, start.line, s);
    return new StringLiteral(owner, t);
}

function predefeval_substr(var owner, var start, var args)
{
    var argstr = args[0].arg;
    var argpos = args[1].arg;
    string str = argstr.get_value();
    int pos = argpos.numval;

    var t = new TokenQuoted(start.file, start.line, substr(str, pos));
    return new StringLiteral(owner, t);
}

function predefeval_substr_l(var owner, var start, var args)
{
    var argstr = args[0].arg;
    var argpos = args[1].arg;
    var arglen = args[2].arg;
    string str = argstr.get_value();
    int pos = argpos.numval;
    int len = arglen.numval;

    var t = new TokenQuoted(start.file, start.line, substr(str, pos, len));
    return new StringLiteral(owner, t);
}

function predefeval_indexof(var owner, var start, var args)
{
    var argstrfrom = args[0].arg;
    var argstrsearch = args[1].arg;
    string strfrom = argstrfrom.get_value();
    string strsearch = argstrsearch.get_value();
    return integerValue(owner, start, indexof(strfrom, strsearch));
}

function predefeval_indexof_pos(var owner, var start, var args)
{
    var argstrfrom = args[0].arg;
    var argstrsearch = args[1].arg;
    var argpos = args[2].arg;
    string strfrom = argstrfrom.get_value();
    string strsearch = argstrsearch.get_value();
    int pos = argpos.numval;
    return integerValue(owner, start, indexof(strfrom, strsearch, pos));
}

function getpredefs()
{
    using predefeval_length;
    using predefeval_bytelength;
    using predefeval_chr;
    using predefeval_ord;
    using predefeval_ord_n;
    using predefeval_substr;
    using predefeval_substr_l;
    using predefeval_indexof;
    using predefeval_indexof_pos;

    var predefs = [
        new PredefFunction().set('int',
            new Predef_typecast(REGint),
            REGint, REGraw1
        ),
        new PredefFunction().set('float',
            new Predef_typecast(REGfloat),
            REGfloat, REGraw1
        ),
        new PredefFunction().set('string',
            new Predef_typecast(REGstring),
            REGstring, REGraw1
        ),
        new PredefFunction().set('die',
            'die {arg0}',
            REGnone, REGstring
        ),
        new PredefFunction().set('exit',
            'exit {arg0}',
            REGnone, REGint
        ),
        new PredefFunction().set('time',
            'time {res}',
            REGint
        ),
        new PredefFunction().set('floattime',
            'time {res}',
            REGfloat
        ),
        new PredefFunction().set('spawnw',
            'spawnw {res}, {arg0}',
            REGint, REGvar
        ),
        new PredefFunction().set('getstdin',
            'getstdin {res}',
            REGvar
        ),
        new PredefFunction().set('getstdout',
            'getstdout {res}',
            REGvar
        ),
        new PredefFunction().set('getstderr',
            'getstderr {res}',
            REGvar
        ),
        new PredefFunction().set('open',
            "root_new {res}, ['parrot';'FileHandle']\n" +
            "{res}.'open'({arg0})",
            REGvar, REGstring
        ),
        new PredefFunction().set('open',
            "root_new {res}, ['parrot';'FileHandle']\n" +
            "{res}.'open'({arg0},{arg1})",
            REGvar, REGstring, REGstring
        ),
        new PredefFunction().set('Error',
            "root_new {res}, ['parrot';'Exception']\n" +
            "{res}['message'] = {arg0}",
            REGvar, REGstring
        ),
        new PredefFunction().set('Error',
            "root_new {res}, ['parrot';'Exception']\n" + 
            "{res}['message'] = {arg0}\n" +
            "{res}['severity'] = {arg1}",
            REGvar, REGstring, REGint
        ),
        new PredefFunction().set('Error',
            "root_new {res}, ['parrot';'Exception']\n" +
            "{res}['message'] = {arg0}\n" +
            "{res}['severity'] = {arg1}\n" +
            "{res}['type'] = {arg2}",
            REGvar, REGstring, REGint, REGint
        ),
        new PredefFunction().set('elements',
            'elements {res}, {arg0}',
            REGint, REGvar
        ),
        new PredefFunction().set_eval('length',
            predefeval_length,
            'length {res}, {arg0}',
            REGint, REGstring
        ),
        new PredefFunction().set_eval('bytelength',
            predefeval_bytelength,
            'bytelength {res}, {arg0}',
            REGint, REGstring
        ),
        new PredefFunction().set_eval('chr',
            predefeval_chr,
            "chr $S0, {arg0}\n" +
            "find_encoding $I0, 'utf8'\n" +
            "trans_encoding {res}, $S0, $I0",
            REGstring, REGint
        ),
        new PredefFunction().set_eval('ord',
            predefeval_ord,
            'ord {res}, {arg0}',
            REGint, REGstring
        ),
        new PredefFunction().set_eval('ord',
            predefeval_ord_n,
            'ord {res}, {arg0}, {arg1}',
            REGint, REGstring, REGint
        ),
        new PredefFunction().set_eval('substr',
            predefeval_substr,
            'substr {res}, {arg0}, {arg1}',
            REGstring, REGstring, REGint
        ),
        new PredefFunction().set_eval('substr',
            predefeval_substr_l,
            'substr {res}, {arg0}, {arg1}, {arg2}',
            REGstring, REGstring, REGint, REGint
        ),
        new PredefFunction().set('replace',
            'replace {res}, {arg0}, {arg1}, {arg2}, {arg3}',
            REGstring, REGstring, REGint, REGint, REGstring
        ),
        new PredefFunction().set_eval('indexof',
            predefeval_indexof,
            'index {res}, {arg0}, {arg1}',
            REGint, REGstring, REGstring
        ),
        new PredefFunction().set_eval('indexof',
            predefeval_indexof_pos,
            'index {res}, {arg0}, {arg1}, {arg2}',
            REGint, REGstring, REGstring, REGint
        ),
        new PredefFunction().set('join',
            'join {res}, {arg0}, {arg1}',
            REGstring, REGstring, REGvar
        ),
        new PredefFunction().set('upcase',
            'upcase {res}, {arg0}',
            REGstring, REGstring
        ),
        new PredefFunction().set('downcase',
            'downcase {res}, {arg0}',
            REGstring, REGstring
        ),
        new PredefFunction().set('titlecase',
            'titlecase {res}, {arg0}',
            REGstring, REGstring
        ),
        new PredefFunction().set('split',
            'split {res}, {arg0}, {arg1}',
            REGvar, REGstring, REGstring
        ),
        new PredefFunction().set('chomp',
            "$P0 = get_root_global ['parrot';'String';'Utils'], 'chomp'\n" +
            "{res} = $P0({arg0})",
            REGstring, REGstring
        ),
        new PredefFunction().set('chomp',
            "$P0 = get_root_global ['parrot';'String';'Utils'], 'chomp'\n" +
            "{res} = $P0({arg0}, {arg1})",
            REGstring, REGstring, REGstring
        ),
        new PredefFunction().set('push',
            'push {arg0}, {arg1}',
            REGnone, REGvar, REGany
        ),
        new PredefFunction().set('sqrt',
            'sqrt {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('pow',
            'pow {res}, {arg0}, {arg1}',
            REGfloat, REGfloat, REGfloat
        ),
        new PredefFunction().set('exp',
            'exp {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('ln',
            'ln {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('sin',
            'sin {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('cos',
            'cos {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('tan',
            'tan {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('asin',
            'asin {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('acos',
            'acos {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('atan',
            'atan {res}, {arg0}',
            REGfloat, REGfloat
        ),
        new PredefFunction().set('atan',
            'atan {res}, {arg0}, {arg1}',
            REGfloat, REGfloat, REGfloat
        ),
        new PredefFunction().set('getinterp',
            'getinterp {res}',
            REGvar
        ),
        new PredefFunction().set('get_class',
            'get_class {res}, {arg0}',
            REGvar, REGstring
        ),
        new PredefFunction().set('typeof',
            'typeof {res}, {arg0}',
            REGvar, REGvar
        ),
        new PredefFunction().set('getattribute',
            'getattribute {res}, {arg0}, {arg1}',
            REGvar, REGvar, REGstring
        ),
        new PredefFunction().set('find_method',
            'find_method {res}, {arg0}, {arg1}',
            REGvar, REGvar, REGstring
        ),
        new PredefFunction().set('callmethodwithargs',
            '{res} = {arg0}.{arg1}({arg2} :flat)',
            REGvar, REGvar, REGvar, REGvar
        ),
        new PredefFunction().set('clone',
            'clone {res}, {arg0}',
            REGvar, REGvar
        ),
        new PredefFunction().set('compreg',
            'compreg {res}, {arg0}',
            REGvar, REGstring
        ),
        new PredefFunction().set('compreg',
            'compreg {arg0}, {arg1}',
            REGnone, REGstring, REGvar
        ),
        new PredefFunction().set('load_language',
            "load_language {arg0}\n" +
            "compreg {res}, {arg0}",
            REGvar, REGstring
        ),
        new PredefFunction().set('load_language',
            "load_language {arg0}\n" +
            "compreg {res}, {arg1}",
            REGvar, REGstring, REGstring
        ),
        new PredefFunction().set('loadlib',
            'loadlib {res}, {arg0}',
            REGvar, REGstring
        ),
        new PredefFunction().set('load_bytecode',
            'load_bytecode {arg0}',
            REGnone, REGstring
        ),
        new PredefFunction().set('dlfunc',
            'dlfunc {res}, {arg0}, {arg1}, {arg2}',
            REGvar, REGvar, REGstring, REGstring
        ),
        new PredefFunction().set('sprintf',
            'sprintf {res}, {arg0}, {arg1}',
            REGstring, REGstring, REGvar
        ),
        new PredefFunction().set('sprintf',
            'sprintf {res}, {arg0}, {arg1}',
            REGvar, REGvar, REGvar
        ),
        new PredefFunction().set('print',
            new Predef_print(),
            REGnone, REGarglist
        ),
        new PredefFunction().set('say',
            new Predef_say(),
            REGnone, REGarglist
        ),
        new PredefFunction().set('cry',
            new Predef_cry(),
            REGnone, REGarglist
        )
    ];
    for (;;)
        yield predefs;
}

function findpredef(string name, int nargs)
{
    for (var p in getpredefs())
        if (p.name == name) {
            int pargs = p.nparams;
            if (pargs == nargs ||
                    pargs == PREDEF_arglist ||
                    (pargs == PREDEF_raw1 && nargs == 1))
                return p;
        }
    return null;
}

//*********************************************
//               Auxiliar functions
//*********************************************

function optimize_array(var arr)
{
    int n = elements(arr);
    for (int i= 0; i < n; ++i)
        arr[i] = arr[i].optimize();
}

function parseDotted(tk)
{
    var list = [];
    var t = tk.get();
    if (t.isidentifier()) {
        push(list, t);
        while ((t= tk.get()).isop('.')) {
            t= tk.get();
            push(list, t);
        }
    }
    tk.unget(t);
    return list;
}

function toIdentifierList(var tlist)
{
    string list[];
    for (var t in tlist)
        push(list, t.getidentifier());
    return list;
}

//*********************************************
//               CommonBase
//*********************************************

class CommonBase
{
    var start;
    var owner;

    function initbase(start, owner)
    {
        self.start = start;
        self.owner = owner;
    }
    function annotate(e)
    {
        e.annotate(self.start);
    }
    function use_predef(string name)
    {
        self.owner.use_predef(name);
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function addlocalfunction(fn)
    {
        return self.owner.addlocalfunction(fn);
    }
    function findsymbol(classkey)
    {
        return self.owner.findsymbol(classkey);
    }
    function findclasskey(classkey)
    {
        return self.owner.findclasskey(classkey);
    }
    function dowarnings()
    {
        return self.owner.dowarnings();
    }
}

//*********************************************
//          SimpleArgList
//*********************************************

// A list of arguments without modifiers.

class SimpleArgList
{
    var args;

    function init[vtable]()
    {
        self.args = [];
    }

    function numargs()
    {
        return elements(self.args);
    }
    function getarg(int i)
    {
        var args = self.args;
        return args[i];
    }

    function parseargs(var tk, var owner, string oper_end)
    {
        var args = self.args;
        var t;
        do {
            var value = parseExpr(tk, owner);
            push(args, value);
        } while ((t= tk.get()).isop(','));
        RequireOp(oper_end, t);
    }

    function optimizeargs()
    {
        var args = self.args;
        if (args != null)
            optimize_array(args);
    }
    function getargvalues(var e)
    {
        var args = self.args;
        var argreg = [];
        int nargs = elements(args);
        for (int i= 0; i < nargs; ++i) {
            var a = args[i];
            string reg = a.emit_get(e);
            push(argreg, reg);
        }
        return argreg;
    }
    function emitargs(var e)
    {
        var argreg = self.getargvalues(e);
        e.print(join(', ', argreg));
    }
}

//*********************************************
//            Modifiers
//*********************************************

class Modifier
{
    var name;
    var args;

    function getname() { return self.name; }
    function numargs()
    {
        int nargs = self.args.numargs();
        return nargs;
    }
    function getarg(int argnum)
    {
        var args = self.args;
        if (argnum < args.numargs())
            return args.getarg(argnum);
        else
            InternalError('Wrong modifier arg number');
    }
    function Modifier(string name, var args)
    {
        self.name = name;
        if (args != null)
            self.args = args;
    }
    function optimize()
    {
        self.args.optimizeargs();
    }
}

class ModifierList
{
    var list;

    function ModifierList(var tk, var owner)
    {
        var list = [];
        var t;
        do {
            t = tk.get();
            string name = t.getidentifier();
            t = tk.get();
            var args = new SimpleArgList();
            if (t.isop('(')) {
                args.parseargs(tk, owner, ')');
                t= tk.get();
            }
            push(list, new Modifier(name, args));
        } while (t.isop(','));
        RequireOp(']', t);
        self.list = list;
    }
    function optimize()
    {
        for (var arg in self.list)
            arg.optimize();
    }
    function getlist() { return self.list; }
    function pick(string name)
    {
        var list = self.list;
        int n = elements(list);
        for (int i = 0; i < n; ++i) {
            var mod = list[i];
            if (mod.getname() == name) {
                return mod;
            }
        }
        return null;
    }
}

//*********************************************
//       Auxiliary classes and functions
//*********************************************

function getparrotkey(var path)
{
    string s = join("'; '", path);
    return "[ '" + s + "' ]";
}

function getparrotnamespacekey(var path)
{
    if (elements(path) == 0)
        return ".namespace [ ]";
    else {
        string s = join("'; '", path);
        return ".namespace [ '" + s + "' ]";
    }
}

function parseUsing(t, tk, owner)
{
    var taux = tk.get();
    if (taux.iskeyword('extern'))
        return new ExternStatement(t, tk, owner);
    else if (taux.iskeyword('static'))
        return new StaticStatement(t, tk, owner);
    else {
        tk.unget(taux);
        return new UsingStatement(t, tk, owner);
    }
}

function parseStatement(tk, owner)
{
    var t= tk.get();
    if (t.isop(';'))
        return new EmptyStatement();
    if (t.isop('{'))
        return new CompoundStatement(t, tk, owner);
    if (t.isop('${'))
        return new PiropStatement(t, tk, owner);

    string key = t.checkkeyword();
    var st;
    switch (key) {
    case 'using':
        return parseUsing(t, tk, owner);
    case 'const':
        return parseConst(t, tk, owner);
        break;
    case 'volatile':
        return parseVolatile(t, tk, owner);
        break;
    case 'var':
        return parseVar(t, tk, owner);
    case 'string':
        return parseString(t, tk, owner);
    case 'int':
        return parseInt(t, tk, owner);
    case 'float':
        return parseFloat(t, tk, owner);
    case 'return':
        return new ReturnStatement(t, tk, owner);
    case 'yield':
        return new YieldStatement(t, tk, owner);
    case 'goto':
        return new GotoStatement(t, tk, owner);
    case 'if':
        return new IfStatement(t, tk, owner);
    case 'while':
        return new WhileStatement(t, tk, owner);
    case 'do':
        return new DoStatement(t, tk, owner);
    case 'continue':
        return new ContinueStatement(t, tk, owner);
    case 'break':
        return new BreakStatement(t, tk, owner);
    case 'switch':
        return new SwitchStatement(t, tk, owner);
    case 'for':
        return parseFor(t, tk, owner);
    case 'throw':
        return new ThrowStatement(t, tk, owner);
    case 'try':
        return new TryStatement(t, tk, owner);
    default:
        if (t.isidentifier()) {
            var t2= tk.get();
            if (t2.isop(':'))
                return new LabelStatement(t, owner);
            tk.unget(t2);
        }
        tk.unget(t);
        return new ExprStatement(t, tk, owner);
    }
    if (st == null)
        InternalError('parseStatement failure');
    return st.parse(t, tk, owner);
}

//*********************************************
//            Statement
//*********************************************

class Statement : CommonBase
{
    function initstatement(start, owner)
    {
        self.initbase(start, owner);
    }
    function isempty() { return false; }
    function createreg(string type)
    {
        return self.owner.createreg(type);
    }
    function tempreg(string type)
    {
        return self.owner.tempreg(type);
    }
    function freetemps()
    {
        self.owner.freetemps();
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function getlabel(name)
    {
        return self.owner.getlabel(name);
    }
    function createlabel(name)
    {
        return self.owner.createlabel(name);
    }
    function createconst(name, string type, var value, string id)
    {
        return self.owner.createconst(name, type, value, id);
    }
    function createvar(name, string type, int flags[optional])
    {
        return self.owner.createvar(name, type, flags);
    }
    function getvar(name)
    {
        return self.owner.getvar(name);
    }
    function checkclass(string name)
    {
        return self.owner.checkclass(name);
    }

    function getouter()
    {
        // Returns the nearest outer scope. In this base case,
        // just propagate it. Deriveds that are appropiate
        // scopes will override.
        return self.owner.getouter();
    }
    function getcontinuelabel(pos)
    {
        return self.owner.getcontinuelabel(pos);
    }
    function getbreaklabel(pos)
    {
        return self.owner.getbreaklabel(pos);
    }
    function optimize()
    {
        InternalError('**checking**', self.start);
        // Return unchanged by default
        return self;
    }
}

class EmptyStatement : Statement
{
    function isempty() { return true; }
    function annotate(e)
    {
        InternalError('Attempt to annotate empty statement');
    }
    function optimize() { return self; }
    function emit(e)
    {
        // Do nothing
    }
}

class MultiStatementBase
{
    var statements;

    function optimize()
    {
        var statements = self.statements;
        int n = elements(statements);
        int empty = true;
        for (int i = 0; i < n; ++i) {
            var st = statements[i].optimize();
            if (empty && ! st.isempty())
                empty = false;
            statements[i] = st;
        }
        if (empty)
            return new EmptyStatement();
        else
            return self;
    }
}

class MultiStatement : MultiStatementBase
{
    function MultiStatement(var st1, var st2)
    {
        var statements = [st1, st2];
        self.statements = statements;
    }
    function isempty() { return false; }
    function push(var statement)
    {
        push(self.statements, statement);
        return self;
    }
    function emit(e)
    {
        for (var statement in self.statements)
            statement.emit(e);
    }
}

function addtomulti(var multi, var newst)
{
    if (multi == null)
        return newst;
    else if (multi instanceof MultiStatement)
        return multi.push(newst);
    else
        return new MultiStatement(multi, newst);
}

//*********************************************
//           PiropStatement
//*********************************************

class PiropStatement : Statement
{
    var opname;
    var args;

    function PiropStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        int dotted = false;
        if (t.isop('.')) {
            dotted = true;
            t = tk.get();
        }
        string opname = t.getidentifier();
        self.opname = (dotted ? '.' : '') + opname;
        t = tk.get();
        if (! t.isop('}')) {
            tk.unget(t);
            var args = [];
            do {
                var arg;
                t = tk.get();
                if (t.isop(':')) {
                    t = tk.get();
                    string label = t.getidentifier();
                    arg = new Reflabel(owner, label);
                }
                else {
                    tk.unget(t);
                    arg = parseExpr(tk, owner);
                }
                push(args, arg);
            } while ((t = tk.get()).isop(','));
            RequireOp('}', t);
            self.args = args;
        }
        ExpectOp(';', tk);
    }
    function optimize()
    {
        var args = self.args;
        if (args != null)
            optimize_array(args);
        return self;
    }
    function emit(e)
    {
        string opname = self.opname;
        self.annotate(e);
        e.comment('pirop ' + opname);
        var args = self.args;
        if (args == null)
            e.say(opname);
        else {
            e.print(opname, ' ');
            var argreg = [];
            int nargs = elements(args);
            for (int i= 0; i < nargs; ++i) {
                var a = args[i];
                string reg = a.emit_get(e);
                push(argreg, reg);
            }
            e.say(join(', ', argreg));
        }
    }
}

//*********************************************
//            ExternStatement
//*********************************************

class ExternStatement : Statement
{
    var path;
    function ExternStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        var path = parseDotted(tk);
        if (elements(path) == 0)
            ExpectedIdentifier(tk.get());
        ExpectOp(';', tk);
        self.path = toIdentifierList(path);
        return self;
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        e.say("load_bytecode '", join('/', self.path), ".pbc'");
    }
}

//*********************************************
//            StaticStatement
//*********************************************

class StaticStatement : Statement
{
    var symbol;
    function StaticStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        string sym = tk.get();
        ExpectOp(';', tk);
        self.symbol = sym;
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        var v = self.createvar(self.symbol, REGvar);
        e.say(".const 'Sub' ", v.getreg(), " = '", self.symbol, "'");
    }
}

//*********************************************
//            UsingStatement
//*********************************************

class UsingStatement : Statement
{
    var path;
    var subid;

    function UsingStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        var path = parseDotted(tk);
        if (elements(path) == 0)
            ExpectedIdentifier(tk.get());
        ExpectOp(';', tk);
        self.path = toIdentifierList(path);
    }
    function optimize()
    {
        var path = self.path;
        string name = path[-1];
        var vdata = self.createvar(name, REGvar);

        var symbol = self.findsymbol(path);
        if (symbol != null) {
            if (symbol instanceof FunctionStatement) {
                string subid = symbol.makesubid();
                self.subid = subid;
            }
        }
        return self;
    }
    function emit(e)
    {
        var path = self.path;
        string name = path[-1];
        var vdata = self.getvar(name);
        if (self.subid != null) {
            string subid = self.subid;
            e.say(".const 'Sub' ", vdata.getreg(), ' = "', subid, '"');
        }
        else {
            self.annotate(e);
            e.print('get_hll_global ', vdata.getreg(), ', ');
            path.pop();
            switch (elements(path)) {
            case 0:
                e.say("'", name, "'");
                break;
            default:
                e.say(getparrotkey(path), " , '", name, "'");
            }
        }
    }
}

//*********************************************
//            ExprStatement
//*********************************************

class ExprStatement : Statement
{
    var expr;
    function ExprStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.expr = parseExpr(tk, self);
        ExpectOp(';', tk);
    }
    function optimize()
    {
        self.expr = self.expr.optimize();
        return self;
    }
    function emit(e)
    {
        self.expr.emit(e, '');
    }
}

//*********************************************
//            VarContainer
//*********************************************

class VarData
{
    var type;
    var reg;
    var scope;
    var flags;
    var value;
    var id;
    var lexname;

    function VarData(type, reg, scope, int flags, value [optional])
    {
        self.type = type;
        self.reg = reg;
        self.scope = scope;
        self.flags = flags;
        self.value = value;
    }
    function setid(string id)
    {
        self.id = id;
    }
    function setlex(string name)
    {
        self.lexname = name;
    }
    function gettype() { return self.type; }
    function getreg() { return self.reg; }
    function getscope() { return self.scope; }
    function getvalue() { return self.value; }
    function isconst() { return self.value != null; }
    function getid() { return self.id; }
    function getlex() { return self.lexname; }
    function getflags() { return self.flags; }
}

class ConstantInternalFail
{
    var name;
    function ConstantInternalFail(var name)
    {
        self.name = name;
    }
    function get_string[vtable]()
    {
        InternalError('Attempt to use unexpanded constant!!!');
    }
}


class VarContainer
{
    var locals;
    function init [vtable] ()
    {
        self.locals = {};
    }
    function createvar(var name, string type, int flags[optional])
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        string reg= self.createreg(type);
        var data = new VarData(type, reg, self, flags);
        locals[sname] = data;
        return data;
    }
    function createvarnamed(var name, string type, string pirname)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        locals[sname] = new VarData(type, pirname, self, 0);
    }
    function createconst(var name, string type, var value, string id)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        var data = new VarData(type, new ConstantInternalFail(name), self, 0, value);
        if (id != null && id != '')
            data.setid(id);
        locals[sname] = data;
    }
    function getvar(var name)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist == null && self.owner != null)
            exist = self.owner.getvar(name);
        if (exist != null && ! (exist instanceof VarData))
            InternalError('Incorrect data for Variable', name);
        return exist;
    }
    function getlocalvar(var name)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        return exist;
    }
    function makelexical(vardesc)
    {
        var lexowner = self.getouter();
        string lexname = lexowner.createlex(vardesc);
        return lexname;
    }
    function makelexicalself()
    {
        var lexowner = self;
        const string lexname = '__WLEX_self';
        self.setlex(lexname, SELF);
        return lexname;
    }
}

//*********************************************
//            BlockStatement
//*********************************************

// A BlockStatement is a Statement that can have local variables.

class BlockStatement : VarContainer, Statement
{
}

//*********************************************
//            Expr
//*********************************************

class Expr : CommonBase
{
    function issimple() { return false; }
    function isliteral() { return false; }
    function isintegerliteral() { return false; }
    function isfloatliteral() { return false; }
    function isstringliteral() { return false; }
    function isidentifier() { return false; }
    function isnull() { return false; }
    function hascompilevalue() { return false; }
    function isnegable() { return false; }
    function initexpr(owner, start)
    {
        self.initbase(start, owner);
    }
    function tempreg(type)
    {
        return self.owner.tempreg(type);
    }
    function optimize()
    {
        // By default return same expression unchanged
        return self;
    }
    function cantailcall() { return false; }
    function emit_get(e)
    {
        string type = self.checkresult();
        string reg = type == REGnone ? '' : self.tempreg(type);
        self.emit(e, reg);
        return reg;
    }
    function emit_getint(e)
    {
        string reg;
        if (self.checkresult() == REGint)
            reg = self.emit_get(e);
        else {
            reg = self.tempreg(REGint);
            self.emit(e, reg);
        }
        return reg;
    }
    function emit_assign_get(e, expr)
    {
        SyntaxError('Not a left-side expression', self.start);
    }
}

class SimpleExpr : Expr
{
    function issimple() { return true; }
}

//**********************************************************************

class FunctionExpr : Expr
{
    var fn;
    function FunctionExpr(tk, owner, start)
    {
        self.initexpr(owner, start);
        var t = tk.get();
        if (!t.isop('('))
            SyntaxError('anonymous function expected', t);
        self.fn = new LocalFunctionStatement(start, tk, owner);
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.fn = self.fn.optimize();
        return self;
    }
    function emit(e, result)
    {
        var fn = self.fn;
        string reg = self.tempreg(REGvar);
        self.annotate(e);
        e.say(".const 'Sub' ", reg, " = '", fn.getsubid(), "'");
        if (result != '')
            e.say('newclosure ', result, ', ', reg);
    }
}

//*********************************************

// Condition class, contains and works with expressions used in
// conditional operators and statements.

const int CONDisruntime = 0, CONDistrue = 1, CONDisfalse = 2;

class Condition
{
    var condexpr;
    function set(expr)
    {
        self.condexpr = expr;
        return self;
    }
    function optimize_condition()
    {
        self.condexpr = self.condexpr.optimize();
    }
    function optimize()
    {
        self.condexpr = self.condexpr.optimize();
        return self;
    }
    function getvalue()
    {
        var condexpr = self.condexpr;
        if (condexpr.isliteral()) {
            switch (condexpr.checkresult()) {
            case REGint:
               int n = condexpr.getIntegerValue();
                if (n == 0)
                    return CONDisfalse;
                else
                    return CONDistrue;
            }
        }
        return CONDisruntime;
    }
    function emit_if(e, string labeltrue, string labelfalse)
    {
        var condexpr = self.condexpr;

        if ((condexpr instanceof ComparatorBaseExpr) ||
                (condexpr instanceof NullCheckerExpr))
            condexpr.emit_if(e, labeltrue);
        else {
            string reg = condexpr.emit_get(e);
            string type = condexpr.checkresult();
            switch(type) {
              case REGstring:
              case REGvar:
                e.emitif_null(reg, labelfalse);
              case REGint:
              case REGfloat:
                e.emitif(reg, labeltrue);
                break;
              default:
                InternalError('Invalid if condition');
            }
        }
    }
    function emit_else(e, string labelfalse)
    {
        var condexpr = self.condexpr;

        if ((condexpr instanceof ComparatorBaseExpr) ||
                (condexpr instanceof NullCheckerExpr))
            condexpr.emit_else(e, labelfalse);
        else {
            string reg = condexpr.emit_get(e);
            string type = condexpr.checkresult();
            switch(type) {
              case REGstring:
              case REGvar:
                e.emitif_null(reg, labelfalse);
              case REGint:
              case REGfloat:
                e.emitunless(reg, labelfalse);
                break;
              default:
                InternalError('Invalid if condition');
            }
        }
    }
}

//*********************************************

class Literal : SimpleExpr
{
    function isliteral() { return true; }
    function hascompilevalue() { return true; }
}

//*********************************************

class StringLiteral : Literal
{
    var strval;
    function StringLiteral(owner, t)
    {
        self.initexpr(owner, t);
        self.strval = t;
    }
    function isstringliteral() { return true; }
    function checkresult() { return REGstring; }
    function getPirString()
    {
        var strtok = self.strval;
        string str = strtok.str;
        int typesinglequoted = strtok instanceof TokenSingleQuoted;
        int need_unicode = 0;
        for (int code in str) {
            if (code > 127) {
                need_unicode = 1;
                break;
            }
        }
        if (need_unicode) {
            if (typesinglequoted) {
                typesinglequoted = false;
                string saux = str;
                str = '';
                for (string c in saux) {
                    if (c == '\')
                        c = '\\';
                    str += c;
                }
            }
            string result = '';
            int l = length(str);
            for (int i = 0; i < l; ++i) {
                string c = substr(str, i, 1);
                int n = ord(c);
                if (n > 127) {
                    string h = n.get_as_base(16);
                    result += '\x{' + h + '}';
                }
                else
                    result += c;
            }
            str = result;
        }
        string q = (typesinglequoted) ? "'" : '"';
        str = q + str + q;
        if (need_unicode)
            str = 'unicode:' + str;
        return str;
    }
    function get_value()
    {
        var strtok = self.strval;
        string str = strtok.str;
        if (strtok instanceof TokenQuoted) {
            var s = str;
            str = s.unescape('utf8');
        }
        return str;
    }
    function emit(e, result)
    {
        if (result != '')
            e.emitset(result, self.getPirString());
    }
    function emit_get(e)
    {
        return self.getPirString();
    }
}

//*********************************************

class IntegerLiteral : Literal
{
    var pos;
    var numval;
    function IntegerLiteral(owner, t,
            value [optional], int has_value [opt_flag])
    {
        self.initexpr(owner, t);
        self.pos = t;
        int n;
        if (has_value)
            n = value;
        else {
            string aux = t;
            n = aux;
        }
        self.numval = n;
    }
    function isintegerliteral() { return true; }
    function checkresult() { return REGint; }
    function getIntegerValue()
    {
        string aux= self.numval;
        int i= aux;
        return i;
    }
    function emit(e, result)
    {
        if (result != '') {
            int value = self.getIntegerValue();
            if (value == 0)
                e.emitnull(result);
            else
                e.emitset(result, value);
        }
    }
    function emit_get(e)
    {
        return self.getIntegerValue();
    }
}

//*********************************************

class FloatLiteral : Literal
{
    var numval;
    function FloatLiteral(owner, t)
    {
        self.initexpr(owner, t);
        self.numval = t;
    }
    function isfloatliteral() { return true; }
    function checkresult() { return REGfloat; }
    function getFloatValue()
    {
        string aux= self.numval;
        var n= new ['Float'];
        n =: aux;
        return n;
    }
    function emit(e, result)
    {
        if (result != '') {
            var n= self.getFloatValue();
            e.emitset(result, n);
        }
    }
    function emit_get(e)
    {
        // Make sure that a float constant is handled as such:
        // if it looks like an integer, add a dcimal part.
        string aux= self.numval;
        if (indexof(aux, '.') < 0)
            aux += '.0';
        return aux;
    }
}

//*********************************************

class IdentifierExpr : SimpleExpr
{
    var name;
    function isidentifier() { return true; }
    function IdentifierExpr(owner, t)
    {
        self.initexpr(owner, t);
        self.name = t;
    }
    function isnull()
    {
        return self.name.iskeyword(NULL);
    }
    function checkresult()
    {
        var desc = self.owner.getvar(self.name);
        if (desc != null)
            return desc.gettype();
        else {
            switch (self.name) {
            case SELF:
            case NULL:
                return REGvar;
            default:
                return '';
            }
        }
    }
    function getName()
    {
        string s = self.name;
        return s;
    }
    function checkIdentifier()
    {
        var name = self.name;
        if (name == null)
            InternalError('Bad thing');
        var desc = self.owner.getvar(name);
        string s;
        if (desc == null) {
            string sname = name;
            switch (sname) {
            case SELF:
                s = SELF; break;
            case NULL:
                s = NULL; break;
            default:
                s = '';
            }
        }
        else {
            if (desc.getid() != null)
                return desc.getid();
            else
                s= desc.getreg();
        }
        return s;
    }
    function getIdentifier()
    {
        var value = self.checkIdentifier();
        if (value == '') {
            string name = self.name;
            SyntaxError("Variable '" + name + "' is not defined", self.name);
        }
        return value;
    }
    function optimize()
    {
        var name = self.name;
        var desc = self.owner.getvar(name);
        if (desc != null) {
            if (desc.isconst() && desc.getid() == null)
                return desc.getvalue();
            int flags = desc.getflags();
            if (flags & VAR_is_volatile) {
                if (flags & VAR_is_lexical)
                    return new LexicalVolatileExpr(self, desc);
            }
        }
        return self;
    }
    function emit_getid(e)
    {
        string id = self.getIdentifier();
        var desc = self.owner.getvar(self.name);
        int flags = desc == null ? 0 : desc.getflags();
        if (flags & VAR_is_volatile) {
            if (flags & VAR_is_lexical) {
                string lexname = desc.getlex();
                if (lexname != null && lexname != '')
                    e.say("find_lex ", id, ", '", lexname, "'");
            }
        }
        return id;
    }
    function emit(e, result)
    {
        if (result != '') {
            self.annotate(e);
            string id = self.emit_getid(e);
            e.emitset(result, id);
        }
    }
    function emit_get(e)
    {
        self.annotate(e);
        string id = self.emit_getid(e);
        return id;
    }
    function emit_assign_get(e, expr)
    {
        self.annotate(e);
        if (self.isnull())
            die("NO");
        string typeleft = self.checkresult();
        string lreg = self.getIdentifier();
        if (expr.isnull()) {
            switch(typeleft) {
            case REGstring:
            case REGvar:
                e.emitnull(lreg);
                break;
            default:
                SyntaxError("Can't assign null to that type", self.start);
            }
        }
        else if (expr instanceof IndexExpr)
            expr.emit(e, lreg);
        else {
            string typeright = expr.checkresult();
            if (typeright == REGnone)
                SyntaxError("Can't assign from void expression", self.start);
            if (typeleft == typeright) {
                expr.emit(e, lreg);
            }
            else {
                string rreg = expr.emit_get(e);
                self.annotate(e);
                if (typeleft == REGvar && typeright != REGvar)
                    e.emitbox(lreg, rreg);
                else
                    e.emitset(lreg, rreg);
            }
        }
        return lreg;
    }
}

//*********************************************

class LexicalVolatileExpr : Expr
{
    var desc;
    function LexicalVolatileExpr(idexpr, desc)
    {
        self.initexpr(idexpr.owner, idexpr.start);
        self.desc = desc;
    }
    function checkresult() { return REGvar; }
    function emit_get(e)
    {
        var desc = self.desc;
        string lexname = desc.getlex();
        string reg = self.owner.tempreg(REGvar);
        e.say("find_lex ", reg, ", '", lexname, "'");
        return reg;
    }
    function emit(e, result)
    {
        if (result != '') {
            self.annotate(e);
            string reg = self.emit_get(e);
            e.emitset(result, reg);
        }
    }
    function emit_assign_get(e, expr)
    {
        string lreg = self.owner.tempreg(REGvar);
        if (expr.isnull())
            e.emitnull(lreg);
        else if (expr instanceof IndexExpr)
            expr.emit(e, lreg);
        else {
            string typeright = expr.checkresult();
            if (REGvar == typeright) {
                expr.emit(e, lreg);
            }
            else {
                string rreg = expr.emit_get(e);
                self.annotate(e);
                e.emitbox(lreg, rreg);
            }
        }

        var desc = self.desc;
        string lexname = desc.getlex();
        e.say("store_lex '", lexname, "', ", lreg);
    }
}

//*********************************************

class OpExpr : Expr
{
    function initop(owner, start)
    {
        self.initexpr(owner, start);
    }
}

//*********************************************

class OpClassExpr : OpExpr
{
    var clspec;

    function OpClassExpr(tk, owner, start)
    {
        self.initop(owner, start);
        self.clspec = parseClassSpecifier(tk, owner);
    }
    function checkresult() { return REGvar; }
    function emit(e, result)
    {
        var clspec = self.clspec;
        // In void context use a temporary and get it anyway,
        // to avoid discarding side effects.
        if (result == '')
            result = self.owner.tempreg(REGvar);
        e.print('get_class ', result, ', ');
        clspec.emit(e, self.owner);
        e.say();
    }
}

//*********************************************

class OpUnaryExpr : OpExpr
{
    var subexpr;
    function initunary(owner, start, subexpr)
    {
        self.initop(owner, start);
        self.subexpr = subexpr;
    }
    function optimizearg()
    {
        self.subexpr = self.subexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
}

//*********************************************

class OpBinaryExpr : OpExpr
{
    var lexpr;
    var rexpr;
    function initbinary(owner, start, lexpr, rexpr)
    {
        self.initop(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
    }
    function set(owner, t, lexpr, rexpr)
    {
        self.initbinary(owner, t, lexpr, rexpr);
        return self;
    }
    function setfrom(from)
    {
        return self.set(from.owner, from.start, from.lexpr, from.rexpr);
    }
    function optimizearg()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
    function emit_intleft(e)
    {
        string reg = self.lexpr.emit_getint(e);
        return reg;
    }
    function emit_intright(e)
    {
        string reg = self.rexpr.emit_getint(e);
        return reg;
    }
}

//*********************************************

class OpBinaryIntExpr : OpBinaryExpr
{
    function checkresult()
    {
        return REGint;
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isintegerliteral() && rexpr.isintegerliteral()) {
            int li = int(lexpr.numval);
            int ri = int(rexpr.numval);
            return integerValue(self.owner, self.start, self.do_op(li, ri));
        }
        return self;
    }
}

//*********************************************

class OpDelExBase : OpUnaryExpr
{
    function checkresult()
    {
        return REGint;
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
}


class OpDeleteExpr : OpDelExBase
{
    function emit(e, result)
    {
        var expr = self.subexpr;
        if (expr instanceof IndexExpr && expr.checkresult() != REGstring) {
            expr.emit_prep(e);
            self.annotate(e);
            e.print('delete ');
            expr.emit_aux(e);
            e.say();
            if (result != '')
                e.emitset(result, '1');
        }
        else
            SyntaxError("delete with invalid operator", self.start);
    }
}

class OpExistsExpr : OpDelExBase
{
    function emit(e, result)
    {
        var expr = self.subexpr;
        // TODO: empty result shouldn't be allowed, check.
        string reg = result != '' ? result : self.tempreg(REGint);
        if (expr instanceof IndexExpr && expr.checkresult() != REGstring) {
            expr.emit_prep(e);
            self.annotate(e);
            e.print('exists ', reg, ', ');
            expr.emit_aux(e);
            if (result != '')
                e.say();
        }
        else
            SyntaxError("exists with invalid operator", self.start);
    }
    function emit_get(e)
    {
        var expr = self.subexpr;
        string reg = self.tempreg(REGint);
        if (expr instanceof IndexExpr && expr.checkresult() != REGstring) {
            expr.emit_prep(e);
            self.annotate(e);
            e.print('exists ', reg, ', ');
            expr.emit_aux(e);
            e.say();
            return reg;
        }
        else
            SyntaxError("exists with invalid operator", self.start);
    }
}

//*********************************************

class OpUnaryMinusExpr : OpUnaryExpr
{
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        self.optimizearg();
        if (self.subexpr.isintegerliteral()) {
            var numval = self.subexpr.numval;
            int i = numval;
            return integerValue(self.owner, self.subexpr.start, -i);
        }
        if (__STAGE__ != '0') {
            if (self.subexpr.isfloatliteral()) {
                var numval = self.subexpr.numval;
                float n = string(numval);
                return floatValue(self.owner, self.subexpr.start, -n);
            }
        }
        return self;
    }
    function emit(e, result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.say('neg ', result, ', ', reg);
    }
}

//*********************************************

class OpNotExpr : OpUnaryExpr
{
    function isnegable() { return true; }
    function checkresult()
    {
        return REGint;
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        self.optimizearg();
        var subexpr = self.subexpr;
        if (subexpr.isintegerliteral()) {
            var numval = subexpr.numval;
            int n = numval;
            return integerValue(self.owner, subexpr.start, ! n);
        }
        if (subexpr.isnegable())
            return subexpr.negated();
        return self;
    }
    function negated()
    {
        return self.subexpr;
    }
    function emit(e, result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        string type = self.subexpr.checkresult();
        switch (type) {
        case REGint:
            e.say('not ', result, ', ', reg);
            break;
        case REGvar:
            e.say('isfalse ', result, ', ', reg);
            break;
        default:
            e.say('isfalse ', result, ', ', reg);
        }
    }
}

//*********************************************

class OpPreIncExpr : OpUnaryExpr
{
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        self.subexpr = subexpr;
        return self;
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        if (result != '')
            e.emitset(result, reg);
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitinc(reg);
        return reg;
    }
}

//*********************************************

class OpPostIncExpr : OpUnaryExpr
{
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function emit(e, result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        if (result != '')
            e.emitset(result, reg);
        e.emitinc(reg);
        return reg;
    }
}

//*********************************************

class OpPreDecExpr : OpUnaryExpr
{
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        if (result != '')
            e.emitset(result, reg);
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitdec(reg);
        return reg;
    }
}

//*********************************************

class OpPostDecExpr : OpUnaryExpr
{
    function set(owner, t, subexpr)
    {
        self.initunary(owner, t, subexpr);
        return self;
    }
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function emit(e, result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        if (result != '')
            e.emitset(result, reg);
        e.emitdec(reg);
        return reg;
    }
}

//*********************************************

class OpBaseAssignExpr : Expr
{
    var lexpr;
    var rexpr;
    function set(owner, start, lexpr, rexpr)
    {
        self.initexpr(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
        return self;
    }
    function checkresult()
    {
        return self.lexpr.checkresult();
    }
    function optimize_base()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
        return self;
    }
    function optimize()
    {
        return self.optimize_base();
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        if (result != '') {
            self.annotate(e);
            e.emitset(result, reg);
        }
    }
}

//*********************************************

class OpAssignExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        self.annotate(e);
        var lexpr = self.lexpr;
        return lexpr.emit_assign_get(e, self.rexpr);
    }
}

//*********************************************

class OpAssignToExpr : OpBaseAssignExpr
{
    function emit(e, result)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
        if (result != null && result != '')
            e.emitassign(result, reg);
    }
    function emit_get(e)
    {
        self.annotate(e);
        string reg = self.lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        e.emitassign(reg, reg2);
        return reg;
    }
}

//*********************************************

class OpAddToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string reg = lexpr.emit_get(e);
        if (ltype == REGstring && (rexpr instanceof ConcatString))
            rexpr.emit_concat_to(e, reg);
        else {
            string reg2 = rexpr.emit_get(e);
            string aux;
            self.annotate(e);
            switch (ltype) {
              case REGstring:
                if (rtype != REGstring) {
                    aux = self.tempreg(REGstring);
                    e.emitset(aux, reg2);
                    reg2 = aux;
                }
                e.emitconcat1(reg, reg2);
                break;
              case REGint:
              case REGfloat:
                if (ltype != rtype) {
                    aux = self.tempreg(ltype);
                    e.emitset(aux, reg2);
                    reg2 = aux;
                }
                e.emitaddto(reg, reg2);
                break;
              default:
                e.emitaddto(reg, reg2);
            }
        }
        return reg;
    }
}

//*********************************************

class OpSubToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string reg = lexpr.emit_get(e);
        string reg2 = rexpr.emit_get(e);
        string aux;
        self.annotate(e);
        switch (ltype) {
          case REGstring:
            InternalError('-= to string must not happen', self.start);
          case REGint:
          case REGfloat:
            if (ltype != rtype) {
                aux = self.tempreg(ltype);
                e.emitset(aux, reg2);
                reg2 = aux;
            }
            e.emitsubto(reg, reg2);
            break;
          default:
            e.emitsubto(reg, reg2);
        }
        return reg;
    }
}

//*********************************************

class OpMulToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        string ltype = self.lexpr.checkresult();
        string rtype = self.lexpr.checkresult();
        string lreg = self.lexpr.emit_get(e);
        string rreg;
        switch (ltype) {
          case REGstring:
            if (rtype == REGint)
                rreg = self.rexpr.emit_get(e);
            else {
                rreg = self.tempreg(REGint);
                self.rexpr.emit(e, rreg);
            }
            self.annotate(e);
            e.say('repeat ', lreg, ', ', lreg, ', ', rreg);
            break;
          default:
            rreg = self.rexpr.emit_get(e);
            self.annotate(e);
            e.say('mul ', lreg, ', ', rreg);
        }
        return lreg;
    }
}

//*********************************************

class OpDivToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        string type = self.lexpr.checkresult();
        string reg = self.lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.say('div ', reg, ', ', reg2);
        return reg;
    }
}

//*********************************************

class OpModToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        string type = self.lexpr.checkresult();
        string reg = self.lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.say('mod ', reg, ', ', reg2);
        return reg;
    }
}

//*********************************************

class ComparatorBaseExpr : OpBinaryExpr
{
    function checkresult() { return REGint; }
    function emit_comparator(e, result, int doifelse[optional])
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        string regl = self.lexpr.emit_get(e);
        string regr = self.rexpr.emit_get(e);
        self.annotate(e);
        string aux;
        if (rl == REGfloat || rr == REGfloat)
        {
            if (rl == REGint) {
                aux = self.tempreg(REGfloat);
                e.emitset(aux, regl);
                regl = aux;
            }
            if (rr == REGint) {
                aux = self.tempreg(REGfloat);
                e.emitset(aux, regr);
                regr = aux;
            }
        }
        else if (rr == REGint && rl == REGvar) {
            aux = self.tempreg(REGint);
            e.emitset( aux, regl);
            regl = aux;
        }
        else if (rr == REGvar && rl == REGint) {
            aux = self.tempreg(REGint);
            e.emitset(aux, regr);
            regr = aux;
        }
        else if (rr == REGstring && rl == REGvar) {
            aux = self.tempreg(REGstring);
            e.emitset(aux, regl);
            regl = aux;
        }
        else if (rr == REGvar && rl == REGstring) {
            aux = self.tempreg(REGstring);
            e.emitset(aux, regr);
            regr = aux;
        }

        switch (doifelse) {
          case 0:
            self.emitop(e, result, regl, regr);
            break;
          case 1:
            self.emitop_if(e, result, regl, regr);
            break;
          case 2:
            self.emitop_else(e, result, regl, regr);
            break;
        }
    }
    function emit(e, result)
    {
        self.emit_comparator(e, result);
    }
    function emit_if(e, string labeltrue)
    {
        self.emit_comparator(e, labeltrue, 1);
    }
    function emit_else(e, string labelfalse)
    {
        self.emit_comparator(e, labelfalse, 2);
    }
}

//*********************************************

// Null checkers, created during optimize of Equal and NotEqual
// to simplify its emit functions.

class NullCheckerExpr : Expr
{
    var expr;
    var checknull;

    function NullCheckerExpr(base, expr, int checknull)
    {
        self.initexpr(base.owner, base.start);
        self.expr = expr;
        self.checknull = checknull;
    }
    function checkresult() { return REGint; }
    function isnegable() { return true; }
    function negated()
    {
        int checkneg = ! self.checknull;
        self.checknull = checkneg;
        return self;
    }
    function emit(e, result)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        e.say('isnull ', result, ', ', reg);
        if (! self.checknull)
            e.say('not ', result);
    }
    function emit_else(e, string labelelse)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        e.say(self.checknull ? 'unless' : 'if', '_null ', reg, ', ', labelelse);
    }
}

//*********************************************

class OpEqualExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return new OpNotEqualExpr().setfrom(self);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        int lnull = lexpr.isnull();
        int rnull = rexpr.isnull();
        if (lnull) {
            if (rnull)
                return integerValue(self.owner, self.start, 1);
            else
                return new NullCheckerExpr(self, self.rexpr, true);
        }
        if (rnull)
            return new NullCheckerExpr(self, self.lexpr, true);
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            if (ltype == REGstring && rtype == REGstring) {
                string ls = (lexpr.strval).str;
                string rs = (rexpr.strval).str;
                return integerValue(self.owner, self.start, ls == rs);
            }
        }
        return self;
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('iseq', result, regl, regr);
    }
    function emit(e, result)
    {
        self.emit_comparator(e, result);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.say('eq ', regl, ', ', regr, ', ', labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.say('ne ', regl, ', ', regr, ', ', labelelse);
    }
}

//*********************************************

class OpNotEqualExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return new OpEqualExpr().setfrom(self);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        int lnull = lexpr.isnull();
        int rnull = rexpr.isnull();
        if (lnull) {
            if (rnull)
                return integerValue(self.owner, self.start, 0);
            else
                return new NullCheckerExpr(self, self.rexpr, false);
        }
        if (rnull)
            return new NullCheckerExpr(self, self.lexpr, false);
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            if (ltype == REGstring && rtype == REGstring) {
                string ls = (lexpr.strval).str;
                string rs = (rexpr.strval).str;
                return integerValue(self.owner, self.start, ls != rs);
            }
        }
        return self;
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('isne', result, regl, regr);
    }
    function emit(e, result)
    {
        self.emit_comparator(e, result);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.say('ne ', regl, ', ', regr, ', ', labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.say('eq ', regl, ', ', regr, ', ', labelelse);
    }
}

//**********************************************************************

class OpSameExpr : ComparatorBaseExpr
{
    var positive;
    function OpSameExpr(int positiveform, owner, t, lexpr, rexpr)
    {
        self.initbinary(owner, t, lexpr, rexpr);
        self.positive = positiveform;
    }
    function isnegable() { return true; }
    function negated()
    {
        int positive = self.positive;
        return new OpSameExpr(! positive, self.owner, self.start, self.lexpr, self.rexpr);
    }
    function emitop(e, string result, string regl, string regr)
    {
        int positive = self.positive;
        string op = positive ? 'issame' : 'isntsame';
        e.emitbinop(op, result, regl, regr);
    }
    function emit(e, result)
    {
        self.emit_comparator(e, result);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        int positive = self.positive;
        string op = positive ? 'eq_addr' : 'ne_addr';
        e.say(op, ' ', regl, ', ', regr, ', ', labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        int positive = self.positive;
        string op = positive ? 'ne_addr' : 'eq_addr';
        e.say(op, ' ', regl, ', ', regr, ', ', labelelse);
    }
}

//*********************************************

class OpLessExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return new OpGreaterEqualExpr().setfrom(self);
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('islt', result, regl, regr);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.say('lt ', regl, ', ', regr, ', ', labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.say('ge ', regl, ', ', regr, ', ', labelelse);
    }
}

//*********************************************

class OpGreaterExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return new OpLessEqualExpr().setfrom(self);
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('isgt', result, regl, regr);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.say('gt ', regl, ', ', regr, ', ', labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.say('le ', regl, ', ', regr, ', ', labelelse);
    }
}

//*********************************************

class OpLessEqualExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return new OpGreaterExpr().setfrom(self);
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('isle', result, regl, regr);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.say('le ', regl, ', ', regr, ', ', labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.say('gt ', regl, ', ', regr, ', ', labelelse);
    }
}

//*********************************************

class OpGreaterEqualExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return new OpLessExpr().setfrom(self);
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('isge', result, regl, regr);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.say('ge ', regl, ', ', regr, ', ', labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.say('lt ', regl, ', ', regr, ', ', labelelse);
    }
}

//*********************************************

class OpBaseBoolExpr : OpBinaryExpr
{
    function checkresult()
    {
        return REGint;
    }
}

//*********************************************

class OpBoolAndExpr : OpBaseBoolExpr
{
    function optimize()
    {
        self.optimizearg();
        if (self.lexpr.isintegerliteral() ) {
            var lval = self.lexpr.numval;
            int ln = lval;
            if (ln != 0)
               return self.rexpr;
            else
                return integerValue(self.owner, self.start, ln);
        }
        return self;
    }
    function emit(e, result)
    {
        string res = result != null ? result : self.tempreg(REGint);
        if (self.lexpr.issimple() && self.rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop('and', res, lreg, rreg);
        }
        else {
            string l = self.owner.genlabel();
            self.lexpr.emit(e, res);
            e.emitunless(res, l);
            self.rexpr.emit(e, res);
            e.emitlabel(l);
        }
    }
}

//*********************************************

class OpBoolOrExpr : OpBaseBoolExpr
{
    function optimize()
    {
        self.optimizearg();
        if (self.lexpr.isintegerliteral() ) {
            var lval = self.lexpr.numval;
            int ln = lval;
            if (ln == 0)
               return self.rexpr;
            else
                return integerValue(self.owner, self.start, ln);
        }
        return self;
    }
    function emit(e, result)
    {
        string res;
        if (result != null)
            res = result;
        else
            res = self.tempreg(REGint);
        if (self.lexpr.issimple() && self.rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop('or', res, lreg, rreg);
        }
        else {
            string l = self.owner.genlabel();
            self.lexpr.emit(e, res);
            e.emitif(res, l);
            self.rexpr.emit(e, res);
            e.emitlabel(l);
        }
    }
}

//*********************************************

class OpBaseBinExpr : OpBinaryIntExpr
{
}

//*********************************************

class OpBinAndExpr : OpBaseBinExpr
{
    function emit(e, result)
    {
        string res = result != null ? result : self.tempreg(REGint);
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('band', res, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left & right;
    }
}

//*********************************************

class OpBinOrExpr : OpBaseBinExpr
{
    function emit(e, result)
    {
        string res = result != null ? result : self.tempreg(REGint);
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('bor', res, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left | right;
    }
}

//*********************************************

class OpBinXorExpr : OpBaseBinExpr
{
    function emit(e, result)
    {
        string res = result != null ? result : self.tempreg(REGint);
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('bxor', res, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left ^ right;
    }
}

//*********************************************

class ConcatString : Expr
{
    var values;
    function ConcatString(owner, start, lexpr, rexpr)
    {
        self.initexpr(owner, start);
        if (lexpr instanceof ConcatString) {
            self.values = lexpr.values;
            if (rexpr instanceof ConcatString)
                self.values.append(rexpr.values);
            else
                push(self.values, rexpr);
        }
        else if (rexpr instanceof ConcatString) {
            self.values = rexpr.values;
            self.values.unshift(lexpr);
        }
        else
            self.values = [lexpr, rexpr];
    }
    function checkresult() { return REGstring; }
    function getregs(e)
    {
        var values = self.values;
        int nvalues = elements(values);
        string regvalues[nvalues];
        int i;
        for (i = 0; i < nvalues; ++i)
            regvalues[i] = string(values[i].emit_get(e));
        return regvalues;
    }
    function emit(e, result)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        string auxreg = '$S0';
        self.annotate(e);
        e.emitconcat(auxreg, regvalues[0], regvalues[1]);
        for (int i = 2; i < nvalues; ++i)
            e.emitconcat1(auxreg, regvalues[i]);
        e.emitset(result, auxreg);
    }
    function emit_get(e)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        string auxreg = self.tempreg(REGstring);
        self.annotate(e);
        e.emitconcat(auxreg, regvalues[0], regvalues[1]);
        for (int i = 2; i < nvalues; ++i)
            e.emitconcat1(auxreg, regvalues[i]);
        return auxreg;
    }
    function emit_concat_to(e, result)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        self.annotate(e);
        for (int i = 0; i < nvalues; ++i)
            e.emitconcat1(result, regvalues[i]);
    }
    function emit_concat_set(e, result)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        self.annotate(e);
        e.emitconcat(result, regvalues[0], regvalues[1]);
        for (int i = 2; i < nvalues; ++i)
            e.emitconcat1(result, regvalues[i]);
    }
}

//*********************************************

class OpAddExpr : OpBinaryExpr
{
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        if (lexpr.isliteral() && rexpr.isliteral()) {
            if (ltype == REGstring && rtype == REGstring) {
                var etok = lexpr.strval;
                var rtok = rexpr.strval;
                var t;
                string es = etok.str;
                string rs = rtok.str;
                if ((etok instanceof TypeSingleQuoted) && (rtok instanceof TypeSingleQuoted))
                    t = new TokenSingleQuoted(etok.file, etok.line, es + rs);
                else
                    t = new TokenQuoted(etok.file, etok.line, es + rs);
                return new StringLiteral(self.owner, t);
            }
            if (ltype == REGint && rtype == REGint) {
                var lval = lexpr.numval;
                int ln = lval;
                var rval = rexpr.numval;
                int rn = rval;
                return integerValue(self.owner, self.start, ln + rn);
            }
            if (__STAGE__ != '0') {
                if (floatresult(ltype, rtype)) {
                    var lvalf = lexpr.numval;
                    float lf = string(lvalf);
                    var rvalf = rexpr.numval;
                    float rf = string(rvalf);
                    return floatValue(self.owner, self.start, lf + rf);
                }
            }
        }
        if (ltype == REGstring && rtype == REGstring) {
            return new ConcatString(self.owner, self.start, lexpr, rexpr);
        }
        return self;
    }
    function checkresult()
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        if (rl == REGint && rr == REGstring)
            return REGstring;
        if (rl == REGstring && rr == REGint)
            return REGstring;
        if (floatresult(rl, rr))
            return REGfloat;
        return REGint;
    }
    function emit(e, result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string restype = self.checkresult();
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();

        string rleft = lexpr.emit_get(e);
        string rright = rexpr.emit_get(e);
        if (restype == REGstring) {
            if (ltype != REGstring || rtype != REGstring) {
                string aux = self.tempreg(REGstring);
                if (ltype != REGstring) {
                    e.emitset(aux, rleft);
                    rleft = aux;
                }
                else {
                    e.emitset(aux, rright);
                    rright = aux;
                }
            }
            e.emitconcat(result, rleft, rright);
        }
        else {
            if (restype == REGint && (ltype != REGint || rtype != REGint)) {
                string l;
                if (ltype == REGint) l = rleft;
                else {
                    l = self.tempreg(REGint);
                    e.emitset(l, rleft);
                }
                string r;
                if (rtype == REGint) r = rright;
                else {
                    r = self.tempreg(REGint);
                    e.emitset(r, rright);
                }
                e.emitadd(result, l, r);
            }
            else
                e.emitadd(result, rleft, rright);
        }
    }
}

//*********************************************

class OpSubExpr : OpBinaryExpr
{
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            if (ltype == REGint && rtype == REGint) {
                var lval = lexpr.numval;
                int ln = lval;
                var rval = rexpr.numval;
                int rn = rval;
                return integerValue(self.owner, self.start, ln - rn);
            }
        }
        return self;
    }
    function checkresult()
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        if (rl == REGint && rr == REGfloat)
            return REGfloat;
        if (rl == REGfloat && rr == REGint)
            return REGfloat;
        return REGint;
    }
    function emit(e, result)
    {
        string lreg = self.lexpr.emit_get(e);
        string rreg = self.rexpr.emit_get(e);
        e.say('sub ', result, ', ', lreg, ', ', rreg);
    }
}

//*********************************************

class OpMulExpr : OpBinaryExpr
{
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            if (ltype == REGint && rtype == REGint) {
                var lval = lexpr.numval;
                int ln = lval;
                var rval = rexpr.numval;
                int rn = rval;
                return integerValue(self.owner, self.start, ln * rn);
            }
            if (__STAGE__ != '0') {
                if (floatresult(ltype, rtype)) {
                    var lvalf = lexpr.numval;
                    float lf = string(lvalf);
                    var rvalf = rexpr.numval;
                    float rf = string(rvalf);
                    return floatValue(self.owner, self.start, lf * rf);
                }
            }
        }
        return self;
    }
    function checkresult()
    {
        var lexpr = self.lexpr;
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        if (rl == REGstring)
            return REGstring;
        else
            return REGfloat;
    }
    function emit(e, result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string lreg, rreg;
        if (ltype == REGstring) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            string rval;
            switch (rtype) {
            case REGint:
                rval = rreg;
                break;
            default:
                rval = self.tempreg(REGint);
                e.emitset(rval, rreg);
            }
            self.annotate(e);
            e.say('repeat ', result, ', ', lreg, ', ', rval);
            return;
        }
        if (ltype == rtype && (ltype == REGint || ltype == REGfloat || ltype == REGvar)) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            e.emitmul(result, lreg, rreg);
            return;
        }

        // Quick fix for some float mul
        // TODO: rewrite this mess
        if (ltype == REGfloat) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            string rval;
            switch (rtype) {
            case REGint:
                rval = self.tempreg(REGfloat);
                e.emitset(rval, rreg);
                rval = rreg;
                break;
            case REGfloat:
                rval = rreg;
                break;
            default:
                rval = self.tempreg(REGfloat);
                e.emitset(rval, rreg);
            }
            if (result != '') {
                self.annotate(e);
                e.emitmul(result, lreg, rval);
            }
            return;
        }

        int nleft, nright;
        if ((!lexpr.issimple()) || lexpr.isidentifier()) {
            lreg= self.tempreg(self.checkresult());
            lexpr.emit(e, lreg);
        }
        else {
            nleft= lexpr.getIntegerValue();
            lreg= nleft;
        }
        if ((!rexpr.issimple()) || rexpr.isidentifier()) {
            rreg= self.tempreg(self.checkresult());
            rexpr.emit(e, rreg);
        }
        else {
            switch (rtype) {
              case REGstring:
                rreg= self.tempreg(self.checkresult());
                rexpr.emit(e, rreg);
                break;
              case REGfloat:
                rreg = rexpr.emit_get(e);
                break;
              case REGint:
              default:
                nright= rexpr.getIntegerValue();
                rreg= nright;
                break;
            }
        }
        self.annotate(e);
        if (result == '')
            result = self.tempreg(self.checkresult());
        e.emitmul(result, lreg, rreg);
    }
}

//*********************************************

class OpDivExpr : OpBinaryExpr
{
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            var lval;
            var rval;
            if (ltype == REGint && rtype == REGint) {
                lval = lexpr.numval;
                int ln = lval;
                rval = rexpr.numval;
                int rn = rval;
                if (rn != 0)
                    return integerValue(self.owner, self.start, ln / rn);
            }
            if (__STAGE__ != '0') {
                if (floatresult(ltype, rtype)) {
                    lval = lexpr.numval;
                    float lf = string(lval);
                    rval = rexpr.numval;
                    float rf = string(rval);
                    if (rf != 0)
                        return floatValue(self.owner, self.start, lf / rf);
                }
            }
        }
        return self;
    }
    function checkresult()
    {
        return REGfloat;
    }
    function emit(e, result)
    {
        var lexpr = self.lexpr;
        var aux;
        var lreg = lexpr.emit_get(e);
        if (lexpr.checkresult() != REGfloat) {
            aux = self.tempreg(REGfloat);
            e.emitset(aux, lreg);
            lreg = aux;
        }
        var rexpr = self.rexpr;
        var rreg = rexpr.emit_get(e);
        if (rexpr.checkresult() != REGfloat) {
            aux = self.tempreg(REGfloat);
            e.emitset(aux, rreg);
            rreg = aux;
        }
        self.annotate(e);
        e.say('div ', result, ', ', lreg, ', ', rreg);
    }
}

//*********************************************

class OpModExpr : OpBinaryIntExpr
{
    function emit(e, result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('mod', result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left % right;
    }
}

//*********************************************

class OpCModExpr : OpBinaryExpr
{
    function checkresult()
    {
        return REGint;
    }
    function emit(e, result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);

        // WORKAROUND:
        // e.say('cmod ', result, ', ', lreg, ', ', rreg);
        // cmod is now a dynop. Silly workaround, use mod instead.
        e.emitbinop('mod', result, lreg, rreg);
    }
}

//*********************************************

class OpShiftleftExpr : OpBinaryIntExpr
{
    function emit(e, result)
    {
        string res = result != null ? result : self.tempreg(REGint);
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('shl', res, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left << right;
    }
}

//*********************************************

class OpShiftrightExpr : OpBinaryIntExpr
{
    function emit(e, result)
    {
        string res = result != null ? result : self.tempreg(REGint);
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('shr', res, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left >> right;
    }
}

//*********************************************

class Argument
{
    var arg;
    var modifiers;
    function Argument(var arg, var modifiers)
    {
        self.arg = arg;
        self.modifiers = modifiers;
    }
    function optimize()
    {
        self.arg = self.arg.optimize();
        return self;
    }
    function hascompilevalue()
    {
        return self.arg.hascompilevalue();
    }
}

class ArgumentList
{
    var owner;
    var start;
    var args;
    var argregs;

    function ArgumentList(owner, start, tk, string delimiter)
    {
        self.owner = owner;
        self.start = start;
        var args = [];
        var t = tk.get();
        if (! t.isop(delimiter)) {
            tk.unget(t);
            do {
                var modifier = null;
                var expr = parseExpr(tk, owner);
                t = tk.get();
                if (t.isop(':')) {
                    t = tk.get();
                    if (t.isop('[')) {
                        modifier = new ModifierList(tk, owner);
                        t = tk.get();
                    }
                    else {
                        InternalError('Checking implementation');
                    }
                }
                push(args, new Argument(expr, modifier));
            } while (t.isop(','));
            if (! t.isop(delimiter))
                SyntaxError("Unfinished argument list", t);
            if (elements(args) > 0)
                self.args = args;
        }
    }
    function numargs()
    {
        var args = self.args;
        return args == null ? 0 : elements(args);
    }
    function getrawargs()
    {
        return self.args;
    }
    function getarg(int i)
    {
        var args = self.args;
        return args[i];
    }
    function getfreearg(int i)
    {
        var args = self.args;
        return args[i].arg;
    }
    function optimize()
    {
        var args = self.args;
        if (args != null)
            optimize_array(args);
        return self;
    }
    function getargvalues(var e)
    {
        var argregs = self.argregs;
        if (argregs == null) {
            string regs[];
            string pnull = '';
            argregs = regs;
            var args = self.args;
            int nargs = elements(args);
            for (int i = 0; i < nargs; ++i) {
                var a = args[i].arg;
                string reg;
                if (a.isnull())
                {
                    if (pnull == '') {
                        pnull = self.owner.tempreg(REGvar);
                        e.emitnull(pnull);
                        reg = pnull;
                    }
                }
                else
                    reg = a.emit_get(e);
                push(argregs, reg);
            }
            self.argregs = argregs;
        }
        return argregs;
    }
    function emitargs(var e)
    {
        var args = self.args;
        var argreg = self.getargvalues(e);

        string sep = '';
        int n = self.numargs();
        for (int i = 0; i < n; ++i) {
            string a = argreg[i];
            e.print(sep, a);
            int isflat = 0, isnamed = 0;
            string setname = '';
            var modifiers = args[i].modifiers;
            if (modifiers != null) {
                for (var modif in modifiers.getlist()) {
                    string name = modif.getname();
                    if (name == 'flat')
                        isflat = 1;
                    if (name == 'named') {
                        isnamed = 1;
                        switch (modif.numargs()) {
                          case 0: 
                            break;
                          case 1:
                            var argmod = modif.getarg(0);
                            if (! argmod.isstringliteral())
                                SyntaxError('Invalid modifier', self.start);
                            setname = argmod.getPirString();
                            break;
                          default:
                            SyntaxError('Invalid modifier', self.start);
                        }
                    }
                }
            }
            if (isflat && isnamed)
                e.print(' :flat :named');
            else if (isflat)
                e.print(' :flat');
            else if (isnamed) {
                e.print(' :named');
                if (setname != '')
                    e.print("(", setname, ")");
            }
            sep = ', ';
        }
    }
}

function arglist_hascompilevalue(var arglist)
{
    for (var arg in arglist)
        if (! arg.hascompilevalue())
            return false;
    return true;
}

//*********************************************

class CallPredefExpr : Expr
{
    var predef;
    var args;

    function CallPredefExpr(owner, start, predef, args)
    {
        self.initexpr(owner, start);
        self.predef = predef;
        self.args = args;
    }
    function checkresult()
    {
        return self.predef.result();
    }
    function emit(e, result)
    {
        var predef = self.predef;
        var args = self.args;
        string argreg[];
        var arg;
        int np = predef.params();
        string pnull = '';
        switch (np) {
          case PREDEF_arglist:
            for (arg in args) {
                string reg = arg.arg.emit_get(e);
                // Special case
                if (reg == NULL) {
                    if (pnull == '') {
                        pnull = self.tempreg(REGvar);
                        e.emitnull(pnull);
                    }
                    reg = pnull;
                }
                push(argreg, reg);
            }
            break;
          case PREDEF_raw1:
            var rawargs = [];
            for (arg in args)
                push(rawargs, arg.arg);
            self.predef.expand(e, self, self.start, result, rawargs);
            return;
          default:
            int n = self.args;
            for (int i = 0; i < n; ++i) {
                arg = args[i].arg;
                string argtype = arg.checkresult();
                string paramtype = predef.paramtype(i);
                string argr;
                if (arg.isnull()) {
                    switch (paramtype) {
                      case REGint:
                      case REGfloat:
                      case REGstring:
                        argr = self.tempreg(paramtype);
                        e.emitnull(argr);
                      default:
                        if (pnull == '') {
                            pnull = self.tempreg(REGvar);
                            e.emitnull(pnull);
                        }
                        argr = pnull;
                    }
                }
                else {
                    if (argtype == paramtype || paramtype == REGany)
                        argr = arg.emit_get(e);
                    else {
                        string aux;
                        argr = self.tempreg(paramtype);
                        switch (paramtype) {
                          case REGvar:
                            switch (argtype) {
                              case REGint:
                              case REGfloat:
                              case REGstring:
                                aux = arg.emit_get(e);
                                e.emitbox(argr, aux);
                                break;
                              default:
                                arg.emit(e, argr);
                            }
                            break;
                          case REGint:
                          case REGfloat:
                          case REGstring:
                            aux = arg.emit_get(e);
                            e.emitset(argr, aux);
                            break;
                          default:
                            arg.emit(e, argr);
                        }
                    }
                }
                push(argreg, argr);
            }
        }
        self.predef.expand(e, self, self.start, result, argreg);
    }
}

//*********************************************

class CallExpr : Expr
{
    var funref;
    var args;

    function CallExpr(tk, owner, start, subexp)
    {
        self.initexpr(owner, start);
        self.funref = subexp;
        var t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            self.args = new ArgumentList(owner, start, tk, ')');
        }
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        var funref = self.funref.optimize();
        var args = self.args;
        int nargs = 0;
        if (args != null) {
            args = args.optimize();
            nargs = args.numargs();
        }

        if (funref instanceof MemberExpr)
            return new CallMemberExpr(self, funref, args);
        if (funref instanceof MemberRefExpr)
            return new CallMemberRefExpr(self, funref, args);

        // Check for predefined functions
        if (funref.isidentifier()) {
            string call = funref.getName();
            var predef = findpredef(call, nargs);
            if (predef != null) {
                self.use_predef(call);
                var rawargs = nargs == 0 ? [] : args.getrawargs();

                // Check for compile time evaluation.
                var evalfun = predef.evalfun;
                if (evalfun != null) {
                    if (arglist_hascompilevalue(rawargs))
                        return evalfun(self.owner, self.start, rawargs);
                }

                return new CallPredefExpr(self.owner, self.start, predef, rawargs);
            }
        }

        self.funref = funref;
        self.args = args;
        return self;
    }
    function cantailcall()
    {
        return true;
    }
    function emitcall(e)
    {
        var funref = self.funref;
        string call;
        if (funref.isidentifier()) {
            call = funref.checkIdentifier();
            if (call == '')
                call = join("", [ "'", funref.getName(), "'" ] );
        }
        else
            call = funref.emit_get(e);
        return call;
    }
    function emit(e, result)
    {
        var funref = self.funref;
        string call = self.emitcall(e);
        var args = self.args;
        if (args != null)
            args.getargvalues(e);

        self.annotate(e);

        if (result != null && result != '') {
            if (result == '.tailcall')
                e.print('.tailcall ');
            else
                e.print(result, ' = ');
        }

        e.print(call);
        e.print('(');
        if (args != null)
            args.emitargs(e);
        e.say(')');
    }
}

//*********************************************

// Method calls. Always created from CallExpr, never directly.

// Method call by name.
class CallMemberExpr : CallExpr
{
    function CallMemberExpr(callst, funref, args)
    {
        self.initexpr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
    }
    function emitcall(e)
    {
        var funref = self.funref;
        return join("", [ funref.emit_left_get(e),
                ".'", funref.get_member(), "'" ] );
    }
}

// Method call by reference.
// The reference is a expression, its result must be a var containing a
// invokable or a string with the method name.
class CallMemberRefExpr : CallExpr
{
    function CallMemberRefExpr(callst, funref, args)
    {
        self.initexpr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
    }
    function emitcall(e)
    {
        var funref = self.funref;
        var right = funref.right;
        var type = right.checkresult();
        if (type != REGvar && type != REGstring)
            SyntaxError("Invalid expression type in '.*'", funref.start);
        // We want a well defined order of evaluation here, so use variables
        // to store intermediate results.
        string lreg = funref.emit_left_get(e);
        string rreg = right.emit_get(e);
        return lreg + '.' + rreg;
    }
}

//*********************************************

class MemberExprBase : Expr
{
    var left;
    function MemberExprBase(owner, start, subexp)
    {
        self.initexpr(owner, start);
        self.left = subexp;
    }
    function emit_left_get(e)
    {
        var left = self.left;
        string type = left.checkresult();
        string reg = left.emit_get(e);
        if (type != REGvar) {
            string auxreg = reg;
            reg = self.tempreg(REGvar);
            e.emitbox(reg, auxreg);
        }
        return reg;
    }
}

class MemberExpr : MemberExprBase
{
    var right;

    function MemberExpr(owner, start, subexp, right)
    {
        self.MemberExprBase(owner, start, subexp);
        self.right = right;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.left = self.left.optimize();
        return self;
    }
    function get_member()
    {
        return self.right;
    }
    function emit_get(e)
    {
        string obj = self.left.emit_get(e);
        string ident = self.right.getidentifier();
        string result = self.tempreg(REGvar);
        self.annotate(e);
        e.say('getattribute ', result, ', ', obj, ", '", ident, "'");
        return result;
    }
    function emit(e, result)
    {
        string obj = self.left.emit_get(e);
        string ident = self.right.getidentifier();
        self.annotate(e);
        e.say('getattribute ', result, ', ', obj, ", '", ident, "'");
    }
    function emit_init(e, result)
    {
        self.emit(e, result);
    }
    function emit_assign(e, string typeright, string rreg)
    {
        string obj = self.left.emit_get(e);
        string ident = self.right.getidentifier();
        string value;
        if (typeright == REGvar) {
            // Special case temporarily
            if (rreg == NULL) {
                rreg = self.tempreg(REGvar);
                e.emitnull(rreg);
            }
            value = rreg;
        }
        else {
            value = self.tempreg(REGvar);
            e.emitbox(value, rreg);
        }
        e.say("setattribute ", obj, ", '", ident, "', ", value);
    }
    function emit_assign_get(e, expr)
    {
        string obj = self.left.emit_get(e);
        string ident = self.right.getidentifier();
        string value = self.tempreg(REGvar);
        if (expr.isnull())
            e.emitnull(value);
        else {
            string rreg = expr.emit_get(e);
            if (expr.checkresult() != REGvar)
                e.emitbox(value, rreg);
            else
                value = rreg;
        }
        e.say("setattribute ", obj, ", '", ident, "', ", value);
        return value;
    }
}

// Member derefrence via a var or string expresion.
// Used only for method calls.
class MemberRefExpr : MemberExprBase
{
    var right;
    function MemberRefExpr(owner, start, left, right)
    {
        self.MemberExprBase(owner, start, left);
        self.right = right;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.left = self.left.optimize();
        self.right = self.right.optimize();
        return self;
    }
    function emit(e, result)
    {
        SyntaxError('Member reference can be used only for method calls',
            self.start);
    }
}

//*********************************************

class IndexExpr : Expr, SimpleArgList
{
    var left;
    var regleft;
    var argregs;

    function IndexExpr(tk, owner, start, subexp)
    {
        self.initexpr(owner, start);
        self.left = subexp;
        self.parseargs(tk, owner, ']');
    }
    function checkresult()
    {
        if (self.left.checkresult() == REGstring)
            return REGstring;
        else
            return REGvar;
    }
    function optimize()
    {
        var left = self.left.optimize();
        self.left = left;
        self.optimizeargs();

        // Optimize case of string constant indexed with int constant
        // evaluating it at compile time.
        if (left.isstringliteral() && self.numargs() == 1) {
            var arg = self.getarg(0);
            if (arg.isintegerliteral()) {
                int ival = arg.getIntegerValue();
                string sval = left.get_value();
                var t = new TokenQuoted(self.start.file, self.start.line,
                        substr(sval, ival, 1));
                return new StringLiteral(self.owner, t);
            }
        }
        return self;
    }
    function emit_prep(e)
    {
        var regleft = self.regleft;
        var argregs = self.argregs;
        if (regleft != null || argregs != null)
            InternalError('wrong call to IndexExpr.emit_args', self.start);
        if (self.left.isidentifier())
            regleft = self.left.getIdentifier();
        else
            regleft = self.left.emit_get(e);
        self.regleft = regleft;
        argregs = self.getargvalues(e);
        self.argregs = argregs;
    }
    function emit_aux(e)
    {
        var regleft = self.regleft;
        var argregs = self.argregs;
        if (regleft == null || argregs == null)
            InternalError('wrong call to IndexExpr.emit_aux', self.start);
        e.print(self.regleft, '[');
        e.print(join('; ', self.argregs));
        e.print(']');
    }
    function emit(e, result)
    {
        self.emit_prep(e);
        string type = self.checkresult();
        if (type == REGstring) {
            var argregs = self.argregs;
            int nargs = elements(self.argregs);
            if (nargs != 1)
               SyntaxError('Bad string index', self.start);
            if (result == '')
                result = self.tempreg(REGstring);
            e.say('substr ', result, ', ', self.regleft, ', ', argregs[0], ', ', 1);
        }
        else {
            self.annotate(e);
            e.print(result, ' = ');
            self.emit_aux(e);
            e.say('');
        }
    }
    function emit_assign(e, string typeright, string rreg)
    {
        self.emit_prep(e);
        self.annotate(e);
        self.emit_aux(e);
        e.say(' = ', rreg);
    }
    function emit_assign_get(e, expr)
    {
        self.emit_prep(e);
        string rreg;
        if (expr.isnull()) {
            rreg = self.tempreg(REGvar);
            e.emitnull(rreg);
        }
        else
            rreg = expr.emit_get(e);
        self.annotate(e);
        self.emit_aux(e);
        e.say(' = ', rreg);
        return rreg;
    }
}

//*********************************************

class ArrayExpr : Expr
{
    var values;

    function ArrayExpr(tk, owner, start)
    {
        self.initexpr(owner, start);
        self.values = [];
        var t = tk.get();
        if (! t.isop(']')) {
            tk.unget(t);
            do {
                var item = parseExpr(tk, owner);
                push(self.values, item);
            } while ((t= tk.get()).isop(','));
            if (!t.isop(']'))
                Expected("']' or ','", t);
        }
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        optimize_array(self.values);
        return self;
    }
    function emit(e, result)
    {
        if (result != '') {
            string value = self.emit_get(e);
            e.emitset(result, value);
        }
        else {
            // No need to create the container, but the
            // initializers may have secondary effects,
            // so they should be evaluated.
            self.emit_init(e, '');
        }
    }
    function emit_get(e)
    {
        string container = self.tempreg(REGvar);
        self.emit_init(e, container);
        return container;
    }
    function emit_init(e, string container)
    {
        self.annotate(e);
        string itemreg;
        string it_p;
        if (container != '') {
            e.say('root_new ', container, ", ['parrot';'ResizablePMCArray']");
            it_p = self.tempreg(REGvar);
        }
        for (var item in self.values) {
            string type = item.checkresult();
            switch (type) {
            case REGint: case REGfloat: case REGstring:
                string aux = item.emit_get(e);
                if (container != '') {
                    e.emitbox(it_p, aux);
                    itemreg = it_p;
                }
                break;
            default:
                if (item.isnull()) {
                    if (container != '') {
                        itemreg = self.tempreg(REGvar);
                        e.emitnull(itemreg);
                    }
                }
                else
                    itemreg = item.emit_get(e);
            }
            if (container != '') {
                self.annotate(e);
                e.say('push ', container, ", ", itemreg);
            }
        }
    }
}

//*********************************************

class HashExpr : Expr
{
    var keys;
    var values;

    function HashExpr(tk, owner, start)
    {
        self.initexpr(owner, start);
        var t = tk.get();
        var keys = [];
        var values = [];
        if (!t.isop('}')) {
            tk.unget(t);
            do {
                var key = parseExpr(tk, owner);
                ExpectOp(':', tk);
                var value = parseExpr(tk, owner);
                push(keys, key);
                push(values, value);

            } while ((t = tk.get()).isop(','));
            if (! t.isop('}'))
                Expected("',' or '}'", t);
        }
        self.keys = keys;
        self.values = values;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        optimize_array(self.keys);
        optimize_array(self.values);
        return self;
    }
    function emit(e, result)
    {
        self.annotate(e);

        // In void context there is no need to create the container,
        // but the keys and values may have secondary effects,
        // so they should ve evaluated.
        if (result != '')
            e.say('root_new ', result, ", ['parrot';'Hash']");

        var keys = self.keys;
        var values = self.values;
        int n = keys;
        for (int i = 0; i < n; ++i) {
            var key = keys[i];
            string item;
            if (key.isidentifier()) {
                string id = key.getName();
                item = self.tempreg(REGvar);
                e.say('get_hll_global ', item, ", '", id, "'");
            }
            else
                item = key.emit_get(e);

            var value = values[i];
            string itemreg;
            if (value.isnull()) {
                if (result != '') {
                    itemreg = self.tempreg(REGvar);
                    e.emitnull(itemreg);
                }
            }
            else if (value.isidentifier()) {
                string s = value.checkIdentifier();
                if (s != null && s != '')
                    itemreg = s;
                else {
                    string id = value.getName();
                    if (self.owner.getvar(id) == null) {
                        itemreg = self.tempreg(REGvar);
                        e.say('get_hll_global ', itemreg, ", '", id, "'");
                    }
                    else
                        itemreg = value.emit_get(e);
                }
            }
            else
                itemreg = value.emit_get(e);
            if (result != '')
                e.say(result, '[', item, '] = ', itemreg);
        }
    }
    function emit_get(e)
    {
        string container = self.tempreg(REGvar);
        self.emit(e, container);
        return container;
    }
}

//**********************************************************************

class NewBaseExpr : Expr
{
    var initializer;

    function checkresult() { return REGvar; }
    function parseinitializer(tk)
    {
        // Called with the tokenizer pointing right after the
        // opening parenthesis
        var owner = self.owner;
        var t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            var initializer = [];
            do {
                var auxinit = parseExpr(tk, owner);
                push(initializer, auxinit);
            } while ((t = tk.get()).isop(','));
            self.initializer = initializer;
            RequireOp(')', t);
        }
    }
    function optimize()
    {
        var initializer = self.initializer;
        if (initializer != null)
            optimize_array(initializer);
        return self;
    }
}

//**********************************************************************

class NewExpr : NewBaseExpr
{
    var value;

    function NewExpr(var tk, var owner, var start, var firstvalue)
    {
        self.initexpr(owner, start);

        if (! (firstvalue.isstring() || firstvalue.isidentifier()))
            SyntaxError("Unimplemented", firstvalue);
        self.value = firstvalue;
        var t = tk.get();

        if (t.isop('('))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function optimize()
    {
        var value = self.value;
        if ((value instanceof Token) && value.isidentifier()) {
            // The identifier can be a string constant, check for that case
            // and obtain the string value.
            var name = value.getidentifier();
            var desc = self.owner.getvar(name);
            if (desc != null && desc.isconst()) {
                if (desc.getid() == null) {
                    value = desc.getvalue();
                    if (! (value instanceof StringLiteral))
                        SyntaxError('Constant value must evaluate to a string', value);
                    self.value = value.strval;
                }
                else
                    SyntaxError('*Constant value must evaluate to a string', value);
            }
        }

        var initializer = self.initializer;
        if (initializer != null)
            optimize_array(self.initializer);
        return self;
    }
    function emit(e, result, int is_init[optional])
    {
        self.annotate(e);

        var initializer = self.initializer;
        int numinits = initializer == null ? 0 : elements(initializer);

        const int BYNAME = 0, BYIDENT = 1;
        int type = self.value.isstring() ? BYNAME : 
                self.value.isidentifier() ? BYIDENT : -1;

        string reginit = '';
        string regnew = result;
        string constructor;
        switch (numinits) {
          case 0:
            break;
          case 1:
            if (type == BYIDENT) {
                if (! is_init)
                    regnew = self.tempreg(REGvar);
            }
            else {
                var initval = initializer[0];
                reginit = initval.emit_get(e);
                reginit = ', ' + reginit;
            }
            break;
          default:
            if (type != BYIDENT)
                SyntaxError('Multiple init arguments not allowed here', self.start);
            if (! is_init)
                regnew = self.tempreg(REGvar);
        }

        switch (type) {
          case BYNAME:
            // By name, usually a pmc.
            string name = self.value.rawstring();
            var aux = get_class(name);
            if (aux == null && self.dowarnings())
                Warn("Can't locate class " + name + " at compile time", self.value);

            // Avoid using root_new here for a now.
            //e.say('root_new ', regnew, ", ['parrot'; ", self.value, " ]", reginit);
            e.say('new ', regnew, ", [ ", self.value, " ]", reginit);
            if (numinits > 1) {
                e.say(regnew, ".'", self.value, "'()");
            }
            break;
          case BYIDENT:
            var id = self.owner.getvar(self.value);
            if (id == null) {
                //say('new with no var');
                var cl = self.owner.checkclass(self.value);
                if (cl != null) {
                    e.say('new ', regnew, ", ", cl.getclasskey(), reginit);
                }
                else {
                    if (self.dowarnings())
                        Warn('Checking: new unknown type');
                    e.say('new ', regnew, ", ['", self.value, "']", reginit);
                }
                constructor = self.value;
            }
            else {
                //say('new with var');
                e.say('new ', regnew, ", ", id.getreg(), "", reginit);
            }
            break;
          default:
            InternalError('Unexpected type in new');
        }
        if (numinits > 1 || (numinits > 0 && type == BYIDENT)) {
            string argregs[];
            for (var arg in initializer) {
                string reg = arg.emit_get(e);
                push(argregs, reg);
            }
            e.print(regnew, ".'", constructor, "'(");
            e.print(join(", ", argregs));
            e.say(")");
            if (! is_init)
                e.emitset(result, regnew);
        }
    }
    function emit_init(e, result)
    {
        return self.emit(e, result, true);
    }
}

//**********************************************************************

class NewIndexedExpr : NewBaseExpr
{
    var nskey;

    function NewIndexedExpr(var tk, var owner, var start)
    {
        self.initexpr(owner, start);
        self.owner = owner;
        var nskey = new ClassSpecifierParrotKey(tk, owner, start);
        self.nskey = nskey;
        var t = tk.get();
        if (t.isop('('))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function emit(e, result)
    {
        string reginit;
        var init = self.initializer;
        int numinits = init == null ? 0 : elements(init);
        switch (numinits) {
          case 0:
            break;
          case 1:
            var initval = init[0];
            reginit = initval.emit_get(e);
            break;
          default:
            SyntaxError('Multiple init arguments not allowed here', self.start);
        }
        var nskey = self.nskey;
        if (nskey.hasHLL())
            e.print("root_");
        e.print("new ", result, ", ");
        nskey.emit(e, null);
        if (reginit != null)
            e.print(', ', reginit);
        e.say();
    }
}

//**********************************************************************

class NewQualifiedExpr : NewBaseExpr
{
    var nskey;

    function NewQualifiedExpr(var tk, var owner, var start)
    {
        self.initexpr(owner, start);
        self.owner = owner;
        var nskey = new ClassSpecifierId(tk, owner, start);
        self.nskey = nskey;
        var t = tk.get();
        if (t.isop('('))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function emit(e, result)
    {
        string reginit;
        var init = self.initializer;

        int numinits = init == null ? 0 : elements(init);
        string regnew = result;
        if (numinits > 0)
            regnew = self.tempreg(REGvar);
        var nskey = self.nskey;
        e.print("new ", regnew, ", ");
        nskey.emit(e, self.owner);
        e.say();

        if (numinits > 0) {
            string argregs[];
            for (var arg in init) {
                string reg = arg.emit_get(e);
                push(argregs, reg);
            }
            string constructor = nskey.last();
            e.print(regnew, ".'", constructor, "'(");
            e.print(join(", ", argregs));
            e.say(")");
            e.emitset(result, regnew);
        }
    }
}

//**********************************************************************

function parseNew(var tk, var owner, var start)
{
    var t = tk.get();

    if (t.isop('(')) {
        // Not a new operator, but a call to a function called new.
        return new CallExpr(tk, owner, start,
                new StringLiteral(owner, start));
    }
    else if (t.isop('[')) {
        // Class specifier is a key
        return new NewIndexedExpr(tk, owner, start);
    }
    else if (t.isidentifier()) {
        // Special case here. It can be an id, a qualified id or
        // a const string
        var t2 = tk.get();
        tk.unget(t2);
        if (t2.isop('.')) {
            // Qualified id
            return new NewQualifiedExpr(tk, owner, t);
        }
        else {
            // Let the default case handle it
            return new NewExpr(tk, owner, start, t);
        }
    }
    else {
        // Remainig cases
        return new NewExpr(tk, owner, start, t);
    }
}

//**********************************************************************

class OpInstanceOfExpr : Expr
{
    var lexpr;
    var checked;

    function OpInstanceOfExpr(owner, start, lexpr, tk)
    {
        self.initexpr(owner, start);
        self.lexpr = lexpr;
        self.checked= tk.get();
    }
    function checkresult() { return REGint; }
    function emit(e, result)
    {
        var checked = self.checked;
        string checkedval;
        if (checked.isidentifier()) {
           checkedval = checked.getidentifier();
           checkedval = "'" + checkedval + "'";
        }
        else
            checkedval = checked;
        string r = self.lexpr.emit_get(e);
        self.annotate(e);
        e.say('isa ', result, ', ', r, ', ', checkedval);
    }
}

//*********************************************

class OpConditionalExpr : Expr
{
    // TODO
    // Allow true and false branches to have different types,
    // or give an error in that case.

    var condition;
    var etrue;
    var efalse;

    function set(owner, start, condition, etrue, efalse)
    {
        self.initexpr(owner, start);
        self.condition = new Condition().set(condition);
        self.etrue = etrue;
        self.efalse = efalse;
        return self;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        switch (self.condition.getvalue()) {
        case CONDistrue:
            return self.etrue.optimize();
        case CONDisfalse:
            return self.efalse.optimize();
        default:
            self.etrue = self.etrue.optimize();
            self.efalse = self.efalse.optimize();
            return self;
        }
    }
    function checkresult()
    { 
        return self.etrue.checkresult();
    }
    function emit(e, result)
    {
        string cond_end = self.owner.genlabel();
        string cond_false = self.owner.genlabel();
        self.condition.emit_else(e, cond_false);
        self.etrue.emit(e, result);
        e.emitgoto(cond_end);
        e.emitlabel(cond_false);
        self.efalse.emit(e, result);
        e.emitlabel(cond_end);
    }
}

//*********************************************
//           Expressions parser
//*********************************************

const int
    Code_none          =  0,
    Code_paren         =  1,
    Code_bracket       =  2,
    Code_dot           =  3,
    Code_assign        =  4,
    Code_assign_to     =  5,
    Code_add_assign    =  6,
    Code_add           =  7,
    Code_minus         =  8,
    Code_inc           =  9,
    Code_dec           = 10,
    Code_not           = 11,
    Code_equal         = 12,
    Code_not_equal     = 13,
    Code_less          = 14,
    Code_less_equal    = 15,
    Code_greater       = 16,
    Code_greater_equal = 17,
    Code_sub_assign    = 18,
    Code_mul           = 19,
    Code_div           = 20,
    Code_mod           = 21,
    Code_cmod          = 22,
    Code_mul_assign    = 23,
    Code_div_assign    = 24,
    Code_same          = 25,
    Code_not_same      = 26,
    Code_instanceof    = 27,
    Code_shiftleft     = 28,
    Code_shiftright    = 29,
    Code_mod_assign    = 30,
    Code_delete        = 31,
    Code_exists        = 32;

function getOpCode_2(t)
{
    switch (t.checkop()) {
    case '(': return Code_paren;
    case '[': return Code_bracket;
    case '.': return Code_dot;
    default:  return Code_none;
    }
}

function getOpCode_4(t)
{
    switch (t.checkop()) {
    case '-':  return Code_minus;
    case '!':  return Code_not;
    case '++': return Code_inc;
    case '--': return Code_dec;
    default:
        if (t.iskeyword('delete')) return Code_delete;
        else if (t.iskeyword('exists')) return Code_exists;
        else return Code_none;
    }
}

function getOpCode_5(t)
{
    switch (t.checkop()) {
    case '*':  return Code_mul;
    case '/':  return Code_div;
    case '%':  return Code_mod;
    case '%%': return Code_cmod;
    default:   return Code_none;
    }
}

function getOpCode_7(t)
{
    switch (t.checkop()) {
    case '<<':  return Code_shiftleft;
    case '>>':  return Code_shiftright;
    default:   return Code_none;
    }
}

function getOpCode_8(t)
{
    switch (t.checkop()) {
    case '<':  return Code_less;
    case '>':  return Code_greater;
    case '<=': return Code_less_equal;
    case '>=': return Code_greater_equal;
    default:
        if (t.iskeyword('instanceof')) return Code_instanceof;
        else return Code_none;
    }
}

function getOpCode_9(t)
{
    switch (t.checkop()) {
    case '==':  return Code_equal;
    case '!=':  return Code_not_equal;
    case '===':  return Code_same;
    case '!==':  return Code_not_same;
    default:   return Code_none;
    }
}

function getOpCode_16(t)
{
    switch (t.checkop()) {
    case '=':  return Code_assign;
    case '=:': return Code_assign_to;
    case '+=': return Code_add_assign;
    case '-=': return Code_sub_assign;
    case '*=': return Code_mul_assign;
    case '/=': return Code_div_assign;
    case '%=': return Code_mod_assign;
    default:   return Code_none;
    }
}

function parseExpr_0(tk, owner)
{
    using static parseExpr;

    var t= tk.get();
    var expr;
    if (t.isop('(')) {
        expr = parseExpr(tk, owner);
        ExpectOp(')', tk);
        return expr;
    }
    if (t.isop('['))
        return new ArrayExpr(tk, owner, t);
    if (t.isop('{'))
        return new HashExpr(tk, owner, t);
    if (t.isstring())
        return new StringLiteral(owner, t);
    if (t.isint())
        return new IntegerLiteral(owner, t);
    if (t.isfloat())
        return new FloatLiteral(owner, t);
    switch (t.checkkeyword()) {
      case 'new':
        return parseNew(tk, owner, t);
      case 'function':
        return new FunctionExpr(tk, owner, t);
      case 'class':
        return new OpClassExpr(tk, owner, t);
    }
    if (t.isidentifier())
        return new IdentifierExpr(owner, t);
    SyntaxError('Expression expected', t);
}

function parseExpr_2(tk, owner)
{
    using static parseExpr_0;
    using static getOpCode_2;

    var subexp = parseExpr_0(tk, owner);
    var t;
    var start;
    int code;
    while ((code = getOpCode_2(t = tk.get())) != Code_none ) {
        switch(code) {
        case Code_paren:
            subexp = new CallExpr(tk, owner, t, subexp);
            break;
        case Code_bracket:
            subexp = new IndexExpr(tk, owner, t, subexp);
            break;
        case Code_dot:
            start = t;
            t = tk.get();
            if (t.isop('*')) {
                var right = parseExpr_0(tk, owner);
                subexp = new MemberRefExpr(owner, t, subexp, right);
            }
            else
                subexp = new MemberExpr(owner, start, subexp, t);
            break;
        default:
            InternalError('Unexpected code in parseExpr_2');
        }
    }
    tk.unget(t);
    return subexp;
}

function parseExpr_3(tk, owner)
{
    using static parseExpr_2;

    var subexp = parseExpr_2(tk, owner);
    var t = tk.get();
    if (t.isop('++'))
        return new OpPostIncExpr().set(owner, t, subexp);
    else if (t.isop('--'))
        return new OpPostDecExpr().set(owner, t, subexp);
    else
    {
        tk.unget(t);
        return subexp;
    }
}

function parseExpr_4(tk, owner)
{
    using static parseExpr_4;
    using static parseExpr_3;
    using static getOpCode_4;

    var t = tk.get();
    int code = getOpCode_4(t);
    var subexpr;
    if  (code != Code_none) {
        subexpr = parseExpr_4(tk, owner);
        var oper;
        switch (code) {
        case Code_minus:
            oper = new OpUnaryMinusExpr();
            break;
        case Code_not:
            oper = new OpNotExpr();
            break;
        case Code_inc:
            oper = new OpPreIncExpr();
            break;
        case Code_dec:
            oper = new OpPreDecExpr();
            break;
        case Code_delete:
            oper = new OpDeleteExpr();
            break;
        case Code_exists:
            oper = new OpExistsExpr();
            break;
        default:
            InternalError('Invalid code in parseExpr_4', t);
        }
        subexpr = oper.set(owner, t, subexpr);
    }
    else {
        tk.unget(t);
        subexpr =  parseExpr_3(tk, owner);
    }
    return subexpr;
}

function parseExpr_5(tk, owner)
{
    using static parseExpr_4;
    using static getOpCode_5;

    var lexpr= parseExpr_4(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_5(t= tk.get())) != Code_none) {
        var rexpr= parseExpr_4(tk, owner);
        var aux;
        switch (code) {
        case Code_mul:
            aux = new OpMulExpr();
            break;
        case Code_div:
            aux = new OpDivExpr();
            break;
        case Code_mod:
            aux = new OpModExpr();
            break;
        case Code_cmod:
            aux = new OpCModExpr();
            break;
        default:
            InternalError('Invalid code in parseExpr_5', t);
        }
        aux.set(owner, t, lexpr, rexpr);
        lexpr = aux;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_6(tk, owner)
{
    using static parseExpr_5;

    var lexpr= parseExpr_5(tk, owner);
    var t;
    while ((t= tk.get()).isop('+') || t.isop('-')) {
        var rexpr= parseExpr_5(tk, owner);
        var expr;
        if (t.isop('+'))
            expr= new OpAddExpr().set(owner, t, lexpr, rexpr);
        else
            expr= new OpSubExpr().set(owner, t, lexpr, rexpr);
        lexpr= expr;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_7(tk, owner)
{
    using static parseExpr_6;

    var lexpr = parseExpr_6(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_7(t= tk.get())) != Code_none) {
        switch (code) {
          case Code_shiftleft:
            rexpr = parseExpr_6(tk, owner);
            lexpr= new OpShiftleftExpr().set(owner, t, lexpr, rexpr);
            break;
          case Code_shiftright:
            rexpr = parseExpr_6(tk, owner);
            lexpr= new OpShiftrightExpr().set(owner, t, lexpr, rexpr);
            break;
        default:
            InternalError('Invalid code in parseExpr_7', t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_8(tk, owner)
{
    using static parseExpr_7;
    using static getOpCode_8;

    var lexpr = parseExpr_7(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_8(t= tk.get())) != Code_none) {
        switch (code) {
          case Code_less:
            rexpr = parseExpr_7(tk, owner);
            lexpr = new OpLessExpr().set(owner, t, lexpr, rexpr);
            break;
          case Code_greater:
            rexpr = parseExpr_7(tk, owner);
            lexpr = new OpGreaterExpr().set(owner, t, lexpr, rexpr);
            break;
          case Code_less_equal:
            rexpr = parseExpr_7(tk, owner);
            lexpr = new OpLessEqualExpr().set(owner, t, lexpr, rexpr);
            break;
          case Code_greater_equal:
            rexpr = parseExpr_7(tk, owner);
            lexpr = new OpGreaterEqualExpr().set(owner, t, lexpr, rexpr);
            break;
          case Code_instanceof:
            lexpr = new OpInstanceOfExpr(owner, t, lexpr, tk);
            break;
          default:
            InternalError('Invalid code in parseExpr_9', t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_9(tk, owner)
{
    using static parseExpr_8;
    using static getOpCode_9;

    var lexpr = parseExpr_8(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_9(t= tk.get())) != Code_none) {
        switch (code) {
          case Code_equal:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpEqualExpr().set(owner, t, lexpr, rexpr);
            break;
          case Code_not_equal:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpNotEqualExpr().set(owner, t, lexpr, rexpr);
            break;
          case Code_same:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpSameExpr(true, owner, t, lexpr, rexpr);
            break;
          case Code_not_same:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpSameExpr(false, owner, t, lexpr, rexpr);
            break;
          default:
            InternalError('Invalid code in parseExpr_8', t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_10(tk, owner)
{
    using static parseExpr_9;

    var lexpr = parseExpr_9(tk, owner);
    var t;
    while ((t = tk.get()).isop('&')) {
        var rexpr = parseExpr_9(tk, owner);
        lexpr = new OpBinAndExpr().set(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_11(tk, owner)
{
    using static parseExpr_10;

    var lexpr = parseExpr_10(tk, owner);
    var t;
    while ((t = tk.get()).isop('^')) {
        var rexpr = parseExpr_10(tk, owner);
        lexpr = new OpBinXorExpr().set(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_12(tk, owner)
{
    using static parseExpr_11;

    var lexpr = parseExpr_11(tk, owner);
    var t;
    while ((t = tk.get()).isop('|')) {
        var rexpr = parseExpr_11(tk, owner);
        lexpr = new OpBinOrExpr().set(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_13(tk, owner)
{
    using static parseExpr_12;

    var lexpr = parseExpr_12(tk, owner);
    var t;
    while ((t= tk.get()).isop('&&')) {
        var rexpr = parseExpr_12(tk, owner);
        lexpr = new OpBoolAndExpr().set(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_14(tk, owner)
{
    using static parseExpr_13;

    var lexpr = parseExpr_13(tk, owner);
    var t;
    while ((t= tk.get()).isop('||')) {
        var rexpr = parseExpr_12(tk, owner);
        lexpr = new OpBoolOrExpr().set(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_15(tk, owner)
{
    using static parseExpr_16;
    using static parseExpr_14;

    var econd = parseExpr_14(tk, owner);
    var t = tk.get();
    if (t.isop('?')) {
        var etrue = parseExpr_16(tk, owner);
        ExpectOp(':', tk);
        var efalse = parseExpr_16(tk, owner);
        return new OpConditionalExpr().set(owner, t, econd, etrue, efalse);
    }
    else {
        tk.unget(t);
        return econd;
    }
}

function parseExpr_16(tk, owner)
{
    using static parseExpr_16;
    using static parseExpr_15;
    using static getOpCode_16;

    var lexpr = parseExpr_15(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_16(t = tk.get())) != Code_none ) {
        var rexpr = parseExpr_16(tk, owner);
        var expr;
        switch (code) {
        case Code_assign:
            expr = new OpAssignExpr();
            break;
        case Code_assign_to:
            expr = new OpAssignToExpr();
            break;
        case Code_add_assign:
            expr = new OpAddToExpr();
            break;
        case Code_sub_assign:
            expr = new OpSubToExpr();
            break;
        case Code_mul_assign:
            expr = new OpMulToExpr();
            break;
        case Code_div_assign:
            expr = new OpDivToExpr();
            break;
        case Code_mod_assign:
            expr = new OpModToExpr();
            break;
        default:
            InternalError('Unexpected code in parseExpr_16', t);
        }
        expr.set(owner, t, lexpr, rexpr);
        lexpr = expr;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr(tk, owner)
{
    using static parseExpr_16;

    return parseExpr_16(tk, owner);
}

//*********************************************
//         Breakable and Continuable
//*********************************************

// Abstract base class for statments that can contain break
// and continue statments. Continuable is always breakable.

class Breakable
{
    var brlabel;

    function genbreaklabel()
    {
        if (self.brlabel != null)
            InternalError('attempt to generate break label twice');
        string label = self.genlabel();
        self.brlabel = label;
        return label;
    }
    function getbreaklabel(pos)
    {
        var label = self.brlabel;
        if (label == null)
            InternalError('attempt to get break label before creating it');
        return label;
    }
}

class Continuable : Breakable
{
    var cntlabel;

    function gencontinuelabel()
    {
        if (self.cntlabel != null)
            InternalError('attempt to generate continue label twice');
        string label = self.genlabel();
        self.cntlabel = label;
        return label;
    }
    function getcontinuelabel(pos)
    {
        var label = self.cntlabel;
        if (label == null)
            InternalError('attempt to get continue label before creating it');
        return label;
    }
}

//*********************************************
//            ReturnYieldStatement
//*********************************************

// Return and Yield statements and a base class
// that does almost all.

class ReturnYieldStatement : Statement
{
    var values;

    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            self.values = new ArgumentList(owner, start, tk, ";");
        }
    }
    function optimize()
    {
        var values = self.values;
        if (values != null)
            values = values.optimize();
        return self;
    }
    function emit(e)
    {
        //var args = [];
        var values = self.values;
        int n = values == null ? 0 : int(values.numargs());

        // Experimental tailcall optimization
        if (n == 1 && (self instanceof ReturnStatement)) {
            var func = values.getfreearg(0);
            if (func.cantailcall()) {
                self.annotate(e);
                return func.emit(e, '.tailcall');
            }
        }

        if (n > 0)
            values.getargvalues(e);

        self.annotate(e);
        self.emitret(e);
        if (n > 0)
            values.emitargs(e);
        e.say(')');
    }
}

class ReturnStatement : ReturnYieldStatement
{
    function ReturnStatement(start, tk, owner)
    {
        self.parse(start, tk, owner);
    }
    function emitret(e)
    {
        e.print('.return(');
    }
}

class YieldStatement : ReturnYieldStatement
{
    function YieldStatement(start, tk, owner)
    {
        self.parse(start, tk, owner);
    }
    function emitret(e)
    {
        e.print('.yield(');
    }
}

//*********************************************
//            LabelStatement
//*********************************************

class LabelStatement : Statement
{
    var name;
    var value;
    function LabelStatement(n, owner)
    {
        self.initstatement(n, owner);
        self.name= n;
        string value= self.owner.createlabel(n);
        self.value= value;
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        string name = self.name;
        string comment = 'label ' + name;
        e.emitlabel(self.value, comment);
    }
}

//*********************************************
//            Reflabel
//*********************************************

class Reflabel
{
    var owner;
    var label;

    function Reflabel(owner, string label)
    {
        self.owner = owner;
        self.label = label;
    }
    function optimize() { return self; }
    function emit_get(e)
    {
        string label = self.label;
        string value = self.owner.getlabel(label);
        return value;
    }
}

//*********************************************
//            GotoStatement
//*********************************************

class GotoStatement : Statement
{
    var label;

    function GotoStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        RequireIdentifier(t);
        self.label = t;
        ExpectOp(';', tk);
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        string label = self.label;
        string value = self.getlabel(label);
        e.emitgoto(value, 'goto ' + label);
    }
}

//*********************************************
//          ConditionalStatement
//*********************************************

class ConditionalStatement : Statement, Condition
{
    function parseconditionshort(tk)
    {
        self.set(parseExpr(tk, self));
    }
    function parsecondition(tk)
    {
        ExpectOp('(', tk);
        self.set(parseExpr(tk, self));
        ExpectOp(')', tk);
    }
}

//*********************************************
//            IfStatement
//*********************************************

class IfStatement : ConditionalStatement
{
    var truebranch;
    var falsebranch;
    function IfStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.parsecondition(tk);
        self.truebranch = parseStatement(tk, self);
        var t = tk.get();
        if (t.iskeyword("else"))
            self.falsebranch = parseStatement(tk, self);
        else {
            self.falsebranch = new EmptyStatement();
            tk.unget(t);
        }
    }
    function optimize()
    {
        self.optimize_condition();
        int checkvalue = self.getvalue();
        self.truebranch = self.truebranch.optimize();
        self.falsebranch = self.falsebranch.optimize();
        switch (checkvalue) {
        case CONDistrue:
            return self.truebranch;
        case CONDisfalse:
            return self.falsebranch;
        }
        return self;
    }
    function emit(e)
    {
        var truebranch = self.truebranch;
        var falsebranch = self.falsebranch;
        int t_empty = truebranch.isempty();
        int f_empty = falsebranch.isempty();
        string elselabel = '';
        if (! f_empty)
            elselabel = self.genlabel();
        string endlabel = self.genlabel();
        string cond_false = f_empty ? endlabel : elselabel;
        self.annotate(e);
        self.emit_else(e, cond_false);
        truebranch.emit(e);

        if (! f_empty) {
            e.emitgoto(endlabel);
            e.emitlabel(elselabel, 'else');
            falsebranch.emit(e);
        }
        e.emitlabel(endlabel, 'endif');
    }
}

//*********************************************
//            LoopStatement
//*********************************************

class LoopStatement : Continuable
{
    var body;
    function parsebody(tk)
    {
        self.body = parseStatement(tk, self);
    }
    function emit_infinite(e)
    {
        string breaklabel = self.genbreaklabel();
        string continuelabel = self.gencontinuelabel();

        self.annotate(e);
        e.emitlabel(continuelabel, 'Infinite loop');
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, 'Infinite loop end');
    }
}

//*********************************************
//            WhileStatement
//*********************************************

class WhileStatement : LoopStatement, ConditionalStatement
{
    function WhileStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.parsecondition(tk);
        self.parsebody(tk);
    }
    function optimize()
    {
        self.optimize_condition();
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        switch (self.getvalue()) {
        case CONDistrue:
            self.emit_infinite(e);
            break;
        case CONDisfalse:
            e.comment('while(false) optimized out');
            break;
        default:
            string breaklabel = self.genbreaklabel();
            string continuelabel = self.gencontinuelabel();

            self.annotate(e);
            e.emitlabel(continuelabel, 'while');
            self.emit_else(e, breaklabel);
            self.body.emit(e);
            e.emitgoto(continuelabel);
            e.emitlabel(breaklabel, 'endwhile');
        }
    }
}

//*********************************************
//            DoStatement
//*********************************************

class DoStatement : LoopStatement, ConditionalStatement
{
    function DoStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.parsebody(tk);
        ExpectKeyword('while', tk);
        self.parsecondition(tk);
    }
    function optimize()
    {
        self.optimize_condition();
        var body = self.body.optimize();
        if (body.isempty() && self.getvalue() == CONDisfalse)
            return new EmptyStatement();
        self.body = body;
        return self;
    }
    function emit(e)
    {
        var body = self.body;
        int condvalue = self.getvalue();
        switch (condvalue) {
        case CONDistrue:
            self.emit_infinite(e);
            break;
        default:
            string looplabel = self.genlabel();
            string breaklabel = self.genbreaklabel();
            string continuelabel = self.gencontinuelabel();

            self.annotate(e);
            e.emitlabel(looplabel, 'do');

            body.emit(e);
            e.emitlabel(continuelabel, 'continue');
            if (condvalue != CONDisfalse)
                self.emit_if(e, looplabel, breaklabel);
            e.emitlabel(breaklabel, 'enddo');
        }
    }
}

//*********************************************
//            ContinueStatement
//*********************************************

class ContinueStatement : Statement
{
    function ContinueStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        ExpectOp(';', tk);
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        string label = self.getcontinuelabel(self.start);
        e.emitgoto(label, 'continue');
    }
}

//*********************************************
//            BreakStatement
//*********************************************

class BreakStatement : Statement
{
    function BreakStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        ExpectOp(';', tk);
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        string label = self.getbreaklabel(self.start);
        e.emitgoto(label, 'break');
    }
}

//*********************************************
//            SwitchStatement
//*********************************************

class SwitchStatement : Breakable, Statement
{
    var condition;
    var case_value;
    var case_st;
    var default_st;

    function SwitchStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        if (! t.isop('('))
            Expected("'(' in switch", t);
        self.condition = parseExpr(tk, self);
        t = tk.get();
        if (! t.isop(')'))
            Expected("')' in switch", t);
        t = tk.get();
        if (! t.isop('{'))
            Expected("'{' in switch", t);
        self.case_value = [];
        self.case_st = [];
        self.default_st = [];
        while ((t = tk.get()).iskeyword('case') || t.iskeyword('default')) {
            if (t.iskeyword('case')) {
                push(self.case_value, parseExpr(tk, self));
                t = tk.get();
                if (! t.isop(':'))
                    Expected("':' in case", t);
                var st = [];
                while (! ((t = tk.get()).isop('}') || t.iskeyword('case') || t.iskeyword('default'))) {
                    tk.unget(t);
                    push(st, parseStatement(tk, self));
                }
                push(self.case_st, st);
                tk.unget(t);
            }
            else {
                t = tk.get();
                if (! t.isop(':'))
                    Expected("':' in default", t);
                while (! ((t = tk.get()).isop('}') || t.iskeyword('case') || t.iskeyword('default'))) {
                    tk.unget(t);
                    push(self.default_st, parseStatement(tk, self));
                }
                tk.unget(t);
            }
        }
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        optimize_array(self.case_value);
        for (var casest in self.case_st)
            optimize_array(casest);
        optimize_array(self.default_st);
        return self;
    }
    function emit(e)
    {
        // Get case common type
        string type = '';
        for (var value in self.case_value) {
            string t = value.checkresult();
            if (t == REGfloat)
                SyntaxError("Invalid type in case", self.start);
            if (type == '')
                type = t;
            else if (type != t)
                type = REGvar;
        }
        // Evaluate condition
        string reg = self.tempreg(type);
        if (self.condition.checkresult() == type)
            self.condition.emit(e, reg);
        else {
            string regcond = self.condition.emit_get(e);
            e.emitset(reg, regcond);
        }

        // Prpeare labels and check values
        self.genbreaklabel();
        string defaultlabel = self.genlabel();
        string caselabel[];
        string regval = self.tempreg(type);
        for (var caseval in self.case_value) {
            string label = self.genlabel();
            push(caselabel, label);
            caseval.emit(e, regval);
            e.say('if ', reg, ' == ', regval, ' goto ', label);
        }
        e.emitgoto(defaultlabel);

        // Emit cases
        e.comment('switch');
        self.annotate(e);
        var case_st = self.case_st;
        int n = case_st;
        for (int i= 0; i < n; ++i) {
            string l = caselabel[i];
            e.emitlabel(l, 'case');
            var casest = case_st[i];
            for (var st in casest)
                st.emit(e);
        }
        // Emit default
        e.emitlabel(defaultlabel, 'default');
        for (var dst in self.default_st)
            dst.emit(e);

        e.emitlabel(self.getbreaklabel(self.start), 'switch end');
    }
}

//*********************************************
//            ForStatement
//*********************************************

class ForStatement : LoopStatement, BlockStatement, ConditionalStatement
{
    var initializer;
    var iteration;

    function ForStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            self.initializer = parseStatement(tk, self);
        }
        t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            self.parseconditionshort(tk);
            ExpectOp(';', tk);
        }
        t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            self.iteration = parseExpr(tk, self);
            ExpectOp(')', tk);
        }
        self.parsebody(tk);
    }
    function optimize()
    {
        if (self.initializer != null)
            self.initializer = self.initializer.optimize();
        if (self.condexpr != null)
            self.optimize_condition();
        if (self.iteration != null)
            self.iteration = self.iteration.optimize();
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        if (self.initializer == null &&
                self.condexpr == null &&
                self.iteration == null) {
            self.emit_infinite(e);
            return;
        }
        e.comment('for loop');
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        string condlabel = self.genlabel();
        if (self.initializer != null)
            self.initializer.emit(e);

        e.emitlabel(condlabel, 'for condition');
        if (self.condexpr != null)
            self.emit_else(e, breaklabel);

        self.body.emit(e);
        e.emitlabel(continuelabel, 'for iteration');
        if (self.iteration != null)
            string unused = self.iteration.emit_get(e);
        e.emitgoto(condlabel);

        e.emitlabel(breaklabel, 'for end');
    }
}

//*********************************************
//            ForeachStatement
//*********************************************

class ForeachStatement : LoopStatement, BlockStatement
{
    var deftype;
    var varname;
    var container;

    function ForeachStatement(start, tk, owner, name, string type)
    {
        self.initstatement(start, owner);
        string sname = name;
        if (type != '') {
            string deftype = typetoregcheck(type);
            self.createvar(sname, deftype);
            self.deftype = deftype;
        }
        self.varname = name;
        self.container = parseExpr(tk, self);
        ExpectOp(')', tk);
        self.parsebody(tk);
    }
    function optimize()
    {
        self.container = self.container.optimize();
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        string regcont;
        if (self.container.checkresult() == REGstring) {
            string value = self.container.emit_get(e);
            regcont = self.tempreg(REGvar);
            e.emitbox(regcont, value);
        }
        else
            regcont = self.container.emit_get(e);
        var itvar = self.getvar(self.varname);
        string iterator = self.createreg(REGvar);
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        e.say('iter ', iterator, ', ', regcont);
        e.emitset(iterator, '0');
        e.emitlabel(continuelabel, 'for iteration');
        e.emitunless(iterator, breaklabel);
        e.say('shift ', itvar.getreg(), ', ', iterator);
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, 'endfor');
    }
}

//*********************************************

function parseFor(t, tk, owner)
{
    ExpectOp('(', tk);
    var aux = tk.get();
    var in1 = tk.get();
    if (in1.iskeyword('in'))
        return new ForeachStatement(t, tk, owner, aux, '');
    else {
        var in2 = tk.get();
        if (in2.iskeyword('in'))
            return new ForeachStatement(t, tk, owner, in1, aux);
        tk.unget(in2);
        tk.unget(in1);
        tk.unget(aux);
    }
    return new ForStatement(t, tk, owner);
}

//*********************************************
//            ThrowStatement
//*********************************************

class ThrowStatement : Statement
{
    var excep;

    function ThrowStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.excep = parseExpr(tk, self);
    }
    function optimize()
    {
        self.excep = self.excep.optimize();
        return self;
    }
    function emit(e)
    {
        string reg = self.excep.emit_get(e);
        self.annotate(e);
        e.say('throw ', reg);
    }
}

//*********************************************
//            TryStatement
//*********************************************

class TryStatement : BlockStatement
{
    var stry;
    var modifiers;
    var exname;
    var scatch;

    function TryStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t = tk.get();
        if (t.isop('[')) {
            self.modifiers = new ModifierList(tk, self);
        }
        else
            tk.unget(t);

        self.stry = parseStatement(tk, self);
        t = tk.get();
        if (! t.iskeyword('catch'))
            ExpectedOp('catch', t);
        t = tk.get();
        if (! t.isop('('))
            Expected("'(' after 'catch'", t);
        t = tk.get();
        if (! t.isop(')')) {
            string exname = t.getidentifier();
            self.exname = t;
            self.createvar(exname, REGvar);
            t = tk.get();
            if (! t.isop(')'))
                Expected("')' in 'catch'", t);
        }
        self.scatch = parseStatement(tk, self);
    }
    function optimize()
    {
        if (self.modifiers != null)
            self.modifiers.optimize();
        self.stry = self.stry.optimize();
        self.scatch = self.scatch.optimize();
        return self;
    }
    function emit(e)
    {
        string reghandler = self.tempreg(REGvar);
        string labelhandler = self.genlabel();
        string labelpasthandler = self.genlabel();
        string exreg;
        if (self.exname != null) {
            var exname = self.getvar(self.exname);
            exreg = exname.getreg();
        }
        else
            exreg = self.tempreg(REGvar);

        self.annotate(e);
        e.comment('try: create handler');

        e.say('new ', reghandler, ", 'ExceptionHandler'");
        e.say('set_label ', reghandler, ', ', labelhandler);

        if (self.modifiers != null) {
            var modiflist = self.modifiers.getlist();
            for (var modif in modiflist) {
                string modifname = modif.getname();
                int nargs = modif.numargs();
                switch (modifname) {
                case 'min_severity':
                case 'max_severity':
                    if (nargs != 1)
                        SyntaxError('Wrong modifier args', self.start);
                    var arg = modif.getarg(0);
                    string argreg = arg.emit_get(e);
                    e.say(reghandler, ".'", modifname, "'(", argreg, ")");
                    break;
                case 'handle_types':
                case 'handle_types_except':
                    string argregs [];
                    for (int i= 0; i < nargs; ++i) {
                        var arg = modif.getarg(i);
                        push(argregs, arg.emit_get(e));
                    }
                    e.print(reghandler, ".'", modifname, "'(");
                    string sep = '';
                    for (string argreg in argregs) {
                        e.print(sep, argreg);
                        sep = ', ';
                    }
                    e.say(")");
                    break;
                default:
                    SyntaxError('Unexpected modifier in try', self.start);
                }
            }
        }

        e.say('push_eh ', reghandler);
        e.comment('try: begin');
        self.stry.emit(e);
        e.comment('try: end');
        e.say('pop_eh');

        self.annotate(e);
        e.emitgoto(labelpasthandler);

        e.comment('catch');
        e.emitlabel(labelhandler);
        e.say('.get_results(', exreg, ')');
        e.say('finalize ', exreg);
        e.say('pop_eh');
        self.scatch.emit(e);

        e.comment('catch end');
        e.emitlabel(labelpasthandler);
    }
}

//*********************************************
//            VarBaseStatement
//*********************************************

class VarBaseStatement : Statement
{
    var name;
    var reg;
    function initvarbase(start, owner, name, int flags[optional])
    {
        self.initstatement(start, owner);
        self.name = name;
        var vdata = self.createvar(name, REGvar, flags);
        self.reg = vdata.getreg();
    }
}

//*********************************************
//            DeclareStatement
//*********************************************

class DeclareStatement : Statement
{
    var name;
    var t_reg;
    var t_name;
    var t_array;
    var reg;
    var typearray;
    var size;
    var init;
    function parse(start, tk, owner)
    {
        self.initstatement(start, owner);
        var t= tk.get();
        RequireIdentifier(t);
        self.name= t;
        var vdata;
        string reg;

        t= tk.get();
        if (t.isop('[')) {
            // Array
            self.typearray = 1;
            vdata = self.createvar(self.name, REGvar);
            reg = vdata.getreg();
            t = tk.get();
            if (t.isop(']')) {
                // Variable length
                t= tk.get();
            }
            else {
                tk.unget(t);
                self.size = parseExpr(tk, self);
                ExpectOp(']', tk);
                t= tk.get();
            }
        }
        else {
            // Simple
            self.typearray = 0;
            vdata = self.createvar(self.name, self.t_reg);
            reg = vdata.getreg();
            if (t.isop('=')) {
                // Simple initializer
                self.init = parseExpr(tk, self);
                t= tk.get();
            }
        }

        self.reg= reg;
        if (t.isop('=')) {
            t = tk.get();
            if (! t.isop('['))
                Expected("array initializer", t);
            self.init = [];
            t = tk.get();
            if (! t.isop(']')) {
                tk.unget(t);
                do {
                    var item = parseExpr(tk, self);
                    push(self.init, item);
                } while ((t = tk.get()).isop(','));
                if (! t.isop(']'))
                    Expected("',' or ']'", t);
            }
            t = tk.get();
        }
        tk.unget(t);
    }
    function optimize()
    {
        var init = self.init;
        if (self.size != null)
            self.size = self.size.optimize();
        if (init != null) {
            if (self.typearray == 0)
                self.init = init.optimize();
            else
                optimize_array(init);
        }
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        string tname = self.t_name;
        string name = self.name;
        string reg = self.reg;
        string t_reg = self.t_reg;
        var init = self.init;
        e.comment(tname + ' ' + name + ': ' + reg);

        if (self.typearray == 0) {
            if (init == null || init.isnull())
                self.defaultinit(e);
            else {
                string itype = init.checkresult();
                if (itype == t_reg) {
                    if (itype == REGstring && (init instanceof ConcatString))
                        init.emit_concat_set(e, reg);
                    else
                        init.emit(e, reg);
                }
                else {
                    if (init instanceof IndexExpr) {
                        // Use the declared type for the indexing
                        init.emit(e, reg);
                    }
                    else {
                        string ireg;
                        if (itype == '')
                            ireg = init.emit_get(e);
                        else {
                            ireg = self.tempreg(itype);
                            init.emit(e, ireg);
                        }
                        if (t_reg == REGstring && itype == REGvar) {
                            string auxlabel = self.genlabel();
                            e.emitnull(reg);
                            e.emitif_null(ireg, auxlabel);
                            e.emitset(reg, ireg);
                            e.emitlabel(auxlabel);
                        }
                        else
                            e.emitset(reg, ireg);
                    }
                }
            }
        }
        else {
            var size = self.size;
            if (size != null) {
                // Fixed size array
                string regsize = size.emit_get(e);
                e.say('new ', reg, ", ['Fixed", self.t_array, "Array'], ", regsize);
            }
            else {
                // Variable size array
                e.say('root_new ', reg, ", ['parrot'; 'Resizable", self.t_array, "Array']");
            }
            if (init != null) {
                string itemreg = self.tempreg(t_reg);
                int n = elements(init);
                if (size == null) {
                    if (n > 0) {
                        // Allocate initializers size
                        e.emitset(reg, n);
                    }
                }
                int i= 0;
                for (var item in init) {
                    item.emit(e, itemreg);
                    e.say(reg, '[', i , '] = ', itemreg);
                    ++i;
                }
            }
        }
    }
    function defaultinit(var e)
    {
        InternalError('DeclareStatement.defaultinit must be overriden');
    }
}

function parseDeclareHelper(fun, start, tk, owner)
{
    var next;
    var r = null;
    do {
        var item = fun(start, tk, owner);
        r = addtomulti(r, item);
        next = tk.get();
    } while (next.isop(','));
    RequireOp(';', next);
    return r;
}

//*********************************************
//            ConstStatement
//*********************************************

class ConstStatement : Statement
{
    var type;
    var name;
    var value;

    function ConstStatement(var start, var owner,
            string type, var name, var value)
    {
        self.initstatement(start, owner);
        self.type = type;
        self.name= name;
        self.value = value;
    }
    function optimize()
    {
        var value = self.value;
        var name = self.name;
        string type = self.type;
        value = value.optimize();
        if (! value.hascompilevalue()) {
            SyntaxError('Value for const is not evaluable at compile time',
                self.start);
        }
        self.createconst(name, type, value, '');
        self.value = value;
        return self;
    }
    function checkresult()
    {
        InternalError('Direct use of const', self.start);
    }
    function emit(e)
    {
        string name = self.name;
        e.comment('Constant ' + name + ' evaluated at compile time');
    }
}

function parseConst(start, tk, owner)
{
    var t = tk.get();
    string type = typetoregcheck(t);
    if (type != REGint && type != REGfloat && type != REGstring)
        SyntaxError('Invalid type for const', start);

    var multi = null;
    do {
        t = tk.get();
        var name = t;
        ExpectOp('=', tk);
        var value = parseExpr(tk, owner);
        multi = addtomulti(multi,
                new ConstStatement(t, owner, type, name, value));
    } while ((t = tk.get()).isop(','));
    return multi;
}

//*********************************************
//            VarStatement
//*********************************************

class VarStatement : VarBaseStatement
{
    var init;
    function VarStatement(start, tk, owner, name, int flags)
    {
        self.initvarbase(start, owner, name, flags);
        var t= tk.get();
        if (t.isop('=')) {
            self.init = parseExpr(tk, self);
            t= tk.get();
        }
        RequireOp(';', t);
    }
    function optimize_init()
    {
        if (self.init != null)
            self.init = self.init.optimize();
        return self;
    }
    function optimize()
    {
        return self.optimize_init();
    }
    function emit(var e)
    {
        self.annotate(e);
        string name=  self.name;
        string reg = self.reg;
        var init = self.init;
        e.comment('var ' + name + ': ' + reg);
        if (init != null)
            if (init.isnull())
                init = null;
        if (init != null) {
            string type = init.checkresult();
            switch (type) {
            case REGvar:
                if ((init instanceof MemberExpr) || (init instanceof ArrayExpr) || (init instanceof NewExpr))
                    init.emit_init(e, reg);
                else
                    init.emit(e, reg);
                break;
            case REGstring:
            case REGint:
            case REGfloat:
                string value = init.emit_get(e);
                e.emitbox(reg, value);
                break;
            case REGnone:
                SyntaxError("Can't use void function as initializer", self.name);
            default:
                SyntaxError("Invalid var initializer", self.name);
            }
        }
        else
            e.emitnull(reg);
    }
}

class ResizableVarStatement : VarStatement
{
    function ResizableVarStatement(start, tk, owner, name)
    {
        self.initvarbase(start, owner, name);
        ExpectOp(';', tk);
    }
    function emit(var e)
    {
        self.annotate(e);
        string name=  self.name;
        string reg = self.reg;
        e.comment('var ' + name + '[] : ' + reg);
        e.say('new ', reg, ", 'ResizablePMCArray'");
    }
}

class FixedVarStatement : VarStatement
{
    var exprsize;

    function FixedVarStatement(start, tk, owner, name)
    {
        self.initvarbase(start, owner, name);
        self.exprsize = parseExpr(tk, self);
        ExpectOp(']', tk);
        ExpectOp(';', tk);
    }
    function optimize()
    {
        self.exprsize = self.exprsize.optimize();
        return self.optimize_init();
    }
    function emit(var e)
    {
        string regsize = self.exprsize.emit_get(e);
        self.annotate(e);
        string name=  self.name;
        string reg = self.reg;
        e.comment('var ' + name + '[] : ' + reg);
        e.say('new ', reg, ", 'FixedPMCArray', ", regsize);
    }
}

function parseVar(start, tk, owner, int flags[optional])
{
    var name = tk.get();
    RequireIdentifier(name);
    var t = tk.get();
    if (t.isop('[')) {
        t = tk.get();
        if (t.isop(']'))
            return new ResizableVarStatement(start, tk, owner, name); 
        else {
            tk.unget(t);
            return new FixedVarStatement(start, tk, owner, name); 
        }
    }
    else {
        tk.unget(t);
        return new VarStatement(start, tk, owner, name, flags);
    }
}

function parseVolatile(start, tk, owner)
{
    var t = tk.get();
    if (!t.iskeyword('var'))
        SyntaxError("invalid volatile type", t);
    return parseVar(start, tk, owner, VAR_is_volatile);
}

//*********************************************
//            StringStatement
//*********************************************

class StringStatement : DeclareStatement
{
    function StringStatement(t, tk, owner)
    {
        self.t_reg = REGstring;
        self.t_name = 'string';
        self.t_array = 'String';
        self.parse(t, tk, owner);
    }
    function defaultinit(var e)
    {
        e.emitnull(self.reg);
    }
}

function newStringSt(start, tk, owner)
{
    return new StringStatement(start, tk, owner);
}

function parseString(start, tk, owner)
{
    using static newStringSt;
    return parseDeclareHelper(newStringSt, start, tk, owner);
}

//*********************************************
//            IntStatement
//*********************************************

class IntStatement : DeclareStatement
{
    function IntStatement(t, tk, owner)
    {
        self.t_reg = REGint;
        self.t_name = 'int';
        self.t_array = 'Integer';
        self.parse(t, tk, owner);
    }
    function defaultinit(var e)
    {
        e.emitnull(self.reg);
    }
}

function newIntSt(start, tk, owner)
{
    return new IntStatement(start, tk, owner);
}

function parseInt(start, tk, owner)
{
    using static newIntSt;
    return parseDeclareHelper(newIntSt, start, tk, owner);
}

//*********************************************
//            FloatStatement
//*********************************************

class FloatStatement : DeclareStatement
{
    function FloatStatement(t, tk, owner)
    {
        self.t_reg = REGfloat;
 
        self.t_name = 'float';
        self.t_array = 'Float';
        self.parse(t, tk, owner);
    }
    function defaultinit(var e)
    {
        e.emitnull(self.reg);
    }
}

function newFloatSt(start, tk, owner)
{
    return new FloatStatement(start, tk, owner);
}

function parseFloat(start, tk, owner)
{
    using static newFloatSt;
    return parseDeclareHelper(newFloatSt, start, tk, owner);
}

//*********************************************
//            CompoundStatement
//*********************************************

class CompoundStatement : MultiStatementBase, BlockStatement
{
    var end;
    var labels;

    function CompoundStatement(start, tk, owner)
    {
        self.initstatement(start, owner);
        self.labels = {};
        self.statements= [];
        var t;
        while (! (t= tk.get()).isop('}')) {
            tk.unget(t);
            var c = parseStatement(tk, self);
            if (c == null)
                InternalError('Unexpected null statement');
            push(self.statements, c);
        }
        self.end= t;
    }
    function getlabel(var name)
    {
        string s= name;
        var labels= self.labels;
        string exist= labels[s];
        if (exist == null || exist == '')
            exist = self.owner.getlabel(name);
        return exist;
    }
    function createlabel(var name)
    {
        string s= name;
        var labels= self.labels;
        string exist= labels[s];
        if (exist != null && exist != '')
            SyntaxError('Label already defined', name);
        string value= self.genlabel();
        labels[s]= value;
        return value;
    }
    function getend() { return self.end; }
    function emit(var e)
    {
        e.comment('{');
        for (var st in self.statements) {
            st.emit(e);
            self.freetemps();
        }
        e.comment('}');
    }
}

//*********************************************
//            RegisterStore
//*********************************************

class RegisterStore
{
    var type;
    var nreg;
    var tempreg;
    var freereg;
    function init [vtable]()
    {
        // Registers number 0 are reserved for temporary usage in predefs.
        self.nreg = 1;
        string tempreg[];
        string freereg[];
        self.tempreg= tempreg;
        self.freereg= freereg;
    }
    function settype(string type)
    {
        self.type = type;
        return self;
    }
    function createreg()
    {
        var n = self.nreg;
        int i = n;
        string reg= i++;
        n =: i;
        string type = self.type;
        reg = '$' + type + reg;
        return reg;
    }
    function tempreg()
    {
        var freereg = self.freereg;
        var tempreg = self.tempreg;
        string reg;
        if (elements(freereg) > 0)
            reg= freereg.pop();
        else
            reg= self.createreg();
        push(tempreg, reg);
        return reg;
    }
    function freetemps()
    {
        var freereg = self.freereg;
        var tempreg = self.tempreg;
        int n = elements(tempreg);
        for (int i = n - 1; i >= 0; --i) {
            string s = tempreg[i];
            push(freereg, s);
        }
        tempreg =: 0;
    }
}

//*********************************************
//            FunctionBase
//*********************************************

class FunctionBase : BlockStatement
{
    var name;
    var subid;
    var modifiers;
    var params;
    var body;
    var regstI;
    var regstN;
    var regstS;
    var regstP;
    var nlabel;
    var localfun;
    var lexicals;
    var usedlexicals;
    var outer;

    function FunctionBase(start, owner)
    {
        self.initstatement(start, owner);
        self.params = [];
        self.nlabel= 0;
        self.regstI = new RegisterStore().settype(REGint);
        self.regstN = new RegisterStore().settype(REGfloat);
        self.regstS = new RegisterStore().settype(REGstring);
        self.regstP = new RegisterStore().settype(REGvar);
    }

    function getouter() { return self; }
    function makesubid()
    {
        // Return the subid for this function, creating if it doesn't have one
        var subid = self.subid;
        if (subid == null) {
            subid = self.generatesubid();
            self.subid = subid;
        }
        return subid;
    }

    function same_scope_as(other)
    {
        int r = self === other;
        return r;
    }
    function parse_parameters(tk)
    {
        var params = self.params;
        var t= tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            do {
                t= tk.get();
                string type = typetoregcheck(t.checkkeyword());
                if (type != '')
                    t= tk.get();
                else
                    type = REGvar;
                string argname = '__ARG_' + string(self.getparamnum());
                self.createvarnamed(t, type, argname);

                string varname = t;
                var arg = { };
                arg['name'] = varname;
                t= tk.get();
                if (t.isop('[')) {
                    var modifiers = new ModifierList(tk, self);
                    arg['modifiers'] = modifiers;
                    t = tk.get();
                }
                push(params, arg);
            } while (t.isop(','));
            if (!t.isop(')'))
                Expected("')' or ','", t);
        }
    }

    function addlocalfunction(fn)
    {
        var localfun = self.localfun;
        if (localfun == null)
            self.localfun = [ fn ];
        else
            push(localfun, fn);
    }

    function optimize()
    {
        self.body = self.body.optimize();
        return self;
    }

    function setusedlex(string lexname, string localname)
    {
        var lexicals = self.usedlexicals;
        if (lexicals == null) {
            lexicals = {};
            self.usedlexicals = lexicals;
        }
        lexicals[localname] = lexname;
    }
    function setlex(string lexname, string localname)
    {
        var lexicals = self.lexicals;
        if (lexicals == null) {
            lexicals = {};
            self.lexicals = lexicals;
        }
        lexicals[localname] = lexname;
    }
    function createlex(vardata)
    {
        // Get the lexname for a variable, creating it on the fly
        // when needed.
        var lex = vardata.getlex();
        string lexname;
        if (lex != null)
            lexname = lex;
        else {
            string reg = vardata.getreg();
            int lexnum = self.getlexnum();
            lexname = '__WLEX_' + string(lexnum);
            self.setlex(lexname, reg);
            vardata.setlex(lexname);
        }
        return lexname;
    }

    function createreg(string type)
    {
        var store;
        switch(type) {
        case REGint:
            store = self.regstI; break;
        case REGfloat:
            store = self.regstN; break;
        case REGstring:
            store = self.regstS; break;
        case REGvar:
            store = self.regstP; break;
        default:
            InternalError('Invalid type in createreg: ' + type);
        }
        string reg = store.createreg();
        return reg;
    }
    function tempreg(string type)
    {
        var store;
        switch(type) {
        case REGint:
            store = self.regstI; break;
        case REGfloat:
            store = self.regstN; break;
        case REGstring:
            store = self.regstS; break;
        case REGvar:
            store = self.regstP; break;
        default:
            InternalError("Invalid type '" + type + "' in tempreg");
        }
        string reg = store.tempreg();
        return reg;
    }
    function freetemps()
    {
        for (var st in [ self.regstI, self.regstN, self.regstS, self.regstP ] )
            st.freetemps();
    }
    function genlabel()
    {
        var nlabel = self.nlabel;
        int n= nlabel;
        string s= '__label_' + n++;
        nlabel =: n;
        return s;
    }
    function getbreaklabel(pos)
    {
        SyntaxError('break not allowed here', pos);
    }
    function getcontinuelabel(pos)
    {
        SyntaxError('continue not allowed here', pos);
    }

    function emit(var e)
    {
        string name = self.name;
        e.say();
        e.print(".sub ");
        if (self.isanonymous())
            e.print("'' :anon");
        else
            e.print ("'", name, "'");
        if (self.subid != null)
            e.print(" :subid('", self.subid, "')");
        if (self.outer != null) {
            var outer = self.outer;
            var outerid = outer.subid;
            if (outerid != null)
                e.print(" :outer('", outerid, "')");
        }

        // Modifiers
        if (self.ismethod())
            e.print(' :method');
        var modifiers= self.modifiers;
        if (modifiers != null) {
            var mlist = modifiers.getlist();
            for (var m in mlist) {
                int nargmods = m.numargs();
                e.print(' :', m.getname());
                if (nargmods > 0) {
                    e.print('(');
                    for (int iargmod = 0; iargmod < nargmods; ++iargmod) {
                        var argmod = m.getarg(iargmod);
                        if (!argmod.isstringliteral())
                            SyntaxError('Invalid modifier', argmod.start);
                        e.print(argmod.getPirString());
                    }
                    e.print(')');
                }
            }
        }
        else {
            if (name == 'main')
                e.print(' :main');
        }
        e.say();

        var params = self.params;
        var param;
        string paramname;
        var a;

        for (param in params) {
            paramname = param['name'];
            a = self.getvar(paramname);
            string ptype = typetopirname(a.gettype());
            e.print('.param ', ptype, ' ', a.getreg());
            var modarg = param['modifiers'];
            if (modarg != null) {
                var named = null;
                var slurpy = null;
                var modarglist = modarg.getlist();
                for (var mod in modarglist) {
                    string modname = mod.getname();
                    switch (modname) {
                    case 'named':
                        named = mod;
                        break;
                    case 'slurpy':
                        slurpy = mod;
                        break;
                    default:
                        e.print(' :', modname);
                    }
                }
                if (named != null && slurpy != null) {
                    // Special case for named slurpy: named refers
                    // to the slurpy content, not to the param himself.
                    // TODO: check that named has no arguments,
                    // or use a different way.
                    e.print(" :named :slurpy");
                }
                else {
                    if (named != null) {
                        string setname;
                        int nargs = named.numargs();
                        switch (nargs) {
                        case 0:
                            setname = "'" + paramname + "'";
                            break;
                        case 1:
                            var argmod = named.getarg(0);
                            if (! argmod.isstringliteral())
                                SyntaxError('Invalid modifier', self.start);
                            setname = argmod.getPirString();
                            break;
                        default:
                            SyntaxError('Invalid modifier', self.start);
                        }
                        e.print(" :named(", setname, ")");
                    }
                    else if (slurpy != null) {
                        e.print(" :slurpy");
                    }
                }
            }
            e.say('');
        }
        e.say();
        e.annotate(self.start);

        // lexicals declared in this function and its inner scopes
        var lexicals = self.lexicals;
        if (lexicals != null)
        {
            for (string l in lexicals)
                e.say(".lex '", lexicals[l], "', ", l);
        }
        // lexicals from outers used inside
        lexicals = self.usedlexicals;
        if (lexicals != null)
        {
            for (string l in lexicals)
                e.say(l, " = find_lex '", lexicals[l], "'");
        }

        var body = self.body;
        if (body.isempty())
            e.comment('Empty body');
        else {
            e.comment('Body');
            body.emit(e);
            e.annotate(body.getend());
        }
        e.say("\n.end # ", name, "\n");

        // Local functions
        var localfun = self.localfun;
        if (localfun != null) {
            for (int ifn = 0; ifn < elements(localfun); ++ifn) {
                var fn = localfun[ifn];
                fn.emit(e);
            }
        }
    }
}

//*********************************************
//            FunctionStatement
//*********************************************

class FunctionStatement : FunctionBase
{
    var paramnum;
    var lexnum;

    function FunctionStatement(start, tk, owner)
    {
        self.FunctionBase(start, owner);
        self.paramnum = 0;
        self.lexnum = 0;
        self.parse(tk);
    }

    function isanonymous() { return false; }
    function getparamnum()
    {
        // Get a number to assign unique internal names to params.
        var paramnum = self.paramnum;
        int n = paramnum + 1;
        paramnum =: n;
        return n;
    }
    function getlexnum()
    {
        // Get a number to assign unique internal names to lexicals.
        var lexnum = self.lexnum;
        int n = lexnum + 1;
        lexnum =: n;
        return n;
    }
    function ismethod() { return false; }

    function parse(tk)
    {
        var name = tk.get();
        self.name = name;
        var t = tk.get();
        if (t.isop('[')) {
            var modifiers = new ModifierList(tk, self);
            self.modifiers = modifiers;
            t = tk.get();
        }
        RequireOp('(', t);
        self.parse_parameters(tk);

        var fullname = clone(self.owner.getpath());
        push(fullname, name.getidentifier());
        self.createconst('__FUNCTION__', REGstring,
                new StringLiteral(self,
                    new TokenQuoted(name.file, name.line, join('.', fullname))),
                    '');

        t= tk.get();
        if (!t.isop('{'))
            ExpectedOp('{', t);
        self.body= new CompoundStatement(t, tk, self);
        return self;
    }
}

//*********************************************
//            LocalFunctionStatement
//*********************************************

class LocalFunctionStatement : FunctionBase
{
    function LocalFunctionStatement(start, tk, owner)
    {
        self.FunctionBase(start, owner);
        self.outer = owner.getouter();
        self.outer.makesubid();
        var subid = self.makesubid();
        self.name = subid;
        self.parse_parameters(tk);
        var t = tk.get();
        RequireOp('{', t);
        self.body= new CompoundStatement(t, tk, self);
        owner.addlocalfunction(self);
    }
    function isanonymous() { return true; }
    function ismethod() { return false; }
    function getsubid()
    {
        return self.subid;
    }
    function getparamnum()
    {
        // Forward to the outer to avoid duplicate names.
        return self.outer.getparamnum();
    }
    function getlexnum()
    {
        // Forward to the outer to avoid duplicate names.
        return self.outer.getlexnum();
    }
    function getvar(string name)
    {
        var r = self.getlocalvar(name);
        if (r == null) {
            // Not found in function scope, look for external scopes
            // and type valid for a lexical.
            r = self.owner.getvar(name);
            if (r == null) {
                // Special case for self in methods
                if (name == SELF) {
                    var ownerscope = self.outer;
                    if (self.outer.ismethod()) {
                        string lexself = ownerscope.makelexicalself();
                        r = self.createvar(name, REGvar);
                        string reg = r.getreg();
                        self.setusedlex(lexself, reg);
                    }
                }
            }
            else if (r.gettype() == 'P' && !r.isconst()) {
                var scope = r.getscope();
                var ownerscope = scope.getouter();
                var outer = self.outer;
                if (ownerscope instanceof FunctionBase) {
                    if (ownerscope.same_scope_as(outer)) {
                        string lexname = scope.makelexical(r);
                        int flags = r.getflags() | VAR_is_lexical;
                        r = self.createvar(name, REGvar, flags);
                        r.lexname = lexname;
                        string reg = r.getreg();
                        self.setusedlex(lexname, reg);
                    }
                }
            }
        }
        if (r != null && !(r instanceof VarData))
            InternalError('Incorrect data for variable in LocalFunction');
        return r;
    }
}

//*********************************************
//            MethodStatement
//*********************************************

class MethodStatement : FunctionStatement
{
    function MethodStatement(t, tk, owner)
    {
        self.FunctionStatement(t, tk, owner);
    }
    function ismethod() { return true; }
}

//*********************************************
//            Class specifier
//*********************************************

const int
    CLASSSPECIFIER_invalid   = 0,
    CLASSSPECIFIER_str       = 1, // Literal name
    CLASSSPECIFIER_parrotkey = 2, // Parrot key
    CLASSSPECIFIER_id        = 3; // Identifier, maybe qualified

class ClassSpecifier : CommonBase
{
    function ClassSpecifier(owner, start)
    {
        self.initbase(start, owner);
    }
    function reftype() { return CLASSSPECIFIER_invalid; }

    function annotate(e)
    {
        e.annotate(self.start);
    }
}

class ClassSpecifierStr : ClassSpecifier
{
    var name;
    function ClassSpecifierStr(owner, name)
    {
        self.ClassSpecifier(owner, name);
        self.name = name;
    }
    function reftype() { return CLASSSPECIFIER_str; }

    function emit(e, ns)
    {
        string basestr = self.name;
        e.print(basestr);
    }
}

class ClassSpecifierParrotKey : ClassSpecifier
{
    var key;
    var hll;
    function ClassSpecifierParrotKey(tk, owner, start)
    {
        self.ClassSpecifier(owner, start);
        var key = [];
        var t = tk.get();
        if (!t.isstring())
            Expected('literal string', t);
        push(key, t.rawstring());
        t = tk.get();
        if (! t.isop(']')) {
            switch (t.checkop()) {
              case ':':
                self.hll = true;
              case ',':
                break;
              default:
                SyntaxError('Unexpected token in class key', t);
            }
            do {
                t = tk.get();
                if (!t.isstring())
                    Expected('literal string', t);
                push(key, t.rawstring());
            } while ((t = tk.get()).isop(','));
            RequireOp(']', t);
        }
        self.key = key;
    }
    function reftype() { return CLASSSPECIFIER_parrotkey; }
    function hasHLL()
    {
        return int(self.hll != null);
    }

    function emit(e, ns)
    {
        e.print(getparrotkey(self.key));
    }
}

class ClassSpecifierId : ClassSpecifier
{
    var key;
    function ClassSpecifierId(tk, owner, id)
    {
        self.ClassSpecifier(owner, id);
        var key = [ string(id) ];
        var t;
        while ((t = tk.get()).isop('.')) {
            t = tk.get();
            push(key, string(t));
        }
        tk.unget(t);
        self.key = key;
    }
    function reftype() { return CLASSSPECIFIER_id; }

    function last()
    {
        var key = self.key;
        return key[-1];
    }

    function emit(e, ns)
    {
        var key = ns.findclasskey(self.key);
        if (key == null) {
            if (self.dowarnings())
                Warn("class " + join(".", self.key) + " not found at compile time");
            e.print(getparrotkey(self.key));
        }
        else e.print(key.getclasskey());
    }
}

function parseClassSpecifier(tk, owner)
{
    var t = tk.get();
    if (t.isstring())
        return new ClassSpecifierStr(owner, t);
    if (t.isop('['))
        return new ClassSpecifierParrotKey(tk, owner, t);
    if (t.isidentifier())
        return new ClassSpecifierId(tk, owner, t);
    SyntaxError('Invalid class', t);
}

//*********************************************
//            ClassStatement
//*********************************************

class ClassStatement : CommonBase, VarContainer
{
    var parent;
    var name;
    var bases;
    var constants;
    var functions;
    var members;
    var classns;

    function ClassStatement(start, tk, parent)
    {
        self.initbase(start, parent);
        self.parent= parent;
        var functions = [];
        self.functions = functions;
        var members = [];
        self.members = members;
        self.bases= [];
        var constants = [];
        self.constants = constants;

        var name = tk.get();
        self.name = name;
        var classns = clone(parent.getpath());
        push(classns, self.name);
        self.classns = classns;

        var t = tk.get();
        if (t.isop(':')) {
            var bases = self.bases;
            for (;;) {
                var base = parseClassSpecifier(tk, self);
                push(bases, base);
                t= tk.get();
                if (!t.isop(',')) break;
            }
        }
        RequireOp('{', t);
        for (t = tk.get(); !t.isop('}'); t = tk.get()) {
            string key = t.checkkeyword();
            switch (key) {
              case 'function':
                var f= new MethodStatement(t, tk, self);
                push(functions, f);
                break;
              case 'var':
                var name = tk.get();
                if (! name.isidentifier())
                   Expected("member identifier", name);
                push(members, name);
                t = tk.get();
                if (! t.isop(';'))
                    Expected("';' in member declaration", t);
                break;
              case 'const':
                var cst = parseConst(t, tk, self);
                push(constants, cst);
                break;
              default:
                SyntaxError("Unexpected item in class", t);
            }
        }
    }
    function getpath()
    {
        return self.classns;
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function findsymbol(classkey)
    {
        return self.parent.findsymbol(classkey);
    }
    function findclasskey(classkey)
    {
        return self.parent.findclasskey(classkey);
    }
    function checkclass(string name)
    {
        return self.parent.checkclass(name);
    }
    function use_predef(string name)
    {
        return self.owner.use_predef(name);
    }
    function optimize()
    {
        optimize_array(self.constants);
        optimize_array(self.functions);
        return self;
    }
    function getclasskey()
    {
        return getparrotkey(self.classns);
    }
    function emit(var e)
    {
        var classns= self.classns;
        e.say(getparrotnamespacekey(classns));
        for (var f in self.functions)
            f.emit(e);

        e.say('.sub Winxed_class_init :anon :load :init');

        e.say('newclass $P0, ', self.getclasskey() );
        int n = 1;
        for (var base in self.bases) {
            base.annotate(e);
            string reg = "$P" + n++;
            e.print('get_class ', reg, ', ');
            base.emit(e, self.parent);
            e.say();
            e.say('addparent $P0, ', reg);
        }
        for (var member in self.members) {
            e.annotate(member);
            e.say("addattribute $P0, '", member, "'");
        }

        e.say('.end');
    }
}

//*********************************************
//            NamespaceBase
//*********************************************

function include_parrot(var start, var tk, var ns)
{
    var t = tk.get();
    if (!t.isstring())
        Expected('literal string', t);
    ExpectOp(';', tk);
    string filename = t.rawstring();
    var interp = getinterp();

    // Search for the file in the parrot include paths
    const int IGLOBALS_LIB_PATHS = 9;
    const int PARROT_LIB_PATH_INCLUDE = 0;
    var libpaths = interp[IGLOBALS_LIB_PATHS];
    var paths = libpaths[PARROT_LIB_PATH_INCLUDE];
    var file = new ['FileHandle'];
    for (string path in paths) {
        string filepath = path + filename;
        try {
            file.open(filepath, 'r');
            break;
        }
        catch () {
        }
    }
    if (file.is_closed())
        SyntaxError('File not found', t);

    // Use a regular expression to check lines like:
    // .macro_const CONST_NAME value
    // Assume only integer values for a now
    using extern PGE;
    var regexcomp = compreg('PGE::P5Regex');
    var rule = regexcomp('^\.macro_const\s+([A-Za-z0-9_]+)\s+(\S+)');

    for (string line = file.readline(); !file.eof(); line = file.readline()) {
        string matches[];
        matches = rule(line);
        if (elements(matches) > 0) {
            string name = matches[0];
            string value = matches[1];
            int ivalue;
            if (substr(value, 0, 2) == '0x' || substr(value, 0, 2) == '0X')
                ivalue = substr(value, 2).to_int(16);
            else
                ivalue = value;
            ns.createconst(name, REGint,
                integerValue(ns,
                    new TokenInteger(start.file, start.line, name), ivalue),
                    '');
        }
    }
    file.close();
}

//*********************************************

class NamespaceBase : VarContainer
{
    var nspath;
    var namespaces;
    var classes;
    var functions;
    var items;
    var owner;

    function init [vtable] ()
    {
        self.namespaces= [];
        self.classes= [];
        self.functions = [];
        self.items = [];
    }
    function getpath()
    {
        return self.nspath;
    }
    function checkclass_base(string name)
    {
        var classes = self.classes;
        for (var cl in classes)
            if (cl.name == name)
                return cl;
        return null;
    }
    function findclasskey_base(classkey)
    {
        // Look for a class by its key in this namespace
        // and its childs.
        switch (elements(classkey)) {
          case 0:
            return null;
          case 1:
            // The key contains the name, look by name
            return self.checkclass_base(classkey[0]);
          default:
            // The key is multi: look for a child namespace named
            // as the first key item, and look into it with the
            // remaining.
            var namespaces = self.namespaces;
            var childkey = clone(classkey);
            string basename = childkey.shift();
            for (var ns in namespaces) {
                if (ns.name == basename) {
                    var found = ns.findclasskey(childkey);
                    if (found != null)
                        return found;
                }
            }
        }
        return null;
    }
    function findsymbol(classkey)
    {
        // Look for a symbol by its key in this namespace
        // and its childs.
        switch (elements(classkey)) {
          case 0:
            return null;
          case 1:
            string name = classkey[0];
            // The key contains the name, look by name
            var sym = self.checkclass_base(name);
            if (sym != null)
                return sym;
            for (var s in self.functions)
                if (s.name == name)
                    return s;
            return null;
          default:
            // The key is multi: look for a child namespace named
            // as the first key item, and look into it with the
            // remaining.
            var namespaces = self.namespaces;
            var childkey = clone(classkey);
            string basename = childkey.shift();
            for (var ns in namespaces) {
                if (ns.name == basename) {
                    var found = ns.findsymbol(childkey);
                    if (found != null)
                        return found;
                }
            }
        }
        return null;
    }
    function parsenamespace(start, tk)
    {
        var t= tk.get();
        string name= t;
        t= tk.get();

        var modifier;
        if (t.isop('[')) {
            modifier = new ModifierList(tk, self);
            t = tk.get();
        }

        RequireOp('{', t);
        var child= new NamespaceStatement(self, start, name, modifier);
        push(self.namespaces, child);
        push(self.items, child);
        child.parse(tk);
    }
    function parse(tk)
    {
        var items = self.items;
        var functions = self.functions;
        var classes = self.classes;
        var t;
        for (t = tk.get(); t && !t.isop('}'); t = tk.get())
        {
            string key = t.checkkeyword();
            switch (key) {
              case 'namespace':
                self.parsenamespace(t, tk);
                break;
              case 'const':
                var cst = parseConst(t, tk, self);
                push(items, cst);
                break;
              case 'function':
                var f= new FunctionStatement(t, tk, self);
                push(functions, f);
                push(items, f);
                break;
              case 'class':
                var c= new ClassStatement(t, tk, self);
                push(classes, c);
                push(items, c);
                break;
              case 'using':
                t = tk.get();
                if (! t.iskeyword('extern'))
                    SyntaxError('Unsupported at namespace level', t);
                t = tk.get();
                if (! t.isstring())
                    Expected('string literal', t);
                string reqlib = t;
                self.addlib(reqlib);
                ExpectOp(';', tk);
                break;
              case '$include_const':
                include_parrot(t, tk, self);
                break;
              case '$load':
                t = tk.get();
                if (! t.isstring())
                    Expected('string literal', t);
                ExpectOp(';', tk);
                self.addload((new StringLiteral(self, t)).getPirString());
                break;
              case '$loadlib':
                t = tk.get();
                if (! t.isstring())
                    Expected('string literal', t);
                ExpectOp(';', tk);
                self.addlib((new StringLiteral(self, t)).getPirString());
                break;
              default:
                SyntaxError("Unexpected token", t);
            }
        }
        if (t)
            self.close_ns(t);
        else
            self.unclosed_ns();
    }
    function optimize_base()
    {
        optimize_array(self.items);
    }
    function emit_base(var e)
    {
        var path= self.getpath();
        string s= getparrotnamespacekey(path);

        int activate= 1;
        for (var item in self.items) {
            if ((item instanceof NamespaceStatement) || 
                    (item instanceof ClassStatement))
                activate= 1;
            else
                if (activate) {
                    e.say(s);
                    activate= 0;
                }
            item.emit(e);
        }
    }
}

//*********************************************
//            NamespaceStatement
//*********************************************

class NamespaceStatement : NamespaceBase
{
    var parent;
    var start;
    var name;
    var modifier;
    var hll;

    function NamespaceStatement(var parent, var start,
            string name, var modifier)
    {
        var nspath = clone(parent.getpath());
        push(nspath, name);
        self.nspath = nspath;

        self.parent= parent;
        self.start = start;
        self.owner = parent;
        self.name= name;
        self.modifier = modifier;
        if (modifier != null) {
            if (modifier.pick('HLL') != null)
                self.hll = self.name;
        }
    }
    function dowarnings()
    {
        return self.parent.dowarnings();
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function use_predef(string name)
    {
        self.owner.use_predef(name);
    }
    function addlib(string libname)
    {
        self.parent.addlib(libname);
    }
    function addlib(string loadname)
    {
        self.parent.addload(loadname);
    }
    function checkclass(string name)
    {
        var cl = self.checkclass_base(name);
        if (cl == null)
            return self.parent.checkclass(name);
        else
            return cl;
    }
    function findclasskey(classkey)
    {
        // Look for a class bi its key in this namespace and its childs.
        // If not found, look in the parent namespace.
        var cl = self.findclasskey_base(classkey);
        if (cl == null)
            cl = self.parent.findclasskey(classkey);
        return cl;
    }
    function unclosed_ns()
    {
       SyntaxError('unclosed namespace', self.start);
    }
    function close_ns(t)
    {
        // Do nothing
    }
    function optimize()
    {
        var modifier = self.modifier;
        if (modifier != null) {
            modifier = modifier.optimize();
            self.modifier = modifier;
        }
        self.optimize_base();
        return self;
    }
    function emit(var e)
    {
        var hll = self.hll;
        if (hll !=  null)
            e.say(".HLL '", hll, "'");

        self.emit_base(e);

        if (hll !=  null)
            e.say(".HLL 'parrot'");
    }
}

//*********************************************
//            RootNamespace
//*********************************************

class RootNamespace : NamespaceBase
{
    var unit;
    var predefs_used;
    var libs;
    var loads;
    var subidgen;

    function RootNamespace(unit)
    {
        string nspath[];
        self.nspath = nspath;
        self.unit = unit;
        self.predefs_used = {};
        self.subidgen = 0;
    }
    function use_predef(string name)
    {
        var predefs_used = self.predefs_used;
        predefs_used[name] = 1;
    }
    function predef_is_used(string name)
    {
        var predefs_used = self.predefs_used;
        return predefs_used[name] == null ? 0 : 1;
    }

    function generatesubid()
    {
        var subidgen = self.subidgen;
        int idgen = subidgen;
        ++idgen;
        subidgen =: idgen;
        string id = 'WSubId_' + string(idgen);
        return id;
    }

    function addlib(string libname)
    {
        var libs = self.libs;
        if (libs == null) {
            libs = {};
            self.libs = libs;
        }
        libs[libname] = 1;
    }
    function addload(string name)
    {
        var loads = self.loads;
        if (loads == null) {
            loads = {};
            self.loads = loads;
        }
        loads[name] = 1;
    }
    function checkclass(string name)
    {
        return self.checkclass_base(name);
    }
    function findclasskey(classkey)
    {
        // Look for a class by its key in the root namespace.
        return self.findclasskey_base(classkey);
    }
    function unclosed_ns()
    {
        // Do nothing
    }
    function close_ns(t)
    {
         SyntaxError('Cannot close root namespace', t);
    }
    function dowarnings()
    {
        return self.unit.dowarnings();
    }
    function optimize()
    {
        self.optimize_base();
        return self;
    }
    function emit(var e)
    {
        var predefs_used = self.predefs_used;

        // chomp uses a library function, load the libray if chomp is used
        if (predefs_used['chomp'] != null)
            self.addload('"String/Utils.pbc"');

        // Load trans opcodes if some of its corresponding predefs are used
        string trfuncs[] = [
            'acos', 'asin', 'atan', 'cos', 'exp', 'ln', 'sin', 'tan', 'pow'
        ];
        for (string trfun in trfuncs)
            if (predefs_used[trfun] != null) {
                self.addlib("'trans_ops'");
                break;
            }

        int somelib = false;
        var libs = self.libs;
        if (libs != null) {
            somelib = true;
            for (string libname in libs)
                e.say('.loadlib ', libname);
        }

        int someload = false;
        var loads = self.loads;
        if (loads != null) {
            someload = true;
            e.print("\n.sub initial_load_bytecode :anon :load :init\n");
            for (string name in loads)
                e.say('    load_bytecode ', name);
            e.print(".end\n\n");
        }
        if (somelib || someload)
            e.comment('end libs');

        self.emit_base(e);
    }
}

//*********************************************
//           Compiler classes
//*********************************************

const string EVAL_NAME = '__eval__';

class WinxedCompileUnit
{
    var rootns;
    var warnings;

    function init [vtable] ()
    {
        self.warnings = true;
        var rootns= new RootNamespace(self);

        // Store predefined constants in the root namespace.
        var taux = new TokenIdentifier('__predefconst__', 0, 'predefconst');

        rootns.createconst('false', REGint,
                integerValue(rootns,
                    new TokenInteger(taux.file, taux.line, 'false'), 0),
                    '');
        rootns.createconst('true', REGint,
                integerValue(rootns,
                    new TokenInteger(taux.file, taux.line, 'false'), 1),
                    '');
        // Tricky way of setting __STAGE__: stage 1 is built with
        // stage 0 and stage 2 is built with stage 1. Increment
        // the current stage and we are done.
        rootns.createconst('__STAGE__', REGstring,
                new StringLiteral(rootns,
                    new TokenQuoted(taux.file, taux.line, string(int(__STAGE__) + 1))),
                    '');

        self.rootns = rootns;
    }
    function setwarnmode(int mode)
    {
        self.warnings =: mode;
    }
    function dowarnings()
    {
        return int(self.warnings);
    }
    function parse(tk)
    {
        self.rootns.parse(tk);
    }
    function optimize()
    {
        self.rootns = self.rootns.optimize();
    }
    function emit(var e)
    {
        e.comment('Begin generated code');
        e.say('');

        self.rootns.emit(e);

        e.comment('End generated code');
    }
}

//*********************************************

class WinxedHLL
{
    function __private_compile_tail(winxed, target, noan)
    {
        if (target == 'parse')
            return winxed;
        var handleout = new ['StringHandle'];
        handleout.open(EVAL_NAME, 'w');
        var emit= new Emit();
        if (noan)
            emit.disable_annotations();
        emit.initialize(handleout);
        winxed.emit(emit);
        emit.close();
        handleout.close();
        string pircode = handleout.read(0);
        var object;
        switch (target) {
          case 'pir':
            object = new ['String'];
            object =: pircode;
            break;
          case 'pbc':
          case '':
            var pircomp = compreg('PIR');
            object = pircomp(pircode);
            break;
          default:
            die('Invalid target');
        }
        return object;
    }
    function compile(string code,
            string target[named,optional],
            int noan[named,optional],
            int nowarn[named,optional] )
    {
        if (target == null)
            target = '';
        var handlein = new ['StringHandle'];
        handlein.open(EVAL_NAME, 'w');
        handlein.puts(code);
        handlein.close();
        handlein.open(EVAL_NAME, 'r');
        var tk= new Tokenizer(handlein, EVAL_NAME);
        var winxed= new WinxedCompileUnit();
        if (nowarn)
            winxed.setwarnmode(false);
        winxed.parse(tk);
        handlein.close();
        winxed.optimize();
        return self.__private_compile_tail(winxed, target, noan);
    }
    function compile_from_file_to_pir(string filename, var handleout,
            int noan[named,optional],
            int nowarn[named,optional] )
    {
        var handlein = new ['FileHandle'];
        handlein.open(filename, 'r');
        handlein.encoding('utf8');
        var tk= new Tokenizer(handlein, filename);
        var winxed= new WinxedCompileUnit();
        if (nowarn)
            winxed.setwarnmode(false);
        winxed.parse(tk);
        handlein.close();
        winxed.optimize();
        var emit= new Emit();
        if (noan)
            emit.disable_annotations();
        emit.initialize(handleout);
        winxed.emit(emit);
        emit.close();
    }
    function compile_from_file(string filename,
            string target[named,optional],
            int noan[named,optional],
            int nowarn[named,optional] )
    {
        if (target == null)
            target = '';
        var handlein = new ['FileHandle'];
        handlein.open(filename, 'r');
        handlein.encoding('utf8');
        var tk= new Tokenizer(handlein, filename);
        var winxed= new WinxedCompileUnit();
        if (nowarn)
            winxed.setwarnmode(false);
        winxed.parse(tk);
        handlein.close();
        winxed.optimize();
        return self.__private_compile_tail(winxed, target, noan);
    }
}

//*********************************************

function winxed_parser(tk, string outputfile, int warn, int noan)
{
    var winxed= new WinxedCompileUnit();
    if (! warn)
        winxed.setwarnmode(false);
    winxed.parse(tk);

    winxed.optimize();

    var handle;
    if (outputfile == '-')
        handle = getstdout();
    else
        handle = open(outputfile, 'w');
    var emit= new Emit();
    if (noan)
        emit.disable_annotations();
    emit.initialize(handle);
    winxed.emit(emit);
    emit.close();
    handle.close();
}

//*********************************************
//            Main functions
//*********************************************

function initializer [init,load]()
{
    var comp = new WinxedHLL();
    compreg('winxed', comp);
}

class Options
{
    var getopts;
    var opts;

    function Options(argv)
    {
        using extern Getopt.Obj;
        var getopts = new ['Getopt','Obj'];
        getopts.notOptStop(1);
        getopts.push_string('o=s');
        getopts.push_string('e=s');
        getopts.push_string('noan');
        getopts.push_string('nowarn');
        getopts.notOptStop(1);
        argv.shift();
        var opts = getopts.get_options(argv);
        self.getopts = getopts;
        self.opts = opts;
    }
    function getbool(string option)
    {
        var opts = self.opts;
        var value = opts[option];
        return value != null;
    }
    function getstring(string option, string default[optional])
    {
        var opts = self.opts;
        var value = opts[option];
        return value != null ? string(value) : default;
    }
}

function stage1(argv)
{
    var options = new Options(argv);
    string outputfile = options.getstring('o', '');
    string expr = options.getstring('e');
    int noan  = options.getbool('noan');
    int warn = ! options.getbool('nowarn');

    int argc= argv;
    string filename;
    var file;
    if (expr == null) {
        if (argc == 0)
            throw Error('No file');

        filename= argv[0];
        file = open(filename); // Must throw on error
        file.encoding('utf8');
    }
    else {
        expr = 'function main[main](argv){' + expr + ';}';
        file = new ['StringHandle'];
        file.open(EVAL_NAME, 'w');
        file.puts(expr);
        file.close();
        file.open(EVAL_NAME);
        filename = EVAL_NAME;
    }

    var t= new Tokenizer(file, filename);

    winxed_parser(t, outputfile, warn, noan);

    file.close();
}

function show_backtrace(bt)
{
    int i= 1;
    for (var t in bt) {
        var sub= t['sub'];
        string subname;
        if (sub != null) {
            subname= sub;
            string ns= sub.get_namespace();
            if (ns != '' && ns != 'parrot') subname= ns + '.' + subname;
        }
        var ann= t['annotations'];
        string file= ann['file'];
        if (file != '') {
            int line= ann['line'];
            cry(' ' * (2 * i++), "at ", subname, " in '", file, "' line ", line);
        }
    }
}

function main(argv)
{
    int retval = 0;
    try
            [
                min_severity(2),
                max_severity(2),
                handle_types(ERRORinternal, ERRORtokenizer, ERRORparser)
            ]
        stage1(argv);
    catch (e)
    {
        string msg= e['message'];
        int type = e['type'];
        switch (type) {
          case ERRORtokenizer:
          case ERRORparser:
            cry('Error: ', msg);
            retval = 1;
            break;
          default:
            cry('INTERNAL ERROR: ', msg);
            show_backtrace(e.backtrace());
            retval = 2;
        }
    }
    exit(retval);
}

// End
