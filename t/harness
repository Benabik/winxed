#! winxed
# harness for winxed tests
# TAP parsing adapted from nqp in plumage harness

function debugmsg(string s)
{
    if (0)
        say(s);
}

function run_test(string filename)
{
    var fh;

    string s= './winxed ' + filename;
    debugmsg(s);

    fh= new 'FileHandle';
    fh.open(s, 'rp');
    string test_output= fh.readall();
    fh.close();
    var output= split("\n", test_output);
    return output;
}

function max_length(var args)
{
    var filename;
    int l= 0;
    for (filename in args) {
        int i = length(filename);
        if (i > l)
            l= i;
    }
    return l;
}

function run_test_list(var args, int verbose)
{
    int total_passed= 0;
    int total_failed= 0;
    int total_files= 0;
    int failed_files= 0;
    int curr_test;
    int passed;
    int failed;

    //int l= max_length(args) + 2;
    int l= max_length(args);
    l= l + 2;

    var filename;
    for (filename in args)
    {
        print(filename);
        int i= length(filename);
        while (i++ < l)
            print('.');
        ++total_files;
        passed= 0;
        failed= 0;
        curr_test= 0;
        var output= run_test(filename);
        var plan_parts= split('..', output[0]);
        int num_tests = plan_parts[1];
        output.shift();
        if (verbose) {
            say(1 , '..', num_tests);
        }
        string line;
        for (line in output) {
            debugmsg(line);
            if (line != '')
            {
                if (verbose) say(line);
                var line_parts = split('ok ', line);
                int test_number= line_parts[1];
                debugmsg(test_number);
                string part= line_parts[0];
                debugmsg(part);
                if (part == 'not ') {
                    ++failed;
                    ++curr_test;
                }
                else if (test_number == (curr_test + 1)) {
                    ++passed;
                    ++curr_test;
                }
            }
        }
        if (failed)
            say('failed ', failed, '/', num_tests, ' tests');
        else if (plan_parts[0] != 1 || (num_tests < 0)) {
            say('INVALID PLAN: ', plan_parts[0], '..', plan_parts[1]);
            ++failed_files;
        }
        else
            say('passed ', curr_test, ' tests');

        total_passed= total_passed + passed;
        total_failed= total_failed + failed;
        if (num_tests != curr_test) {
            say('Planned to run ', num_tests, ' tests but ran ', curr_test, ' tests');
            say('FAILED');
        }
    }
    if (total_failed) {
        int total= total_passed + total_failed;
        say('FAILED ', total_failed, '/', total);
    }
    else if (failed_files)
        say('FAILED ', failed_files, ' files, PASSED ', total_passed, ' tests');
    else
        say('PASSED ', total_passed, ' tests in ', total_files, ' files');
}

function add_file(var result, string path)
{
    if (length(path) > 2) {
        string ext= substr(path, -2);
        if (ext == '.t')
            result.push(path);
    }
}

function build_from_dir(var result, string path, int recursive)
{
    var os = new 'OS';
    var dir = os.readdir(path);
    string dirent;
    for (dirent in dir)
        if ((dirent != '.') && (dirent != '..')) {
            string newpath;
	    if (path == '.') newpath = dirent;
	    else newpath = path + '/' + dirent;
            var st= os.stat(newpath);
            int mode = st[2];
            int isdir = (mode & 16384) != 0;
            if (isdir)
                build_from_dir(result, newpath, recursive);
            else
                add_file(result, newpath);
        }
}

function build_file_list(var result, var args, int recursive)
{
    var os = new 'OS';
    string path;
    for (path in args) {
        var st= os.stat(path);
        int mode = st[2];
        int isdir = (mode & 16384) != 0;
        if (isdir && recursive)
            var newlist= build_from_dir(result, path, recursive);
        else
            add_file(result, path);
        
    }
}

function main(var argv)
{
    using extern Getopt.Obj;
    var getopts = new 'Getopt::Obj';
    getopts.notOptStop(1);
    getopts.push_string('v');
    getopts.push_string('r');

    argv.shift();
    var opts = getopts.get_options(argv);
    int verbose = opts['v'];
    int recursive = opts['r'];

    string arg= argv[0];
    if (arg == '')
        argv.push('.');

    var args= new 'ResizableStringArray';
    build_file_list(args, argv, recursive);

    run_test_list(args, verbose);
}
