#! winxed
// ajax.winxed

// A simplified implementation of the W3C XMLHttpRequest specification.
// See: http://www.w3.org/TR/XMLHttpRequest/

//**********************************************************************

class XMLHttpRequest
{
    // Private
    // Internal usage variables and methods

    var ua;  // Parrot LWP;UserAgent
    // HTTP method, URL and async mode specified in open.
    var method;
    var url;
    var async;
    // Constants for readyState values
    const int UNSENT           = 0;
    const int OPENED           = 1;
    const int HEADERS_RECEIVED = 2;
    const int LOADING          = 3;
    const int DONE             = 4;

    function init [vtable]()
    {
        self.readyState = UNSENT;
        self.status = 0;
        self.responseText = '';
        using extern LWP.UserAgent;
    }

    function changeState(int state)
    {
        self.readyState=: state;
        var onreadystatechange = self.onreadystatechange;
        if (onreadystatechange != null)
            onreadystatechange();
    }

    // Public
    // Properties and methods defined by the specification.

    var readyState;
    var status;
    var responseText;
    var onreadystatechange;

    function open(string method, string url, int async)
    {
        self.async = async;
        string m = upcase(method);
        if (m != 'GET' && m != 'HEAD')
            throw Error("Unsupported method '" + method + "'");

        self.method = m;
        self.url = url;
        self.changeState(OPENED);
    }
    function send(var data)
    {
        if (self.readyState != OPENED)
            throw Error('INVALID_STATE_ERR');
        string url = self.url;

        if (self.async)
            self.changeState(OPENED);

        self.ua = new LWP.UserAgent();
        var nargs = {
            'Connection' : 'close'
        };
        var resp;
        switch (self.method) {
          case 'GET':
            resp = self.ua.get(url, nargs:[named,flat]);
            break;
          case 'HEAD':
            resp = self.ua.head(url, nargs:[named,flat]);
            break;
        }

        if (self.async)
            self.changeState(HEADERS_RECEIVED);
        if (self.async)
            self.changeState(LOADING);
        self.status =: resp.code();

        string rt = resp.content();

        // Temporary measure for chunked transfer encoding while LWP
        // does not handle it. If the data does not start with a
        // chunk length, assume that the problem is fixed and let
        // the data unchanged.
        var h = resp.headers();
        string s = h['Transfer-Encoding'];
        if (s == 'chunked') {
            int pos = indexof(rt, "\r\n");
            if (pos > 0) {
                string check = substr(rt, 0, pos);
                for (string c in check)
                    if (indexof('01234567890abcdefABCDEF', c) < 0)
                        pos = -1;
                if (pos > 0)  {
                    string more = rt;
                    rt = '';
                    // Each chunk header is the chunk length followed by
                    // CRLF end of line
                    while ((pos = indexof(more, "\r\n")) > 0) {
                        int chlen = pos + 2;
                        string sl = substr(more, 0, pos);
                        int l = sl.to_int(16);
                        // A chunk of length 0 signals the end
                        if (l == 0)
                            break;
                        rt += substr(more, chlen, l);
                        more = substr(more, chlen + l);
                    }
                    // Optional trailing HTTP headers ignored in this version
                }
            }
        }

        self.responseText = rt;

        self.changeState(DONE);
    }
}

//**********************************************************************

// main function for testing.

function main(var argv)
{
    const string optAsync  = 'async';
    const string optMethod = 'method';

    using extern Getopt.Obj;
    var getopts = new Getopt.Obj();
    getopts.notOptStop(1);
    getopts.push_string(optAsync);
    getopts.push_string(optMethod + '=s');
    argv.shift();
    var opts = getopts.get_options(argv);

    int use_async = false;
    string method;
    if (opts[optMethod] != null)
        method = opts[optMethod];
    else
        method = 'GET';
    if (opts[optAsync] != null)
        use_async = true;

    int argc = elements(argv);
    if (argc < 1)
        Error('No URL');

    var req = new XMLHttpRequest();

    if (use_async) {
        req.onreadystatechange = function()
        {
            say('Status changed to ', req.readyState);
            if (req.readyState == 4) {
                say('Status: ', req.status);
                say("Response:\n", req.responseText);
            }
        };
    }
    req.open(method, argv[0], use_async);
    req.send(null);
    if (! use_async)
        say("Response:\n", req.responseText);
}

// End
