#! winxed
// pirado.winxed
// Tests towards HLL-based pasm/pir compilers.

const int DEBUG = 0;

//**********************************************************************

const int PARROT_ARG_I         = 0x00;
const int PARROT_ARG_S         = 0x01;
const int PARROT_ARG_P         = 0x02;
const int PARROT_ARG_N         = 0x03;
const int PARROT_ARG_TYPE_MASK = 0x0F;
const int PARROT_ARG_CONSTANT  = 0x10;

function typearg(string rtype)
{
    switch (rtype) {
    case 'I': return PARROT_ARG_I;
    case 'S': return PARROT_ARG_S;
    case 'N': return PARROT_ARG_N;
    case 'P': return PARROT_ARG_P;
    default: return -1;
    }
}

//**********************************************************************

function iswhitespace(string c)
{
    return indexof(" \t\n", c) > -1;
}

function isdigit(string c)
{
    return indexof('0123456789', c) > -1;
}

function isidentstart(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_',
        c) > -1;
}

function isident(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_' +
        '0123456789',
        c) > -1;
}

function auxgetchar(string l)
{
    yield length(l);
    for (string c in l)
        yield c;
    for (;;)
        yield '';
}

//**********************************************************************

class Token
{
    var strval;
    var filename;
    var line;
    var pos;
    function isop(string opstr) { return 0; }
    function setstrval(var filepos, string val)
    {
        self.strval = val;
        self.filename = filepos[0];
        int line = filepos[1];
        self.line = line;
        int pos = filepos[2];
        self.pos = pos;
    }
    function debdump() {
        string s = self.strval;
        s = string(self.filename) + ':' + string(self.line) + ':' + string(self.pos) + ':' + s;
        return s;
    }
}

class TokenComment : Token
{
    function setcomment(var filepos)
    {
        self.setstrval(filepos, '# comment');
        return self;
    }
}

class TokenIdentifier : Token
{
    function setid(var filepos, string str)
    {
        self.setstrval(filepos, str);
        return self;
    }
    function getid() { return self.strval; }
}

class TokenInteger : Token
{
    function setint(var filepos, string str)
    {
        self.setstrval(filepos, str);
        return self;
    }
    function getint() { return int(self.strval); }
}

class TokenSingleQuoted : Token
{
    function setsquoted(var filepos, string str)
    {
        self.setstrval(filepos, str);
        return self;
    }
    function getstr() { return string(self.strval); }
}

class TokenRegister : Token
{
    var type;
    var num;
    function setregister(var filepos, string type, int num)
    {
        self.setstrval(filepos, '$' + type + string(num));
        self.type = type;
        self.num = num;
        return self;
    }
    function regtype() { return self.type; }
    function regnum() { return self.num; }
}

class TokenOperator : Token
{
    function setopname(var filepos, string str)
    {
        self.setstrval(filepos, str);
        return self;
    }
    function isop(string opstr)
    {
        return opstr == self.strval;
    }
}

//**********************************************************************

function ErrorAt(string msg, var token)
{
    throw Error(msg + ' at ' + string(token.debdump()));
}

//**********************************************************************

class Line
{
    var getchar_fun;
    var filename;
    var linenum;
    var pos;
    var pending;

    function getchar()
    {
        string c;
        var pending = self.pending;
        if (pending == null)
            throw Error('Line reader not initialized');
        if (elements(pending) > 0) {
            c = pending.pop();
        }
        else {
            var get = self.getchar_fun;
            if (get == null)
                throw Error('Line reader not initialized');
            c = get();
            if (c != '')
                self.pos++;
        }
        return c;
    }
    function ungetchar(string c)
    {
        if (length(c) > 0)
            self.pending.push(c);
    }
    function scancomment(var filepos)
    {
        string c;
        while ((c = self.getchar()) != "\n") ;
        return new TokenComment().setcomment(filepos);
    }
    function scannum(var filepos, string c)
    {
        string n = c;
        while (isdigit(c = self.getchar()))
            n += c;
        self.ungetchar(c);
        return new TokenInteger().setint(filepos, n);
    }
    function scanident(var filepos, string c)
    {
        string id = c;
        while (isident(c = self.getchar()))
            id += c;
        self.ungetchar(c);
        return new TokenIdentifier().setid(filepos, id);
    }
    function scanregister(var filepos)
    {
        string c = self.getchar();
        if (indexof("INSP", c) < 0)
            throw Error("Invalid register");
        string type = c;
        string strnum = '';
        while (isdigit(c = self.getchar()))
            strnum += c;
        if (strnum == '')
            throw Error("Invalid register number");
        int regnum = strnum;
        self.ungetchar(c);
        return new TokenRegister().setregister(filepos, type, regnum);
    }
    function scansinglequoted(var filepos)
    {
        string s;
        string c;
        while ((c = self.getchar()) != '' && c != "'")
            s += c;
        return new TokenSingleQuoted().setsquoted(filepos, s);
    }
    function scan()
    {
        var c;
        var tokenlist = [];
        while ((c = self.getchar()) != '') {
            if (iswhitespace(c)) continue;
            var filepos = [ self.filename, int(self.linenum), int(self.pos) ];
            switch (c) {
            case '#':
                tokenlist.push(self.scancomment(filepos));
                break;
            case "'":
                tokenlist.push(self.scansinglequoted(filepos));
                break;
            case '$':
                tokenlist.push(self.scanregister(filepos));
                break;
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                tokenlist.push(self.scannum(filepos, c));
                break;
            default:
                if (isidentstart(c))
                    tokenlist.push(self.scanident(filepos, c));
                else
                    tokenlist.push(new TokenOperator().setopname(filepos, c));
            }
        }
        return tokenlist;
    }
    function scanline(int linenum, string line)
    {
        using auxgetchar;
        var getchar_f = clone(auxgetchar);
        int n = getchar_f(line);
        var tokenlist;
        if (n) {
            self.getchar_fun = getchar_f;
            self.pending = [];
            self.linenum = linenum;
            self.pos = 0;
            tokenlist = self.scan();
            self.pending = null;
            self.getchar_fun = null;
        }
        return tokenlist;
    }
    function setfilename(string filename)
    {
        self.filename = filename;
    }
}

//**********************************************************************

class Generator
{

var segname;
var packfile;
var dir;
var constseg;
var byteseg;
var nextconst;
var nextcode;
var labels;

function initialize(string segname)
{
    var packfile = new 'Packfile';
    var dir = packfile.get_directory();
    var constseg = new 'PackfileConstantTable';
    int cstindex = 0;
    constseg[cstindex++] = getinterp();
    dir['CONSTANT_' + segname] = constseg;
    var byteseg = new 'PackfileRawSegment';

    self.segname = segname;
    self.packfile = packfile;
    self.dir = dir;
    self.constseg = constseg;
    self.byteseg = byteseg;
    self.nextconst = cstindex;
    self.nextcode = 0;
    self.labels = {};
}

function setlabel(string labelstr, int pos)
{
    if (DEBUG) say('set label ', labelstr, ' to ', pos);
    self.labels[labelstr] = pos;
}

function pushop(int opnum)
{
    int nextcode = self.nextcode;
    self.byteseg[nextcode++] = opnum;
    self.nextcode =: nextcode;
}

function pushconststring(string value)
{
    int nextconst = self.nextconst;
    int result = nextconst;
    self.constseg[nextconst++] = value;
    self.nextconst =: nextconst;
    return result;
}

function pushconstpmc(var value)
{
    int nextconst = self.nextconst;
    int result = nextconst;
    self.constseg[nextconst++] = value;
    self.nextconst =: nextconst;
    return result;
}

function parse(var tokenlist)
{
    var inst = tokenlist[0];
    int ntokens = elements(tokenlist);

    int curpos = self.nextcode;

    if (! (inst instanceof TokenIdentifier))
       throw Error('No instruction');
    string opname = inst.getid();

    if (ntokens == 2 && tokenlist[1].isop(':')) {
        var label = tokenlist[0];
        if (! (label instanceof TokenIdentifier))
            ErrotAt('Invalid label', label);
        self.setlabel(label.getid(), curpos);
    }
    else if (opname == 'goto') {
        // TESTING, ONLY BACKWARDS
        if (ntokens != 2) ErrorAt('Invalid goto', inst);
        int target = self.labels[tokenlist[1].getid()];
        var oplib = new 'OpLib';
        var branch = oplib['branch_ic'];
        self.pushop(int(branch));
        self.pushop(target - curpos);
    }
    else {
        var args = [];
        var argtype = [];
        for (int i = 1; i < ntokens; ++i) {
            var arg = tokenlist[i];
            if (i == 2 && (arg.isop(',')) )
                continue;
            int argt;
            if (arg instanceof TokenRegister)
                argt = typearg(arg.regtype());
            else if (arg instanceof TokenSingleQuoted)
                argt = PARROT_ARG_S | PARROT_ARG_CONSTANT;
            else if (arg instanceof TokenInteger)
                argt = PARROT_ARG_I | PARROT_ARG_CONSTANT;
            else
                ErrorAt('Invalid arg', arg);
            args.push(arg);
            argtype.push(argt);
        }

        int nargs = elements(args);
        var oplib = new 'OpLib';
        var ops = oplib.op_family(opname);
        if (ops == null)
            throw Error('No such op: ' + opname);
        int numops = ops;
        int iop;
        for (iop = 0; iop < numops; ++iop) {
            var op = ops[iop];
            if (nargs != elements(op) )
                continue;
            int i;
            for (i = 0; i < nargs; ++i) {
                int ptype = op[i];
                int atype = argtype[i];
                if (atype != ptype)
                    break;
            }
            if (i == nargs)
                break;
        }
        if (iop >= numops)
            ErrorAt('No op with that args', inst);
        var op = ops[iop];
        int opnum = op;
        if (DEBUG) say('<* ', iop, ':', opnum, ':', string(op), ' *>');
        self.pushop(opnum);

        for (int i = 0; i < nargs; ++i) {
            var arg = args[i];
            if (arg instanceof TokenRegister) {
                int regnum = arg.regnum();
                self.pushop(regnum);
            }
            else if (arg instanceof TokenSingleQuoted) {
                string sarg = arg.getstr();
                int cnum = self.pushconststring(sarg);
                self.pushop(cnum);
            }
            else if (arg instanceof TokenInteger) {
                int narg = arg.getint();
                self.pushop(narg);
            }
        }
    }
}

function writefile(string filename)
{
    string segname = self.segname;
    var dir = self.dir;
    dir['BYTECODE_' + segname] = self.byteseg;
    var fixups = new 'PackfileFixupTable';
    dir['FIXUP_' + segname] = fixups;

    // Temporary:
    // Create a sub just to be able to play with some registers.
    string fakename = 'fakemain';
    var fakesub = new 'Sub'({
        "name" : fakename,
        "subid" : fakename,
        "ns_entry_name" : fakename,
        "start_offs" : 0,
        "end_offs" : self.nextcode,
        "n_regs_used": [ 8, 8, 8, 8 ]
    });
    int fakeconst = self.pushconstpmc(fakesub);
    var fixupfake = new 'PackfileFixupEntry';
    fixupfake =: fakename;
    fixupfake =: fakeconst;
    fixupfake.set_type(2);
    fixups[0] = fixupfake;

    dir['BYTECODE_' + segname + '_ANN'] = new 'PackfileAnnotations';

    var packfile = self.packfile;
    string rawdata = packfile;
    if (DEBUG) say('About to write');
    var handle = new 'FileHandle'.open(filename, 'wb');
    if (DEBUG) say('Writing');
    handle.print(rawdata);
    handle.close();
    if (DEBUG) say('Done');
}

}

//**********************************************************************

function main(argv)
{
    string filename = argv[1];
    var l = new Line();
    l.setfilename(filename);
    var file = open(filename);
    var line;
    int numline = 0;

    var gen = new Generator();
    gen.initialize(filename);
    while ((line = file.readline()) != '') {
        ++numline;
        var tokenlist = l.scanline(numline, line);
        if (tokenlist != null && elements(tokenlist) > 0) {
            if (DEBUG) {
                for (var token in tokenlist)
                    print(token.debdump());
                say();
            }
            if (tokenlist[0] instanceof TokenComment)
                continue;
            gen.parse(tokenlist);
        }
    }

    string pbcfilename = filename;
    {
    int l = length(filename);
    if (l > 4 && substr(filename, l - 5) == '.pasm')
        pbcfilename = substr(pbcfilename, 0, l - 5);
    else if (l > 3 && substr(filename, l - 4) == '.pir')
        pbcfilename = substr(pbcfilename, 0, l - 4);
    pbcfilename += '.pbc';
    }

    if (DEBUG) say(pbcfilename);
    gen.writefile(pbcfilename);
}

// End
