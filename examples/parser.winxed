#! winxed

// parsing example

//*********************************************
//          Character test functions
//*********************************************

function isspace(string c)
{
    return c == ' ' || c == "\n" || c == "\t";
}

function isdigit(string c)
{
    return indexof('0123456789', c) > -1;
}

function isidentstart(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_',
        c) > -1;
}

function isident(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_' +
        '0123456789',
        c) > -1;
}


//*********************************************
//                Token
//*********************************************

const int TypeEof          = -1;
const int TypeComment      = 0;
const int TypeOp           = 1;
const int TypeQuoted       = 2;
const int TypeSingleQuoted = 3;
const int TypeIdentifier   = 4;
const int TypeInteger      = 5;
const int TypeFloat        = 6;

function TokenError(string msg, tk, int line)
{
   string sline= line;
   string file= tk.filename;
   string m= msg + ' in '+ file + ' line ' + sline;
   var ex= Error(m, 2, 555);
   return ex;
}

class Token
{
    var type;
    var str;
    var file;
    var line;
    function get_bool[vtable]()
    {
        return self.type != TypeEof;
    }
    function iseof()     { return self.type == TypeEof; }
    function iscomment() { return self.type == TypeComment; }
    function isint()     { return self.type == TypeInteger; }
    function isfloat()   { return self.type == TypeFloat; }
    function isstring()
    {
        return self.type == TypeQuoted || self.type == TypeSingleQuoted;
    }
    function isidentifier() { return self.type == TypeIdentifier; }
    function getidentifier()
    {
        if (self.type == TypeIdentifier)
            return self.str;
        else
            throw SyntaxError('Identifier expected', self);
    }
    function iskeyword(string name)
    {
        return self.type == TypeIdentifier && self.str == name;
    }
    function isop(string name)
    {
        return self.type == TypeOp && self.str == name;
    }

    function get_string[vtable]()
    {
        string str= self.str;
        switch (self.type) {
        case TypeQuoted:
            str= '"' + str + '"';
            break;
        case TypeSingleQuoted:
            str= "'" + str + "'";
            break;
        }
        return str;
    }
}

function newToken(int type, string s, var file, int line)
{
    var t= new Token();
    t.type= type; t.str= s; t.file= file; t.line= line;
    return t;
}

//*********************************************
//       Tokenizer auxiliar functions
//*********************************************

function getquoted(tk, string start, int line)
{
    string s;
    string c= tk.getchar();
    while (c != '"') {
        if (c == '' || c == "\n")
            throw TokenError('Unterminated string', tk, line);
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeQuoted, s, tk.filename, line);
}

function getsinglequoted(tk, string start, int line)
{
    string s;
    string c= tk.getchar();
    while (c != "'") {
        if (c == '' || c == "\n")
            throw TokenError('Unterminated string', tk, line);
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeSingleQuoted, s, tk.filename, line);
}

function getident(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
    while (isident(c)) {
        s+= c;
        c= tk.getchar();
    }
    tk.ungetchar(c);
    return newToken(TypeIdentifier, s, tk.filename, line);
}

function getnumber(tk, string start, int line)
{
    string s;
    string c = start;
    do {
        s+= c;
        c= tk.getchar();
    } while (isdigit(c));
    if (c == '.') {
        do {
            s+= c;
            c= tk.getchar();
        } while (isdigit(c));
        tk.ungetchar(c);
        return newToken(TypeFloat, s, tk.filename, line);
    }
    else {
        tk.ungetchar(c);
        return newToken(TypeInteger, s, tk.filename, line);
    }
}

function getlinecomment(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
    while (c != '' && c != "\n") {
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeComment, s, tk.filename, line);
}

function getcomment(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
next:
    while (c != '' && c != '*')
    { s+= c; c= tk.getchar(); }
    if (c == '')
        throw Error("Unclosed comment");
    c= tk.getchar();
    if (c == '')
        throw Error("Unclosed comment");
    if (c != '/')
    { s+= '*' + c; goto next; }
    s+= '*/';
    return newToken(TypeComment, s, tk.filename, line);
}

function getop(tk, string start, int line)
{
    string s= start;
    return newToken(TypeOp, s, tk.filename, line);
}

//*********************************************
//              Tokenizer
//*********************************************

class Tokenizer
{
    var h;
    var pending;
    var select;
    var stacked;
    var filename;
    var line;
    function init(handle, string filename)
    {
        self.h= handle;
        self.pending= new 'String';
        self.stacked= [];
        self.filename= filename;
        self.line= 1;
        var select = {
            '"': { '': getquoted },
            "'": { '': getsinglequoted },
            '=': { '=': getop },
            '+': { '+': getop, '=': getop },
            '-': { '-': getop, '=': getop },
            '|': { '|': getop },
            '&': { '&': getop },
            '<': { '<': getop, '=': getop },
            '>': { '>': getop, '=': getop },
            '!': { '=': getop },
            '%': { '%': getop },
            '/': { '/': getlinecomment, '*': getcomment },
            '#': { '': getlinecomment }
        };
        self.select= select;
    }
    function getchar()
    {
        string pending= self.pending;
        if (pending != '') {
            self.pending= '';
            return pending;
        }
        var h= self.h;
        string c= h.read(1);
        if (c == "\n") {
                int l=self.line;
                ++l;
                self.line= l;
        }
        return c;
    }
    function ungetchar(string c)
    {
        self.pending= c;
    }
    function get_token()
    {
        if (self.stacked) {
            var t= self.stacked.pop();
            return t;
        }
        string c= self.getchar();
        while (isspace(c))
                c= self.getchar();
        int line= self.line;
        if (c == '') {
            var t= new Token();
            t.type= TypeEof;
            return t;
        }
        if (isidentstart(c))
            return getident(self, c, line);
        if (isdigit(c))
            return getnumber(self, c, line);
        var select = self.select;
        var current= select[c];
        if (current) {
            string c2= self.getchar();
            var current2= current[c2];
            if (current2) {
                c+= c2;
                return current2(self, c, line);
            }
            else {
                self.ungetchar(c2);
                current2= current[''];
                if (current2)
                    return current2(self, c, line);
            }
        }
        return getop(self, c, line);
    }
    function get(int withcomments [optional])
    {
        var t= self.get_token();
        while (!t.iseof() && ! withcomments && t.iscomment() )
           t= self.get_token();
        return t;
    }
    function unget(t) { self.stacked.push(t); }
}

//*********************************************
//            Miniwinxed
//*********************************************

// This is a first step towards a possible bootstraped version.

function namespacekey(var path)
{
    string s = '.namespace [';
    string sep= " '";
    for (string n in path) {
        s+= sep;
        sep=" ; '";
        s+= n + "'";
    }
    s+= " ]";
    return s;
}

//*********************************************
//            Emit
//*********************************************

class Emit
{
    var handle;
    var file;
    var line;
    var pendingf;
    var pendingl;
    function initialize(var handle)
    {
        self.handle= handle;
        self.file= '';
        self.line= 0;
        self.pendingf= 0;
        self.pendingl= 0;
    }
    function updateannot()
    {
        if (self.pendingf) {
            self.handle.print(".annotate 'file', '");
            self.handle.print(self.file);
            self.handle.print("'");
            self.handle.print("\n");
            self.pendingf= 0;
        }
        if (self.pendingl) {
            self.handle.print(".annotate 'line', ");
            self.handle.print(self.line);
            self.handle.print("\n");
            self.pendingl= 0;
        }
    }
    function vprint(var args)
    {
        for (var s in args)
            self.handle.print(s);
    }
    function print(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
    }
    function say(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
        self.handle.print("\n");
    }
    function annotate(var t)
    {
        if (self.file != t.file) {
            self.file= t.file;
            self.pendingf= 1;
            self.line= 0;
        }
        if (self.line != t.line) {
            self.line= t.line;
            self.pendingl= 1;
        }
    }
    function comment(string s)
    {
        self.handle.print('# ' + s + "\n");
    }
}

//*********************************************
//       Auxiliary classes and functions
//*********************************************

function InternalError(string msg)
{
   var ex= Error(msg, 2, 555);
   throw ex;
}

function SyntaxError(string msg, var pos)
{
   string sline= pos.line;
   string file= pos.file;
   string m= msg + ' in '+ file + ' line ' + sline;
   var ex= Error(m, 2, 555);
   return ex;
}

class Item
{
    function isNamespace() { return 0; }
    function isClass() { return 0; }
}

function parseStatement(tk, owner)
{
    var t= tk.get();
    if (t.isop(';'))
        return new EmptyStatement();
    if (t.isop('{'))
        return new CompoundStatement().parse(tk, owner);
    if (t.iskeyword('using')) {
        var taux = tk.get();
        if (taux.iskeyword('extern'))
            return new ExternStatement().parse(tk, owner);
        else {
            tk.unget(taux);
            return new UsingStatement().parse(tk, owner);
        }
    }
    else if (t.iskeyword('var'))
        return new VarStatement().parse(tk, owner);
    else if (t.iskeyword('string'))
        return new StringStatement().parse(tk, owner);
    else if (t.iskeyword('int'))
        return new IntStatement().parse(tk, owner);
    else if (t.iskeyword('float'))
        return new FloatStatement().parse(tk, owner);
    else if (t.iskeyword('goto'))
        return new GotoStatement().parse(tk, owner);
    else if (t.iskeyword('if'))
        return new IfStatement().parse(tk, owner);
    else if (t.iskeyword('for'))
        return parseFor(t, tk, owner);
    else if (t.iskeyword('print')) {
        var c= new PrintStatement();
        tk.unget(t);
        c.parse(tk, owner);
        return c;
    }
    else if (t.iskeyword('say')) {
        var c= new SayStatement();
        tk.unget(t);
        c.parse(tk, owner);
        return c;
    }
    else if (t.isidentifier()) {
        var t2= tk.get();
        if (t2.isop(':'))
            return new LabelStatement().set(owner, t);
        tk.unget(t2);
    }
    tk.unget(t);
    return new ExprStatement().parse(tk, owner);
}

//*********************************************
//            Statement
//*********************************************

class Statement : Item
{
    var start;
    var owner;
    function isempty() { return 0; }
    function annotate(e)
    {
        e.annotate(self.start);
    }
    function createreg(string type)
    {
        return self.owner.createreg(type);
    }
    function tempreg(string type)
    {
        return self.owner.tempreg(type);
    }
    function freetemps()
    {
        self.owner.freetemps();
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function getlabel(name)
    {
        return self.owner.getlabel(name);
    }
    function createlabel(name)
    {
        return self.owner.createlabel(name);
    }
    function createvar(name, string type)
    {
        return self.owner.createvar(name, type);
    }
    function getvar(name)
    {
        return self.owner.getvar(name);
    }
}

class EmptyStatement : Statement
{
    function isempty() { return 0; }
    function emit(e)
    {
        // Do nothing
    }
}

//*********************************************
//            ExternStatement
//*********************************************

class ExternStatement
{
    var path;
    function parse(tk, owner)
    {
        string path[];
        do {
            var t= tk.get();
            string s= t.getidentifier();
            path.push(s);
        } while ((t= tk.get()).isop('.'));
        if (!t.isop(';'))
            throw SyntaxError("Expected ';'", t);
        self.path = path;
        return self;
    }
    function emit(e)
    {
        string file;
        string sep = '';
        for (string p in self.path) {
            file += sep;
            file += p;
            sep = '/';
        }
        e.say("load_bytecode '", file, ".pbc'");
    }
}

//*********************************************
//            UsingStatement
//*********************************************

class UsingStatement
{
    var path;
    function parse(tk, owner)
    {
        string path[];
        do {
            var t= tk.get();
            string s= t.getidentifier();
            path.push(s);
        } while ((t= tk.get()).isop('.'));
        if (!t.isop(';'))
            throw SyntaxError("Expected ';'", t);
        self.path = path;
        return self;
    }
    function emit(e)
    {
        var path = self.path;
        string name = path.pop();
        e.say('.local pmc ', name);
        e.print('get_hll_global ', name, ', ');
        int n = path;
        switch (n) {
        case 0:
            e.say("'", name, "'");
            break;
        default:
            e.print('[');
            string sep = '';
            for (string p in path) {
                e.print(sep, "'", p, "'");
                sep = '; ';
            }
            e.say(" ], '", name, "'");
        }
    }
}

//*********************************************
//            ExprStatement
//*********************************************

class ExprStatement : Statement
{
    var expr;
    function parse(tk, owner)
    {
        self.owner = owner;
        self.expr = parseExpr(tk, self);
        return self;
    }
    function emit(e)
    {
        var expr = self.expr;
        self.expr.emit_get(e);
    }
}

//*********************************************
//            VarContainer
//*********************************************

class VarContainer
{
    var locals;
    function init [vtable] ()
    {
        self.locals = new 'Hash';
    }
    function createvar(var name, string type)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist != null)
            throw SyntaxError("Redeclared '" + sname + "'", name);
        string reg= self.createreg(type);
        var descriptor= new 'Hash';
        descriptor['type'] = type;
        descriptor['reg'] = reg;
        descriptor['const']= 0;
        locals[sname]= descriptor;
        return reg;
    }
    function getvar(var name)
    {
        var locals= self.locals;
        string sname= name;
        var exist= locals[sname];
        if (exist == null)
            exist = self.owner.getvar(name);
        return exist;
    }
}

//*********************************************
//            BlockStatement
//*********************************************

// A BlockStatement is a Statement that can have local variables.

class BlockStatement : VarContainer, Statement
{
}

//*********************************************
//            Expr
//*********************************************

class Expr
{
    var owner;
    function issimple() { return 0; }
    function isintegerliteral() { return 0; }
    function isfloatliteral() { return 0; }
    function isstringliteral() { return 0; }
    function isidentifier() { return 0; }
    function emit_get(e)
    {
        string type = self.checkResult();
        string reg = self.owner.tempreg(type);
        self.emit(e, reg);
        return reg;
    }
}

class SimpleExpr : Expr
{
    function issimple() { return 1; }
}

//*********************************************

class StringLiteral : SimpleExpr
{
    var strval;
    function isstringliteral() { return 1; }
    function checkResult() { return 'S'; }
    function getPirString() { return self.strval; }
    function emit(e, result)
    {
        e.say('set ', result, ', ', self.getPirString());
    }
    function emit_get(e)
    {
        return self.getPirString();
    }
}

//*********************************************

class IntegerLiteral : SimpleExpr
{
    var numval;
    function isintegerliteral() { return 1; }
    function checkResult() { return 'I'; }
    function getIntegerValue()
    {
        string aux= self.numval;
        int i= aux;
        return i;
    }
    function emit(e, result)
    {
        e.say('set ', result, ', ', self.getIntegerValue());
    }
    function emit_get(e)
    {
        return self.getIntegerValue();
    }
}

//*********************************************

class FloatLiteral : SimpleExpr
{
    var numval;
    function isfloatliteral() { return 1; }
    function checkResult() { return 'N'; }
    function getFloatValue()
    {
        string aux= self.numval;
        var n= new 'Float';
        n =: aux;
        return n;
    }
    function emit(e, result)
    {
        var n= self.getFloatValue();
        e.say('set ', result, ', ', n);
    }
    function emit_get(e)
    {
        return self.getFloatValue();
    }
}

//*********************************************

class IdentifierExpr : SimpleExpr
{
    var name;
    function isidentifier() { return 1; }
    function checkResult()
    {
        var desc = self.owner.getvar(self.name);
        if (desc != null)
            return desc['type'];
        else
            return '';
    }
    function getIdentifier()
    {
        var name = self.name;
        var desc = self.owner.getvar(name);
        if (desc == null) {
            string sname = name;
            throw SyntaxError("Variable '" + sname + "' is not defined", name);
        }
        string s= desc['reg'];
        return s;
    }
    function emit(e, result)
    {
        e.annotate(self.name);
        e.say('set ', result, ', ', self.getIdentifier());
    }
    function emit_get(e)
    {
        return self.getIdentifier();
    }
}

//*********************************************

class OpPreIncExpr : Expr
{
    var start;
    var subexpr;

    function checkResult()
    {
        return self.subexpr.checkResult();
    }
    function set(owner, t, subexpr)
    {
        self.owner = owner;
        self.start = t;
        self.subexpr = subexpr;
        return self;
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        if (result != '')
            e.say('set ', result, ', ', reg);
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        e.annotate(self.start);
        e.say('inc ', reg);
        return reg;
    }
}

//*********************************************

class OpAssignExpr : Expr
{
    var start;
    var eleft;
    var eright;
    function checkResult()
    {
        if (self.eleft.isidentifier())
            return self.eleft.checkResult();
        else
            InternalError('Unimplemented');
    }
    function emit(e, result)
    {
        string reg = self.emit_get(e);
        e.annotate(self.start);
        e.say('set ', result, ', ', reg);
    }
    function emit_get(e)
    {
        e.annotate(self.start);
        string reg = self.eleft.emit_get(e);
        string reg2 = self.eright.emit_get(e);
        e.annotate(self.start);
        e.say('set ', reg, ', ', reg2);
        return reg;
    }
}

//*********************************************

class ComparatorBaseExpr : Expr
{
    var start;
    var eleft;
    var eright;
    function set(owner, t, eleft, eright)
    {
        self.owner = owner;
        self.start = t;
        self.eleft = eleft;
        self.eright = eright;
        return self;
    }
    function checkResult() { return 'I'; }
    function emit(e, result)
    {
        string rl = self.eleft.checkResult();
        string rr = self.eright.checkResult();
        string regl = self.eleft.emit_get(e);
        string regr = self.eright.emit_get(e);
        e.annotate(self.start);
        string aux;
        if (rl == 'N' || rr == 'N')
        {
            if (rl == 'I') {
                aux = self.owner.tempreg('N');
                e.say('set ', aux, ', ', regl);
                regl = aux;
            }
            if (rr == 'I') {
                aux = self.owner.tempreg('N');
                e.say('set ', aux, ', ', regr);
                regr = aux;
            }
        }
        self.emitop(e, result, regl, regr);
    }
}

//*********************************************

class OpEqualExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('iseq ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpNotEqualExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('isne ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpLessExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('islt ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpGreaterExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('isgt ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpLessEqualExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('isle ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpGreaterEqualExpr : ComparatorBaseExpr
{
    function emitop(e, string result, string regl, string regr)
    {
        e.say('isge ', result, ', ', regl, ', ', regr);
    }
}

//*********************************************

class OpAddExpr : Expr
{
    var start;
    var eleft;
    var eright;
    function checkResult()
    {
        string rl = self.eleft.checkResult();
        string rr = self.eright.checkResult();
        if (rl == 'S' && rr == 'S')
            return 'S';
        if (rl == 'N' && rr == 'N')
            return 'N';
        if (rl == 'I' && rr == 'N')
            return 'N';
        if (rl == 'N' && rr == 'I')
            return 'N';
        return 'I';
    }
    function emit(e, result)
    {
        string rleft = self.eleft.emit_get(e);
        string rright = self.eright.emit_get(e);
        if (self.checkResult() == 'S')
            e.say('concat ', result, ', ', rleft, ', ', rright);
        else
            e.say('add ', result, ', ', rleft, ', ', rright);
    }
}

//*********************************************

class OpMulExpr : Expr
{
    var start;
    var eleft;
    var eright;
    function checkResult()
    {
        if (self.eleft.checkResult() == 'I' && self.eright.checkResult() == 'I')
            return 'I';
        else
            return 'N';
    }
    function emit(e, result)
    {
        var eleft = self.eleft;
        var eright = self.eright;
        string rleft;
        string rright;
        int nleft;
        int nright;
        if ((!eleft.issimple()) || eleft.isidentifier()) {
            string rleft= self.owner.tempreg(self.checkResult());
            eleft.emit(e, rleft);
        }
        else {
            nleft= eleft.getIntegerValue();
            rleft= nleft;
        }
        if ((!eright.issimple()) || eright.isidentifier()) {
            string rright= self.owner.tempreg(self.checkResult());
            eright.emit(e, rright);
        }
        else {
            string type = eright.checkResult();
            switch(type) {
            case 'S':
                string rright= self.owner.tempreg(self.checkResult());
                eright.emit(e, rright);
                break;
            case 'I':
            default:
                nright= eright.getIntegerValue();
                rright= nright;
                break;
            }
        }
        e.say('mul ', result, ', ', rleft, ', ', rright);
    }
}

//*********************************************

class CallExpr : Expr
{
    var start;
    var funref;
    var args;

    function parse(tk, owner, start, subexp)
    {
        self.owner = owner;
        self.start = start;
        self.funref = subexp;
        self.args = [];
        var t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            do {
                var expr = parseExpr(tk, owner);
                self.args.push(expr);
            } while ((t = tk.get()).isop(','));
            if (! t.isop(')'))
                throw SyntaxError("Expected ')' or ','", t);
        }
        return self;
    }
    function checkResult() { return 'P'; }
    function emit(e, result)
    {
        var funref = self.funref;
        if (! funref.isidentifier())
            InternalError("Unsupported");
        string name = funref.name; // Internals abuse, provisional
        string argreg[];
        for (var arg in self.args) {
            string reg = arg.emit_get(e);
            argreg.push(reg);
        }
        e.annotate(self.start);
        e.print(name, '(');
        string sep = '';
        for (string a in argreg) {
            e.print(sep, a);
            sep = ', ';
        }
        e.say(')');
    }
}

//*********************************************

class ArrayExpr : Expr
{
    var start;
    var values;

    function parse(tk, owner, t)
    {
        self.owner = owner;
        self.start = t;
        self.values = [];
        var t = tk.get();
        if (! t.isop(']')) {
            tk.unget(t);
            do {
                var item = parseExpr(tk, owner);
                self.values.push(item);
            } while ((t= tk.get()).isop(','));
            if (!t.isop(']'))
                throw SyntaxError("Expected ']' or ','", t);
        }
        return self;
    }
    function emit_get(e)
    {
        e.annotate(self.start);
        string container = self.owner.tempreg('P');
        e.say('root_new ', container, ", ['parrot';'ResizablePMCArray']");
        string it_p = self.owner.tempreg('P');
        string itemreg;
        for (var item in self.values) {
            string type = item.checkResult();
            switch (type) {
            case 'I': case 'N': case 'S':
                string aux = item.emit_get(e);
                e.say('box ', it_p, ', ', aux);
                itemreg = it_p;
                break;
            default:
                itemreg = item.emit_get(e);
            }
            e.annotate(self.start);
            e.say(container, ".'push'(", itemreg, ")");
        }
        return container;
    }
}

//*********************************************

function parseExpr_0(tk, owner)
{
    var t= tk.get();
    var expr;
    if (t.isop('(')) {
        expr = parseExpr(tk, owner);
        t= tk.get();
        if (!t.isop(')'))
            throw SyntaxError("Expected ')'", t);
        return expr;
    }
    if (t.isop('[')) {
        return new ArrayExpr().parse(tk, owner, t);
    }
    if (t.isstring()) {
        expr= new StringLiteral();
        expr.owner= owner;
        expr.strval= t;
        return expr;
    }
    if (t.isint()) {
        expr= new IntegerLiteral();
        expr.owner= owner;
        expr.numval= t;
        return expr;
    }
    if (t.isfloat()) {
        expr= new FloatLiteral();
        expr.owner= owner;
        expr.numval= t;
        return expr;
    }
    if (t.isidentifier()) {
        expr= new IdentifierExpr();
        expr.owner= owner;
        expr.name= t;
        return expr;
    }
    throw SyntaxError('Lots of things unsupported', t);
}

function parseExpr_2(tk, owner)
{
    var subexp = parseExpr_0(tk, owner);
    var t = tk.get();
    if (t.isop('('))
        subexp = new CallExpr().parse(tk, owner, t, subexp);
    else
        tk.unget(t);
    return subexp;
}

function parseExpr_4(tk, owner)
{
    var t = tk.get();
    if (t.isop('++')) {
        var subexpr = parseExpr_4(tk, owner);
        return new OpPreIncExpr().set(owner, t, subexpr);
    }
    else {
        tk.unget(t);
        return parseExpr_2(tk, owner);
    }
}

function parseExpr_5(tk, owner)
{
    var eleft= parseExpr_4(tk, owner);
    var t;
    while ((t= tk.get()).isop('*')) {
        var eright= parseExpr_4(tk, owner);
        var expr= new OpMulExpr();
        expr.owner= owner;
        expr.start= t;
        expr.eleft= eleft;
        expr.eright= eright;
        eleft= expr;
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_6(tk, owner)
{
    var eleft= parseExpr_5(tk, owner);
    var t;
    while ((t= tk.get()).isop('+')) {
        var eright= parseExpr_5(tk, owner);
        var expr= new OpAddExpr();
        expr.owner= owner;
        expr.start= t;
        expr.eleft= eleft;
        expr.eright= eright;
        eleft= expr;
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_8(tk, owner)
{
    var eleft = parseExpr_6(tk, owner);
    var t;
    while ((t= tk.get()).isop('==') || t.isop('!=')) {
        var eright = parseExpr_6(tk, owner);
        if (t.isop('=='))
            eleft = new OpEqualExpr().set(owner, t, eleft, eright);
        else
            eleft = new OpNotEqualExpr().set(owner, t, eleft, eright);
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_9(tk, owner)
{
    var eleft = parseExpr_8(tk, owner);
    var t;
    while ((t= tk.get()).isop('<') || t.isop('>') || t.isop('<=') || t.isop('>=')) {
        var eright = parseExpr_8(tk, owner);
        if (t.isop('<'))
            eleft = new OpLessExpr().set(owner, t, eleft, eright);
        else if (t.isop('>'))
            eleft = new OpGreaterExpr().set(owner, t, eleft, eright);
        else if (t.isop('<='))
            eleft = new OpLessEqualExpr().set(owner, t, eleft, eright);
        else
            eleft = new OpGreaterEqualExpr().set(owner, t, eleft, eright);
    }
    tk.unget(t);
    return eleft;
}

function parseExpr_16(tk, owner)
{
    var subexpr = parseExpr_9(tk, owner);
    var t= tk.get();
    while (t.isop('=')) {
        var subexpr2 = parseExpr_16(tk, owner);
        var expr = new OpAssignExpr();
        expr.owner= owner;
        expr.start= t;
        expr.eleft= subexpr;
        expr.eright= subexpr2;
        subexpr = expr;
        t= tk.get();
    }
    tk.unget(t);
    return subexpr;
}

function parseExpr(tk, owner)
{
    return parseExpr_16(tk, owner);
}

//*********************************************
//            PrintStatement
//*********************************************

// This is a temporal way to be enable generation
// of some working and viewable code.

class PrintStatement : Statement
{
    var items;
    function parse(tk, owner)
    {
        self.owner= owner;
        self.items= [];
        self.start= tk.get();
        var t= tk.get();
        if (! t.isop('('))
            throw SyntaxError("Expected '('", t);
        t= tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            do {
                var exp= parseExpr(tk, self);
                self.items.push(exp);
            } while ((t= tk.get()).isop(','));
            if (! t.isop(')'))
                throw SyntaxError("Expected ')'", t);
        }
        t= tk.get();
        if (! t.isop(';'))
            throw SyntaxError("Expected ';'", t);
    }
    function emit_print(e)
    {
        for (var item in self.items) {
            var expr= item;
            string result = expr.emit_get(e);
            self.annotate(e);
            e.say("print ", result);
        }
    }
    function emit(e)
    {
        self.emit_print(e);
    }
}

class SayStatement : PrintStatement
{
    function emit(e)
    {
        self.emit_print(e);
        e.say('print "\n"');
    }
}

//*********************************************
//            LabelStatement
//*********************************************

class LabelStatement : Statement
{
    var name;
    var value;
    function set(owner, n)
    {
        self.owner= owner;
        self.start= n;
        self.name= n;
        string value= self.owner.createlabel(n);
        self.value= value;
        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        e.say(self.value, ': # label ', self.name);
    }
}

//*********************************************
//            GotoStatement
//*********************************************

class GotoStatement : Statement
{
    var label;
    function parse(tk, owner)
    {
        self.owner= owner;
        var t= tk.get();
        if (!t.isidentifier())
            throw SyntaxError('Identifier expected', t);
        self.start= t;
        string s= t;
        self.label= t;
        t= tk.get();
        if (!t.isop(';'))
            throw SyntaxError("Expected ';'", t);
        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        string value= self.getlabel(self.label);
        e.say('goto ', value, ' # goto ', self.label);
    }
}

//*********************************************
//            IfStatement
//*********************************************

class IfStatement : Statement
{
    var condition;
    var truebranch;
    var falsebranch;
    function parse(tk, owner)
    {
        self.owner= owner;
        var t= tk.get();
        if (!t.isop('('))
            throw SyntaxError("Expected '('", t);
        self.start = t;
        self.condition = parseExpr(tk, self);
        t= tk.get();
        if (! t.isop(')'))
            throw SyntaxError("Expected ')'", t);
        self.truebranch = parseStatement(tk, self);
        t = tk.get();
        if (t.iskeyword("else"))
            self.falsebranch = parseStatement(tk, self);
        else {
            self.falsebranch = new EmptyStatement();
            tk.unget(t);
        }
        return self;
    }
    function emit(e)
    {
        string elselabel = '';
        if (! self.falsebranch.isempty())
            elselabel = self.genlabel();
        string endlabel = self.genlabel();
        string cond_false;
        if (elselabel == '')
            cond_false = endlabel;
        else
            cond_false = elselabel;
        self.annotate(e);
        var condition = self.condition;
        string type = condition.checkResult();
        string reg = self.tempreg(type);
        condition.emit(e, reg);
        switch(type) {
        case 'S':
        case 'P':
            e.say('if_null ', reg, ', ', cond_false);
        case 'I':
        case 'N':
            e.say('unless ', reg, ' goto ', cond_false);
            break;
        default:
            InternalError('Invalid if condition');
        }
        self.truebranch.emit(e);
        if (! self.falsebranch.isempty()) {
            e.say('goto ', endlabel);
            e.say(elselabel, ': #else');
            self.falsebranch.emit(e);
        }
        e.say(endlabel, ': # endif');
    }
}

//*********************************************
//            ForeachStatement
//*********************************************

class ForeachStatement : BlockStatement
{
    var varname;
    var container;
    var body;

    function parse(t, tk, owner)
    {
        self.start = t;
        self.owner = owner;
        var name = tk.get();
        string sname = name;
        string type = '';
        switch (sname)
        {
        case 'int':
            type = 'I'; break;
        case 'float':
            type = 'N'; break;
        case 'string':
            type = 'S'; break;
        case 'var':
            type = 'P'; break;
        }
        if (type != '') {
            name = tk.get();
            sname = name;
            self.createvar(sname, type);
        }
        var aux= tk.get();
        self.varname = name;
        self.container = parseExpr(tk, self);
        var aux = tk.get();
        if (!aux.isop(')'))
            throw SyntaxError("Expected ')'", aux);
        self.body = parseStatement(tk, self);

        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        string regcont = self.container.emit_get(e);
        var itvar = self.getvar(self.varname);
        string iterator = self.createreg('P');
        string continuelabel = self.genlabel();
        string breaklabel = self.genlabel();
        e.say('iter ', iterator, ', ', regcont);
        e.say('set ', iterator, ', 0');
        e.say(continuelabel, ': # for iteration');
        e.say('unless ', iterator, " goto ", breaklabel);
        e.say('shift ', itvar['reg'], ', ', iterator);
        self.body.emit(e);
        e.say('goto ', continuelabel);
        e.say(breaklabel, ': # endfor');
    }
}

//*********************************************

function parseFor(t, tk, owner)
{
    var paren = tk.get();
    if (!paren.isop('('))
        throw SyntaxError("Expected '('", paren);
    var aux = tk.get();
    var in1 = tk.get();
    var in2 = tk.get();
    if (in1.iskeyword('in') || in2.iskeyword('in')) {
        tk.unget(in2);
        tk.unget(in1);
        tk.unget(aux);
        return new ForeachStatement().parse(t, tk, owner);
    }
    throw SyntaxError('Unimplemented', t);
}

//*********************************************
//            DeclareStatement
//*********************************************

class DeclareStatement : Statement
{
    var name;
    var t_reg;
    var t_name;
    var reg;
    var init;
    function parse(tk, owner)
    {
        self.owner= owner;
        var t= tk.get();
        if (!t.isidentifier())
            throw SyntaxError('Identifier expected', t);
        self.name= t;
        string reg= self.createvar(t, self.t_reg);
        self.reg= reg;
        t= tk.get();
        if (t.isop('=')) {
            self.init = parseExpr(tk, self);
            t= tk.get();
        }
        if (!t.isop(';'))
            throw SyntaxError("Expected ';'", t);
        return self;
    }
    function emit(var e)
    {
        e.annotate(self.name);
        string tname = self.t_name;
        string name = self.name;
        string reg = self.reg;
        e.comment(tname + ' ' + name + ': ' + reg);
        if (self.init != null) {
            string itype = self.init.checkResult();
            if (itype == self.t_reg)
                self.init.emit(e, reg);
            else {
                string ireg = self.tempreg(itype);
                self.init.emit(e, ireg);
                e.say('set ', reg, ', ', ireg);
            }
        }
        else
            self.defaultinit(e);
    }
    function defaultinit(var e)
    {
        InternalError('DeclareStatement.defaultinit must be overriden');
    }
}

//*********************************************
//            VarStatement
//*********************************************

class VarStatement : Statement
{
    var name;
    var reg;
    var init;
    function parse(tk, owner)
    {
        self.owner= owner;
        var t= tk.get();
        if (!t.isidentifier())
            throw SyntaxError('Identifier expected', t);
        self.name= t;
        string reg= self.createvar(t, 'P');
        self.reg= reg;
        t= tk.get();
        if (t.isop('=')) {
            self.init = parseExpr(tk, self);
            t= tk.get();
        }
        if (!t.isop(';'))
            throw SyntaxError("Expected ';'", t);
        return self;
    }
    function emit(var e)
    {
        e.annotate(self.name);
        string name=  self.name;
        string reg = self.reg;
        e.comment('var ' + name + ': ' + reg);
        if (self.init != null) {
            string type = self.init.checkResult();
            switch (type) {
            case 'P':
                self.init.emit(e, reg);
                break;
            case 'S':
            case 'I':
            case 'N':
                string value = self.tempreg(type);
                self.init.emit(e, value);
                e.say('box ', reg, ', ', value);
                break;
            default:
                throw SyntaxError("Invalid var initializer", self.name);
            }
        }
        else
            e.say('null ', reg);
    }
}

//*********************************************
//            StringStatement
//*********************************************

class StringStatement : DeclareStatement
{
    function init [vtable] ()
    {
        self.t_reg = 'S';
        self.t_name = 'string';
    }
    function defaultinit(var e)
    {
        e.say('null ', self.reg);
    }
}

//*********************************************
//            IntStatement
//*********************************************

class IntStatement : DeclareStatement
{
    function init [vtable] ()
    {
        self.t_reg = 'I';
        self.t_name = 'int';
    }
    function defaultinit(var e)
    {
        e.say('set ', self.reg, ', 0');
    }
}

//*********************************************
//            FloatStatement
//*********************************************

class FloatStatement : DeclareStatement
{
    function init [vtable] ()
    {
        self.t_reg = 'N';
        self.t_name = 'float';
    }
    function defaultinit(var e)
    {
        e.say('set ', self.reg, ', 0.0');
    }
}

//*********************************************
//            CompoundStatement
//*********************************************

class CompoundStatement : BlockStatement
{
    var statements;
    var end;
    var labels;
    //var locals;

    function init [vtable] ()
    {
        self.labels= new 'Hash';
    }
    function getlabel(var name)
    {
        string s= name;
        var labels= self.labels;
        string exist= labels[s];
        if (exist == null || exist == '')
            exist = self.owner.getlabel(name);
        return exist;
    }
    function createlabel(var name)
    {
        string s= name;
        var labels= self.labels;
        string exist= labels[s];
        if (exist != null && exist != '')
            throw SyntaxError('Label already defined', name);
        string value= self.genlabel();
        labels[s]= value;
        return value;
    }
    function parse(tk, owner)
    {
        //say('<<{');
        self.owner= owner;
        self.statements= [];
        var t;
        while (! (t= tk.get()).isop('}')) {
            tk.unget(t);
            //say (t.line);
            var c = parseStatement(tk, self);
            if (c == null) {
                while (! ( (t = tk.get()).isop(';') || t.isop('}') ) ) {
                    //say('-- ', t);
                    if (t.isop('{')) {
                        var c= new CompoundStatement();
                        c.parse(tk, self);
                    }
                }
                if (t.isop('}')) break;
            }
            else
                self.statements.push(c);
        }
        //say('}', t.line);
        self.end= t;
        return self;
    }
    function getend() { return self.end; }
    function report()
    {
    }
    function emit(var e)
    {
        e.comment('{');
        for (var st in self.statements) {
            st.emit(e);
            self.freetemps();
        }
        e.comment('}');
    }
}

//*********************************************
//            RegisterStore
//*********************************************

class RegisterStore
{
    var type;
    var nreg;
    var tempreg;
    var freereg;
    function init [vtable]()
    {
        self.nreg = 0;
        self.tempreg= new 'ResizableStringArray';
        self.freereg= new 'ResizableStringArray';
    }
    function settype(string type)
    {
        self.type = type;
        return self;
    }
    function createreg()
    {
        var n = self.nreg;
        int i = n;
        string reg= i++;
        n =: i;
        string type = self.type;
        reg = '$' + type + reg;
        return reg;
    }
    function tempreg()
    {
        var freg = self.freereg;
        var treg = self.tempreg;
        int n= freg;
        string reg;
        if (n > 0)
            reg= freg.pop();
        else {
            reg= self.createreg();
            treg.push(reg);
        }
        return reg;
    }
    function freetemps()
    {
        for (string s in self.tempreg)
            self.freereg.unshift(s);
    }
}

//*********************************************
//            FunctionStatement
//*********************************************

class FunctionStatement : BlockStatement
{
    var owner;
    var name;
    var modifiers;
    var args;
    var body;
    var regstI;
    var regstN;
    var regstS;
    var regstP;
    var nlabel;

    function init [vtable]()
    {
        self.regstI = new RegisterStore().settype('I');
        self.regstN = new RegisterStore().settype('N');
        self.regstS = new RegisterStore().settype('S');
        self.regstP = new RegisterStore().settype('P');
        self.nlabel= 0;
    }
    function createreg(string type)
    {
        var store;
        switch(type)
        {
        case 'I':
            store = self.regstI; break;
        case 'N':
            store = self.regstN; break;
        case 'S':
            store = self.regstS; break;
        case 'P':
            store = self.regstP; break;
        default:
            InternalError('Invalid type in createreg');
        }
        string reg = store.createreg();
        return reg;
    }
    function tempreg(string type)
    {
        var store;
        switch(type)
        {
        case 'I':
            store = self.regstI; break;
        case 'N':
            store = self.regstN; break;
        case 'S':
            store = self.regstS; break;
        case 'P':
            store = self.regstP; break;
        default:
            InternalError('Invalid type in tempreg');
        }
        string reg = store.tempreg();
        return reg;
    }
    function freetemps()
    {
        for (var st in [ self.regstI, self.regstN, self.regstS, self.regstP ] )
            st.freetemps();
    }
    function genlabel()
    {
        var nlabel = self.nlabel;
        int n= nlabel;
        string s= '__label_' + n++;
        nlabel =: n;
        return s;
    }

    function parse(tk, owner)
    {
        self.owner= owner;
        var t= tk.get();
        self.name= t;
        t= tk.get();
        if (t.isop('['))
        {
            var modifiers= [];
            t= tk.get();
            modifiers.push(t);
            for (t= tk.get(); t.isop(','); )
            {
                t= tk.get();
                modifiers.push(t);
            }
            if (!t.isop(']'))
                throw Error("Expected ',' or ']'");
            t= tk.get();
            self.modifiers= modifiers;
        }
        if (! t.isop('('))
            throw Error("Expected '('");
        self.args = new 'ResizableStringArray';
        t= tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            do {
                t= tk.get();
                string s = t;
                self.args.push(s);
                self.createvar(s, 'P');
                t= tk.get();
            } while (t.isop(','));
            if (!t.isop(')'))
                throw Error("Expected ')'");
        }

        t= tk.get();
        if (!t.isop('{'))
            throw Error("Expected '{'");
        self.body= new CompoundStatement().parse(tk, self);
        return self;
    }

    function report()
    {
        print('function ', self.name);
        var modifiers= self.modifiers;
        if (modifiers)
        {
            print(' [');
            var m;
            string sep= '';
            for (m in modifiers)
            {
                print(sep);
                sep= ', ';
                print(m);
            }
            print(']');
        }
        say(' ()');
    }
    function emit(var e)
    {
        string name = self.name;
        e.print('.sub ', name);
        if (self.owner.isClass())
            e.print(' :method');
        var modifiers= self.modifiers;
        if (modifiers) {
            for (var m in modifiers)
                e.print(' :', m);
        }
        e.say();
        e.annotate(self.name);
        var arg;
        for (arg in self.args)
            say('.param pmc ', arg);
        for (arg in self.args) {
            var a = self.getvar(arg);
            say('set ', a['reg'], ', ', arg);
        }

        e.comment('Body');
        self.body.emit(e);

        e.annotate(self.body.getend());
        e.say('.end # ', name);
    }
}

//*********************************************
//            ClassStatement
//*********************************************

class ClassStatement : Item
{
    var parent;
    var name;
    var bases;
    var functions;

    function isClass() { return 1; }
    function init [vtable] ()
    {
        self.functions = [];
        self.bases= [];
    }

    function parse(tk, parent)
    {
        self.parent= parent;
        var t= tk.get();
        self.name= t;
        t= tk.get();
        if (t.isop(':')) {
            var bases= self.bases;
            for (;;) {
                t= tk.get();
                bases.push(t);
                t= tk.get();
                if (!t.isop(',')) break;
            }
        }
        if (!t.isop('{'))
            throw Error("Expected '{'");
        t= tk.get();
        while (!t.isop('}'))
        {
            if (t.iskeyword('function'))
            {
                var f= new FunctionStatement().parse(tk, self);
                var functions= self.functions;
                functions.push(f);
            }
            t= tk.get();
        }
    }

    function report()
    {
        print('class ', self.name);
        string sep= ' : ';
        for (var b in self.bases) {
            print (sep, b);
            sep= ' ,';
        }
        say(' {');
        for (var f in self.functions)
            f.report();
        say('}');
    }
    function emit(var e)
    {
        var classns= self.parent.getpath();
        classns.push(self.name);
        say(namespacekey(classns));
        for (var f in self.functions)
            f.emit(e);
    }
}

//*********************************************
//            Namespace
//*********************************************

class Namespace : Item
{
    var parent;
    var name;
    var namespaces;
    var classes;
    var functions;
    var items;

    function isNamespace() { return 1; }
    function init [vtable] ()
    {
        self.namespaces= [];
        self.classes= [];
        self.functions = [];
        self.items = [];
    }
    function init_child(parent, string name)
    {
        self.parent= parent;
        self.name= name;
    }
    function getpath()
    {
        if (self.parent != null) {
            var path=self.parent.getpath();
            path.push(self.name);
            return path;
        }
        else
        {
            string path[];
            return path;
        }
    }
    function getvar(name)
    {
        // Nothing for a now.
        return null;
    }
    function parse(tk)
    {
        string namespace[];
        int balance1= 0;
        int balance2= 0;
        int balance3= 0;
        var t;
        while (t= tk.get())
        {
            if (t.iskeyword('namespace'))
            {
                t= tk.get();
                string name= t;
                namespace.push(name);
                t= tk.get();
                if (!t.isop('{'))
                    throw Error("Expected '{'");
                var child= new Namespace();
                child.init_child(self, name);
                self.namespaces.push(child);
                self.items.push(child);
                child.parse(tk);
            }
            else if (t.iskeyword('function'))
            {
                var f= new FunctionStatement();
                f.parse(tk, self);
                var functions= self.functions;
                functions.push(f);
                self.items.push(f);
            }
            else if (t.iskeyword('class'))
            {
                var c= new ClassStatement();
                c.parse(tk, self);
                var classes= self.classes;
                classes.push(c);
                self.items.push(c);
            }
            else if (t.isop('}'))
            {
                int n= namespace;
                if (n < 1)
                {
                    if (self.parent != null) return;
                    string line= t.line;
                    throw Error('Unclosed namespace in ' + line);
                }
                namespace.pop();
            }
        }
    }
    function report()
    {
        if (self.parent != null)
            say('namespace ', self.name, ' {');
        for (var n in self.namespaces)
            n.report();
        for (var c in self.classes)
            c.report();
        for (var f in self.functions)
            f.report();
        if (self.parent != null)
            say('} // namespace ', self.name);
    }
    function emit(var e)
    {
        var path= self.getpath();
        string s= namespacekey(path);

        int activate= 1;
        for (var item in self.items) {
            if (item.isNamespace() || item.isClass())
                activate= 1;
            else
                if (activate) {
                    e.say(s);
                    activate= 0;
                }
            item.emit(e);
        }
    }
}

//*********************************************
//            MiniWinxed
//*********************************************

class MiniWinxed
{
    var rootns;
    function init [vtable] ()
    {
        self.rootns= new Namespace();
    }
    function parse(tk)
    {
        self.rootns.parse(tk);
    }
    function report()
    {
        self.rootns.report();
    }
    function emit(var e)
    {
        self.rootns.emit(e);
    }
}

function miniwinxed_parser(tk, int gen)
{
        var winxed= new MiniWinxed();
        winxed.parse(tk);
        if (gen) {
            var handle= getinterp().stdhandle(1);
            var emit= new Emit();
            emit.initialize(handle);
            winxed.emit(emit);
        }
        else
            winxed.report();
}

//*********************************************
//            Main functions
//*********************************************

function parser(argv)
{
    // Simple example, get tokens and prints them.

    using extern Getopt.Obj;
    var getopts = new 'Getopt::Obj';
    getopts.notOptStop(1);
    getopts.push_string('withcomments');
    getopts.push_string('miniwinxed');
    getopts.push_string('miniwinxedgen');

    argv.shift();
    var opts = getopts.get_options(argv);
    var withcomments= opts['withcomments'];
    var miniwinxed = opts['miniwinxed'];
    var miniwinxedgen = opts['miniwinxedgen'];

    int argc= argv;
    if (argc == 0)
        throw Error('No file');
    string filename= argv[0];
    var file= new 'FileHandle';
    file.open(filename); // Must throw on error

    var t= new Tokenizer();
    t.init(file, filename);

    if (miniwinxed)
        miniwinxed_parser(t, 0);
    else if (miniwinxedgen)
        miniwinxed_parser(t, 1);    
    else
    {
        var c;
        int line= 0;
        while (c= t.get(withcomments))
        {
            int newline= c.line;
            if (newline != line)
            {
                line= newline;
                say(); print(line, ': ');
            }
            print(" [", c, "]");
        }
        say('');
    }

    file.close();
}

function main(argv)
{
    try [handle_types(555)]
        parser(argv);
    catch (e)
    {
        string msg= e['message'];
        say('Error: ', msg);
        var bt= e.backtrace();
        int i= 1;
        for (var t in bt) {
            var sub= t['sub'];
            if (sub != null) {
                string subname= sub;
                string ns= sub.get_namespace();
                if (ns != '' && ns != 'parrot') subname= ns + '.' + subname;
            }
            var ann= t['annotations'];
            string file= ann['file'];
            if (file != '') {
                int line= ann['line'];
                say(' ' * (2 * i++), "at ", subname, " in '", file, "' line ", line);
            }
        }
    }
}

// End
