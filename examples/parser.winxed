#! winxed

// parsing example

//*********************************************
//          Character test functions
//*********************************************

function isspace(string c)
{
    return c == ' ' || c == "\n" || c == "\t";
}

function isidentstart(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_',
        c) > -1;
}

function isident(string c)
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_' +
        '0123456789',
        c) > -1;
}

//*********************************************
//                Token
//*********************************************

const int TypeEof          = -1;
const int TypeComment      = 0;
const int TypeOp           = 1;
const int TypeQuoted       = 2;
const int TypeSingleQuoted = 3;
const int TypeIdentifier   = 4;

class Token
{
    var type;
    var str;
    var line;
    function get_bool[vtable]()
    {
        return self.type == TypeEof;
    }
    function iseof()
    {
        return self.type == TypeEof;
    }
    function iscomment() { return self.type == 0; }
    function iskeyword(string name)
    {
        return self.type == TypeIdentifier && self.str == name;
    }
    function isop(string name)
    {
        return self.type == TypeOp && self.str == name;
    }

    function get_string[vtable]()
    {
        string str= self.str;
        switch (self.type)
        {
        case TypeQuoted:
            str= '"' + str + '"';
            break;
        case TypeSingleQuoted:
            str= "'" + str + "'";
            break;
        }
        return str;
    }
}

function newToken(int type, string s, int line)
{
    var t= new Token;
    t.type= type; t.str= s; t.line= line;
    return t;
}

//*********************************************
//       Tokenizer auxiliar functions
//*********************************************

function getquoted(tk, string start, int line)
{
    string s;
    string c= tk.getchar();
    while (c != '"')
    {
        if (c == '' || c == "\n")
            throw Error('Unterminated string in ' + line);
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeQuoted, s, line);
}

function getsinglequoted(tk, string start, int line)
{
    string s;
    string c= tk.getchar();
    while (c != "'")
    {
        if (c == '' || c == "\n")
            throw Error('Unterminated string in ' + line);
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeSingleQuoted, s, line);
}

function getident(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
    while (isident(c))
    {
        s+= c;
        c= tk.getchar();
    }
    tk.ungetchar(c);
    return newToken(TypeIdentifier, s, line);
}

function getlinecomment(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
    while (c != '' && c != "\n")
    {
        s+= c;
        c= tk.getchar();
    }
    return newToken(TypeComment, s, line);
}

function getcomment(tk, string start, int line)
{
    string s= start;
    string c= tk.getchar();
next:
    while (c != '' && c != '*')
    { s+= c; c= tk.getchar(); }
    if (c == '')
        throw Error("Unclosed comment");
    c= tk.getchar();
    if (c == '')
        throw Error("Unclosed comment");
    if (c != '/')
    { s+= '*' + c; goto next; }
    s+= '*/';
    return newToken(TypeComment, s, line);
}

function getop(tk, string start, int line)
{
    string s= start;
    var t= new Token;
    return newToken(TypeOp, s, line);
}

//*********************************************
//              Tokenizer
//*********************************************

class Tokenizer
{
    var h;
    var pending;
    var select;
    var line;
    function init(handle)
    {
        self.h= handle;
        self.pending= new 'String';;
        self.line= 1;
        var select = {
            '"': { '': getquoted },
            "'": { '': getsinglequoted },
            '=': { '=': getop },
            '+': { '+': getop, '=': getop },
            '-': { '-': getop, '=': getop },
            '|': { '|': getop },
            '&': { '&': getop },
            '<': { '<': getop, '=': getop },
            '>': { '>': getop, '=': getop },
            '!': { '=': getop },
            '/': { '/': getlinecomment, '*': getcomment },
            '#': { '': getlinecomment }
        };
        self.select= select;
    }
    function getchar()
    {
        string pending= self.pending;
        if (pending != '')
        {
            self.pending= '';
            return pending;
        }
        var h= self.h;
        string c= h.read(1);
        if (c == "\n")
        {
                int l=self.line;
                ++l;
                self.line= l;
        }
        return c;
    }
    function ungetchar(string c)
    {
        self.pending= c;
    }
    function get_token()
    {
        string c= self.getchar();
        while (isspace(c))
                c= self.getchar();
        int line= self.line;
        if (c == '')
        {
            var t= new Token;
            t.type= TypeEof;
            return t;
        }
        if (isidentstart(c)) return getident(self, c, line);
        var select = self.select;
        var current= select[c];
        if (current)
        {
            string c2= self.getchar();
            var current2= current[c2];
            if (current2)
            {
                c+= c2;
                return current2(self, c, line);
            }
            else
            {
                self.ungetchar(c2);
                current2= current[''];
                if (current2)
                    return current2(self, c, line);
            }
        }
        return getop(self, c, line);
    }
    function get(int withcomments [optional])
    {
        var t= self.get_token();
        while (!t.iseof() && ! withcomments && t.iscomment() )
           t= self.get_token();
        return t;
    }
}

//*********************************************
//            Miniwinxed
//*********************************************

// This is a first step towards a possible bootstraped version.

function namespacekey(var path)
{
    string s = '.namespace [';
    string sep= '';
    for (string n in path) {
        s+= sep;
        sep="; '";
        s+= "'" + n + "'";
    }
    s+= " ]";
    return s;
}

class FunctionStatement
{
    var name;
    var modifiers;

    function parse(tk)
    {
        var t= tk.get();
        self.name= t;
        t= tk.get();
        if (t.isop('['))
        {
            var modifiers= [];
            t= tk.get();
            modifiers.push(t);
            for (t= tk.get(); t.isop(','); )
            {
                t= tk.get();
                modifiers.push(t);
            }
            if (!t.isop(']'))
                throw Error("Expected ',' or ']'");
            t= tk.get();
            self.modifiers= modifiers;
        }
        if (! t.isop('('))
            throw Error("Expected '('");
        t= tk.get();
        while (! t.isop(')'))
            t= tk.get();
        t= tk.get();
        if (!t.isop('{'))
            throw Error("Expected '{'");
        int blocklevel= 1;
        while (blocklevel > 0)
        {
            t= tk.get();
            if (t.isop('{'))
                ++blocklevel;
            else if (t.isop('}'))
                --blocklevel;
        }
    }

    function report()
    {
        print('function ', self.name);
        var modifiers= self.modifiers;
        if (modifiers)
        {
            print(' [');
            var m;
            string sep= '';
            for (m in modifiers)
            {
                print(sep);
                sep= ', ';
                print(m);
            }
            print(']');
        }
        say(' ()');
    }
    function emit()
    {
        print('.sub ', self.name);
        var modifiers= self.modifiers;
        if (modifiers)
        {
            for (var m in modifiers)
            {
                print(' :', m);
            }
        }
        say('');
        
        say('.end');
    }
}

class ClassStatement
{
    var name;
    var bases;
    var functions;

    function init [vtable] ()
    {
        self.functions = [];
        self.bases= [];
    }

    function parse(tk)
    {
        var t= tk.get();
        self.name= t;
        t= tk.get();
        if (t.isop(':')) {
            var bases= self.bases;
            for (;;) {
                t= tk.get();
                bases.push(t);
                t= tk.get();
                if (!t.isop(',')) break;
            }
        }
        if (!t.isop('{'))
            throw Error("Expected '{'");
        t= tk.get();
        while (!t.isop('}'))
        {
            if (t.iskeyword('function'))
            {
                var f= new FunctionStatement;
                f.parse(tk);
                var functions= self.functions;
                functions.push(f);
            }
            t= tk.get();
        }
    }

    function report()
    {
        print('class ', self.name);
        string sep= ' : ';
        for (var b in self.bases) {
            print (sep, b);
            sep= ' ,';
        }
        say(' {');
        for (var f in self.functions)
            f.report();
        say('}');
    }
    function emit()
    {
    }
}

class Namespace
{
    var parent;
    var name;
    var namespaces;
    var classes;
    var functions;
    var items;
    function init [vtable] ()
    {
        self.namespaces= [];
        self.classes= [];
        self.functions = [];
        self.items = [];
    }
    function init_child(parent, string name)
    {
        self.parent= parent;
        self.name= name;
    }
    function getpath()
    {
        if (self.parent != null) {
            var path=self.parent.getpath();
            path.push(self.name);
            return path;
        }
        else
        {
            string path[];
            return path;
        }
    }
    function parse(tk)
    {
        string namespace[];
        var t= tk.get();
        int balance1= 0;
        int balance2= 0;
        int balance3= 0;
        while (! t)
        {
            if (t.iskeyword('namespace'))
            {
                t= tk.get();
                string name= t;
                namespace.push(name);
                t= tk.get();
                if (!t.isop('{'))
                    throw Error("Expected '{'");
                var child= new Namespace;
                child.init_child(self, name);
                self.namespaces.push(child);
                self.items.push(child);
                child.parse(tk);
            }
            else if (t.iskeyword('function'))
            {
                var f= new FunctionStatement;
                f.parse(tk);
                var functions= self.functions;
                functions.push(f);
                self.items.push(f);
            }
            else if (t.iskeyword('class'))
            {
                var c= new ClassStatement;
                c.parse(tk);
                var classes= self.classes;
                classes.push(c);
                self.items.push(c);
            }
            else if (t.isop('}'))
            {
                int n= namespace;
                if (n < 1)
                {
                    if (self.parent != null) return;
                    throw Error('Unclosed namespace');
                }
                namespace.pop();
            }
            t= tk.get();
        }
    }
    function report()
    {
        if (self.parent != null)
            say('namespace ', self.name, ' {');
        for (var n in self.namespaces)
            n.report();
        for (var c in self.classes)
            c.report();
        for (var f in self.functions)
            f.report();
        if (self.parent != null)
            say('} // namespace ', self.name);
    }
    function emit()
    {
        var path= self.getpath();
        string s= namespacekey(path);
        say(s);

        for (var item in self.items) {
            item.emit();
            if (item instanceof Namespace)
                say(s);
        }
    }
}

class MiniWinxed
{
    var rootns;
    function init [vtable] ()
    {
        self.rootns= new Namespace;
    }
    function parse(tk)
    {
        self.rootns.parse(tk);
    }
    function report()
    {
        self.rootns.report();
    }
    function emit()
    {
        self.rootns.emit();
    }
}

function miniwinxed_parser(tk, int gen)
{
        var winxed= new MiniWinxed;
        winxed.parse(tk);
        if (gen)
            winxed.emit();
        else
            winxed.report();
}

//*********************************************
//            Main functions
//*********************************************

function parser(argv)
{
    // Simple example, get tokens and prints them.

    using extern Getopt.Obj;
    var getopts = new 'Getopt::Obj';
    getopts.notOptStop(1);
    getopts.push_string('withcomments');
    getopts.push_string('miniwinxed');
    getopts.push_string('miniwinxedgen');

    argv.shift();
    var opts = getopts.get_options(argv);
    var withcomments= opts['withcomments'];
    var miniwinxed = opts['miniwinxed'];
    var miniwinxedgen = opts['miniwinxedgen'];

    int argc= argv;
    if (argc == 0)
        throw Error('No file');
    var file= new 'FileHandle';
    file.open(argv[0]); // Must throw on error

    var t= new Tokenizer;
    t.init(file);

    if (miniwinxed)
        miniwinxed_parser(t, 0);
    else if (miniwinxedgen)
        miniwinxed_parser(t, 1);    
    else
    {
        var c;
        int line= 0;
        c= t.get(withcomments);
        while (! c)
        {
            int newline= c.line;
            if (newline != line)
            {
                line= newline;
                say(); print(line, ': ');
            }
            print(" [", c, "]");
            c= t.get(withcomments);
        }
        say('');
    }

    file.close();
}

function main(argv)
{
    /*try*/ parser(argv);
    /*
    catch (e)
    {
        string msg= e['message'];
        say('Error: ', msg);
    }
    */
}

// End
