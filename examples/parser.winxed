#! winxed

// parsing example

//*********************************************
//          Character test functions
//*********************************************

function isspace(string c)
{
    int r= c == ' ' || c == "\n" || c == "\t";
    return r;
}

function isidentstart(string c)
{
    int r= indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_', c);
    r= r > -1;
    return r;
}

function isident(string c)
{
    int r= indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_' +
        '0123456789', c);
    r= r > -1;
    return r;
}

//*********************************************
//                Token
//*********************************************

class Token
{
    var type;
    var str;
    var line;
    function get_bool[vtable]()
    {
        int eof = self.type == -1;
        return eof;
    }
    function get_string[vtable]()
    {
        string str= self.str;
        if (self.type == 1)
            str= '"' + str + '"';
        else if (self.type == 2)
            str= "'" + str + "'";
        return str;
    }
}

//*********************************************
//       Tokenizer auxiliar functions
//*********************************************

function getquoted(tk, string start)
{
    int line= tk.line;
    string s;
    string c= tk.getchar();
    while (c != '"')
    {
        if (c == '')
            throw Error('Unterminated string');
        s+= c;
        c= tk.getchar();
    }
    var t= new Token;
    t.type= 2; t.str= s; t.line= line;
    return t;
}

function getsinglequoted(tk, string start)
{
    int line= tk.line;
    string s;
    string c= tk.getchar();
    while (c != "'")
    {
        if (c == '')
            throw Error('Unterminated string');
        s+= c;
        c= tk.getchar();
    }
    var t= new Token;
    t.type= 3; t.str= s; t.line= line;
    return t;
}

function getident(tk, string start)
{
    int line= tk.line;
    string s= start;
    string c= tk.getchar();
    while (isident(c))
    {
        s+= c;
        c= tk.getchar();
    }
    tk.ungetchar(c);
    var t= new Token;
    t.type= 4; t.str= s; t.line= line;
    return t;
}

function getlinecomment(tk, string start)
{
    int line= tk.line;
    string s= start;
    string c= tk.getchar();
    while (c != '' && c != "\n")
    {
        s+= c;
        c= tk.getchar();
    }
    var t= new Token;
    t.type= 0; t.str= s; t.line= line;
    return t;
}

function getcomment(tk, string start)
{
    int line= tk.line;
    string s= start;
    string c= tk.getchar();
next:
    while (c != '' && c != '*')
    { s+= c; c= tk.getchar(); }
    if (c == '')
        throw Error("Unclosed comment");
    c= tk.getchar();
    if (c == '')
        throw Error("Unclosed comment");
    if (c != '/')
    { s+= '*' + c; goto next; }
    s+= '*/';
    var t= new Token;
    t.type= 0; t.str= s; t.line= line;
    return t;
}

function getop(tk, string start)
{
    int line= tk.line;
    string s= start;
    var t= new Token;
    t.type= 5; t.str= s; t.line= line;
    return t;
}

//*********************************************
//              Tokenizer
//*********************************************

class Tokenizer
{
    var h;
    var pending;
    var select;
    var line;
    function init(handle)
    {
        self.h= handle;
        var pending= new 'String';
        self.pending= pending;
	self.line= 1;
        var select = {
            '"': { '': getquoted },
            "'": { '': getsinglequoted },
            '=': { '': getop, '=': getop },
            '|': { '': getop, '|': getop },
            '&': { '': getop, '&': getop },
            '!': { '': getop, '=': getop },
            '/': { '/': getlinecomment, '*': getcomment },
            '#': { '': getlinecomment }
        };
        self.select= select;
    }
    function getchar()
    {
        string pending= self.pending;
        if (pending != '')
        {
            self.pending= '';
            return pending;
        }
        var h= self.h;
        string c= h.read(1);
	if (c == "\n")
	{
		int l=self.line;
		++l;
		self.line= l;
	}
        return c;
    }
    function ungetchar(string c)
    {
        self.pending= c;
    }
    function get()
    {
    skip:
        string c= self.getchar();
        if (c == '')
        {
            var t= new Token;
            t.type= -1;
            return t;
        }
        if (isspace(c)) goto skip;
        if (isidentstart(c)) return getident(self, c);
        var select = self.select;
        var current= select[c];
        if (current)
        {
            string c2= self.getchar();
            var current2= current[c2];
            if (current2)
            {
                c= c + c2;
                return current2(self, c);
            }
            else
            {
                self.ungetchar(c2);
                current2= current[''];
                if (current2)
                    return current2(self, c);
            }
        }
	else
	{
            int line= self.line;
            var t= new Token;
            t.type= 5; t.str= c; t.line= line;
            return t;
        }
    }
}

//*********************************************
//            Main functions
//*********************************************

function parser(argv)
{
    // Simple example, get tokens and prints them.

    int argc= argv;
    if (argc == 0)
        throw Error('No file');
    var file= new 'FileHandle';
    file.open(argv[0]); // Must throw on error

    var t= new Tokenizer;
    t.init(file);

    var c;
    int line= 0;
    c= t.get();
    while (! c)
    {
    	int newline= c.line;
	if (newline != line)
	{
	    line= newline;
	    say(); print(line, ': ');
	}
        print(" [", c, "]");
        c= t.get();
    }
    say('');
    file.close();
}

function main(argv)
{
    argv.shift();
    try parser(argv);
    /**/
    catch (e)
    {
        string msg= e['message'];
        say('Error: ', msg);
    }
    /**/
}

// End
