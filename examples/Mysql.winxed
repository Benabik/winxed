#! winxed

// Test Mysql usage via NCI

// Note:
// null results from dlfuncs are checked in a convoluted way
// to be able to work with buggy versions of parrot.

namespace WinxedMysql
{

$include_const 'datatypes.pasm';

// Severity and type of the exceptions explicitly thrown.
const int ERROR = 2;
const int TYPE= 99;

namespace __private
{

function findlib()
{
    for (string lib in [
                'libmysqlclient',
                'libmysqlclient.so.16',
                'libmysqlclient.so.15'
            ] ) {
        var l = loadlib(lib);
        if (l)
            return l;
    }
    return null;
}

function getlib()
{
    var l = findlib();
    if (! l)
        throw Error('Cannot load Mysql lib', ERROR, TYPE);
    for (;;)
        yield l;
}

function str_to_cstring(string s)
{
    var to_cstring = dlfunc(null, 'Parrot_str_to_cstring',   'ppS');
    return to_cstring(getinterp(), s);
}

function str_free_cstring(s)
{
    var free_cstring = dlfunc(null, 'Parrot_str_free_cstring', 'vp');
    free_cstring(s);
}

function get_parrot_func(string name, string sig)
{
    var found;
    try {
        var strnew = dlfunc(null, name, sig);
        if (strnew != null) {
            int isdef;
            ${ defined isdef, strnew };
            if (isdef) {
                isdef = strnew;
                if (isdef)
                    found = strnew;
            }
        }
    }
    catch () {}
    return found;
}

function raw_encode(string s, string encoding)
{
    int got_encoding_num;
    string got_encoding;
    ${ encoding got_encoding_num, s };
    ${ encodingname got_encoding, got_encoding_num };
    if (got_encoding != encoding) {
        switch {
          case got_encoding == 'ascii' && encoding == 'iso-8859-1':
          case got_encoding == 'ascii' && encoding == 'utf8':
            // Compatible encodings, do nothing
            break;
          default:
            // trans_encoding is not useful here, must encode
            // from the raw bytes.
            var b = new ['ByteBuffer'];
            b =: s;
            s = b.get_string(encoding);
        }
    }
    return s;
}

function get_encoding_func()
{
    var found = get_parrot_func('Parrot_str_new_init', 'SppIpI');

    if (found != null) {
        return function(p, string encoding[optional])
        {
            if (encoding == null)
                encoding = 'ascii';
            var interp = getinterp();
            var find_encoding = dlfunc(null, 'Parrot_find_encoding', 'ppp');
            var pencoding = str_to_cstring(encoding);
            var parrot_encoding = find_encoding(interp, pencoding);
            str_free_cstring(pencoding);
            return found(interp, p, 0, parrot_encoding, 0);
        };
    }

    found = get_parrot_func('Parrot_str_from_platform_cstring', 'Spp');
    if (found != null) {
        return function(p, string encoding[optional])
        {
            var interp = getinterp();
            return found(interp, p);
        };
    }

    found = get_parrot_func('Parrot_str_new', 'SppI');
    if (found != null) {
        return function(p, string encoding[optional])
        {
            var interp = getinterp();
            return found(interp, p, 0);
        };
    }
    return null;
}

function string_from_nci(p, string encoding[optional])
{
    var interp = getinterp();

    var f = get_encoding_func();
    if (! f)
        throw "Cannot get string from NCI";

    string s;
    if (f != null)
        s = f(p, encoding);

    if (s != null && encoding != null)
        s = raw_encode(s, encoding);
    return s;
}

} // namespace __private;

using namespace __private;

class Row
{
    var mrow;
    var nfields;
    var encoding;
    function Row(var myrow, int n, string encoding[optional])
    {
        self.mrow = myrow;
        self.nfields = n;
        if (encoding != null)
            self.encoding = encoding;
    }
    function get(int i)
    {
        string s = self.mrow[i];
        if (s != null && self.encoding != null)
            s = raw_encode(s, self.encoding);
        return s;
    }
}

class Result
{
    var mysql;
    var myresult;
    var nfields;
    var desc;
    function Result(var my, var r)
    {
        using WinxedMysql.getlib;
        self.mysql = my;
        self.myresult = r;
        var f = dlfunc(getlib(), 'mysql_field_count', 'ip');
        int count = f(my.mysql);
        self.nfields = count;
        int desc [3 * count];
        // Store the fields description for use in fetchs.
        for (int i = 0; i < count; ++i) {
            desc[i * 3]     = DATATYPE_CSTR;
            desc[i * 3 + 1] = 1;
            desc[i * 3 + 2] = 0;
        }
        self.desc = desc;
    }
    function field_count()
    {
        return self.nfields;
    }
    function fetch_row()
    {
        using WinxedMysql.getlib;
        var f = dlfunc(getlib(), 'mysql_fetch_row', 'pp');
        var frow = f(self.myresult);

        if (frow == null)
            return null;
        var none = new 'UnManagedStruct';
        if (frow == none)
            return null;

        frow =: self.desc;
        string encoding;
        if (self.mysql.encoding != null)
            encoding = self.mysql.encoding;
        return new WinxedMysql.Row(frow, self.nfields, encoding);
    }
    function close()
    {
        if (self.myresult != null)
        {
            using WinxedMysql.getlib;
            var f = dlfunc(getlib(), 'mysql_free_result', 'vp');
            f(self.myresult);
            self.myresult = null;
        }
    }
}

class Connection
{
    var mysql;
    var encoding;

    function Connection()
    {
        using WinxedMysql.getlib;
        var minit = dlfunc(getlib(), 'mysql_init', 'pp');
        string nothing;
        var my = minit(null);
        self.mysql = my;
    }
    function close()
    {
        using WinxedMysql.getlib;
        var mclose = dlfunc(getlib(), 'mysql_close', 'vp');
        mclose(self.mysql);
        var n = new 'Undef';
        self.mysql = n;
    }
    function get_client_info()
    {
        using WinxedMysql.getlib;
        var f = dlfunc(getlib(), 'mysql_get_client_info', 'p');
        return string_from_nci(f(), 'utf8');
    }
    function error()
    {
        using WinxedMysql.getlib;
        var f = dlfunc(getlib(), 'mysql_error', 'pp');
        return string_from_nci(f(self.mysql));
    }
    function connect(string host, string user, string pass, string database,
            string encoding)
    {
        using WinxedMysql.getlib;
        var f = dlfunc(getlib(), 'mysql_real_connect', 'ppppppipi');
        string snull;
        var phost = str_to_cstring(host);
        var puser = str_to_cstring(user);
        var ppass = str_to_cstring(pass);
        var pdatabase = str_to_cstring(database);
        var p = f(self.mysql, phost, puser, ppass, pdatabase, 0, null, 0);
        str_free_cstring(phost);
        str_free_cstring(puser);
        str_free_cstring(ppass);
        str_free_cstring(pdatabase);
        if (p == null)
            throw Error(self.error(), ERROR, TYPE);
        var none = new 'UnManagedStruct';
        if (p == none)
            throw Error(self.error(), ERROR, TYPE);

        var setcharset = dlfunc(getlib(), 'mysql_set_character_set', 'ipp');
        if (encoding != null) {
            int i = setcharset(self.mysql, str_to_cstring(encoding));
            if (i != 0)
                cry('Failed to set character set.');
           self.encoding = encoding;
        }
        return p;
    }
    function query(string stmt)
    {
        using WinxedMysql.getlib;
        var f = dlfunc(getlib(), 'mysql_query', 'ipp');
        var pstmt = str_to_cstring(stmt);
        int q = f(self.mysql, pstmt);
        str_free_cstring(pstmt);
        if (q != 0)
            throw Error(self.error(), ERROR, TYPE);
    }
    function use_result()
    {
        using WinxedMysql.getlib;
        var f = dlfunc(getlib(), 'mysql_use_result', 'pp');
        var r = f(self.mysql);
        if (r == null)
            throw Error(self.error(), ERROR, TYPE);
        var none = new 'UnManagedStruct';
        if (r == none)
            throw Error(self.error(), ERROR, TYPE);
        return new WinxedMysql.Result(self, r);
    }
}

} // namespace WinxedMysql

$load 'Getopt/Obj.pbc';

function main(argv)
{
    using namespace WinxedMysql;

    var getopts = new ['Getopt', 'Obj'];
    getopts.notOptStop(1);
    getopts.push_string('host|h=s');
    getopts.push_string('user|u=s');
    getopts.push_string('password|p:s');
    getopts.push_string('database|D=s');
    getopts.push_string('encoding|D=s');
    getopts.push_string('config|D=s');
    argv.shift();
    var opts = getopts.get_options(argv);

    string host;
    string user;
    string pass;
    string database;
    string encoding;

    string config = opts['config'];
    if (config != null && config != '') {
        // Get config from file in json format.
        try {
            var json = load_language('data_json');
            var code = json.compile(open(config).readall());
            var data = code();
            if (data['host'] != null)
                host = data['host'];
            if (data['user'] != null)
                user = data['user'];
            if (data['password'] != null)
                pass = data['password'];
            if (data['database'] != null)
                database = data['database'];
            if (data['encoding'] != null)
                encoding = data['encoding'];
        }
        catch (e) {
            cry('Error reading config file: ', e['message']);
            return;
        }
    }

    if (opts['host'] != null)
        host = opts['host'];
    if (opts['user'] != null)
        user = opts['user'];
    if (opts['password'] != null)
        pass= opts['password'];
    if (opts['database'] != null)
        database = opts['database'];
    if (opts['encoding'] != null)
        encoding = opts['encoding'];

    if (host == null || host == '')
        host = 'localhost';
    if (user == null || user == '')
        user = 'parrot';

    if (pass == null)
        pass = 'baDworD';
    else if (pass == '')
        die("Sorry, asking for password not implemented");

    if (database == null || database == '')
        database = 'parrot';

    var mysql = new WinxedMysql.Connection();
    say('Mysql version: ', mysql.get_client_info());
    var result;

    try [min_severity(ERROR),max_severity(ERROR),handle_types(TYPE)] {
        mysql.connect(host, user, pass, database, encoding);
        string q = 'select * from hello;';
        if (elements(argv) > 0) {
            q = string(argv.shift());
        }
        for(;;) {
        say("Query: '", q, "'");
        mysql.query(q);
        result = mysql.use_result();
        int fields = result.field_count();

        int nrows = 0;
        var row;
        while ((row = result.fetch_row()) != null) {
            ++nrows;
            print(nrows, ': ');
            for (int i = 0; i < fields; ++i) {
                if (i > 0)
                    print(", ");
                string s = row.get(i);
                if (s == null)
                    print('(null)');
                else
                    print("'", s, "'");
            }
            say();
        }
        result.close();
        say('Total rows: ', nrows);
        if (elements(argv) == 0)
            break;
        q = string(argv.shift());
        }
    }
    catch (e) {
        say("\tERROR: ", e['message']);
        if (result != null)
            result.close();
        mysql.close();
        return;
    }
    mysql.close();
}

// End
