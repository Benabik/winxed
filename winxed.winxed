#! winxed

// Winxed compiler driver.
// Parses command line options, calls the compiler backend
// and eventually runs the generated program.

$load 'Getopt/Obj.pbc';

function extname(string filename, string ext)
{
    // Strip a possible .winxed extension from filename,
    // add ext, and return the result.
    string newname;
    int l = length(filename);
    if (l > 7 && substr(filename, -7) == '.winxed')
        newname = substr(filename, 0, l - 7) + ext;
    else
        newname = filename + ext;
    return newname;
}

// Use the OS pmc for file operations.
function getOS()
{
    var os;
    try {
        loadlib('os');
        os = new 'OS';
    }
    catch() { }
    for (;;)
        yield os;
}

class Options : ['Getopt', 'Obj']
{
    var name;
    var options;
    var opts;

    function Options(argv, int unused)
    {
        var options = [
          [ 'stage=i',  'Compiler stage to use' ],
          [ 'c',        'Compile only. Same as --target=pir' ],
          [ 'e=s',      'Evaluate' ],
          [ 'o=s',      'Object name' ],
          [ 'L=s',      'Add to parrot library search path' ],
          [ 'I=s',      'Add to parrot include search path' ],
          [ 'noan',     'No code annotations' ],
          [ 'nowarn',   'No warnings' ],
          [ 'target=s', 'Set target type: pir, pbc or run. Default is run.' ],
          [ 'help',     'Show this help' ]
        ];
        self.options = options;
        for (var o in options)
            self.push_string(o[0]);
        self.notOptStop(1);
        self.name = argv.shift();
        self.opts = self.get_options(argv);
    }
    function get()
    {
        return self.opts;
    }
    function showhelp()
    {
        say('Usage: ', self.name, ' [options] [program] [args]');
        say('  Available options:');
        int l= 0;
        int i;
        var o;
        for (o in self.options) {
            i= length(o[0]) + 4;
            if (i > l) l= i;
        }
        for (o in self.options) {
            string s= o[0];
            if (length(s) > 1 && substr(s, 1, 1) != '=')
                s= '--' + s;
            else
                s= '-' + s;
            i= l - length(s);
            say('    ', s, ' ' * i, '->  ', o[1]);
        }
    }
}

function main [main] (argv)
{
    const int DEFAULT_STAGE = 2;

    var optionset = new Options(argv, 0);
    var options = optionset.get();

    var help        = options['help'];
    var opt_stage   = options['stage'];
    var compileonly = options['c'];
    var noan        = options['noan'];
    var opt_nowarn  = options['nowarn'];
    var eval        = options['e'];
    var opt_L       = options['L'];
    var opt_I       = options['I'];
    var opt_o       = options['o'];
    var opt_target  = options['target'];

    if (help != null) {
        optionset.showhelp();
        return;
    }

    var env = new 'Env';
    // Path for stage pbc files
    string winxedpath = env['WINXED_PATH'];

    int stage = DEFAULT_STAGE;
    if (opt_stage != null)
        stage = opt_stage;
    else {
        string envstage = env['WINXED_STAGE'];
        if (envstage != '')
            stage = envstage;
    }

    string obj = '';
    if (opt_o != null)
        obj = opt_o;
    string libs = '';
    if (opt_L != null)
        libs = opt_L;
    string incs = '';
    if (opt_I != null)
        incs = opt_I;

    const int TargetDefault = 0;
    const int TargetRun     = 1;
    const int TargetPir     = 2;
    const int TargetPbc     = 3;
    int target = TargetDefault;
    if (opt_target != null) {
        string starget = opt_target;
        switch (starget) {
        case 'pir':
            target = TargetPir;
            break;
        case 'pbc':
            target = TargetPbc;
            break;
        case 'run':
            target = TargetRun;
            break;
        default:
            die('Invalid target: ' + starget);
        }
    }
    if (compileonly != null) {
        if (target != TargetDefault)
            die("Conflicting options");
        target = TargetPir;
    }
    if (target == TargetDefault)
        target = TargetRun;

    string srcfile;
    if (eval == null) {
        int argc= argv;
        if (argc < 1) {
            say("ERROR: No program specified");
            optionset.showhelp();
            return;
        }
        srcfile = argv.shift();
    }

    string pirfile;
    if (obj != '' && target == TargetPir)
        pirfile = obj;
    else {
        if (eval != null)
            pirfile = '__eval__.pir';
        else
            pirfile = extname(srcfile, '.pir');
    }

    var os = getOS();

    // Call backend compiler

    string winxedbin;
    switch (stage) {
    case 0:
        winxedbin = 'winxedst0';
        break;
    case 1:
        winxedbin = 'winxedst1';
        break;
    case 2:
        winxedbin = 'winxedst2';
        break;
    default:
        die('Invalid stage ' + stage + '. Must be 0, 1 or 2 (2 is for testing development only).');
    }

    int retval = 0;
    string cmd[]; // Command to execute

    int use_pbc = stage > 0;

    if (use_pbc) {
        cmd.push('parrot');
        if (winxedpath != null && winxedpath != '')
            winxedbin = winxedpath + '/' + winxedbin;
        winxedbin += '.pbc';
        cmd.push(winxedbin);
    }
    else {
        // First look in WINXED_PATH.
        // If not, simple heuristic: if the compiler is in the current
        // directory and has no extension, use it.
        // If not, assume it's in the PATH or we are on Windows.
        var check = null;
        if (winxedpath != null && winxedpath != '' &&os != null) {
            string checkbin = winxedpath + '/' + winxedbin;
            check = os.stat(checkbin);
            if (check == null) {
                checkbin = winxedpath + "\\" + winxedbin + ".exe";
                check = os.stat(checkbin);
            }
            if (check != null)
                winxedbin = checkbin;
        }
        if (check == null) {
            if (os != null)
                check = os.stat(winxedbin);
            if (check != null)
                winxedbin = './' + winxedbin;
        }
        cmd.push(winxedbin);
    }

    cmd.push('-c');
    if (noan)
        cmd.push('--noan');;
    if (opt_nowarn != null && stage != 0)
        cmd.push('--nowarn');
    if (eval != null) {
        cmd.push('-e');
        cmd.push(eval);
    }
    cmd.push('-o');
    cmd.push(pirfile);
    if (eval == null)
        cmd.push(srcfile);
    retval = spawnw(cmd);
    retval = (retval & 0xFF00) / 256;
    if (retval)
        exit(retval);

    string runit[] = [ 'parrot' ];

    switch (target) {
    case TargetRun:
        // Execute result
        if (libs != '') {
            runit.push('-L');
            runit.push(libs);
        }
        if (incs != '') {
            runit.push('-I');
            runit.push(incs);
        }
        runit.push(pirfile);
        for (string a in argv)
            runit.push(a);
        retval = spawnw(runit);
        // Delete the generated pir file.
        try {
            os.rm(pirfile);
        }
        catch (e)
        {
            cry('WARNING: cannot delete temporary PIR file: ', e['message']);
        }
        break;
    case TargetPbc:
        // Call parrot to ceate the pbc
        string objfile;
        if (obj != '')
            objfile = obj;
        else
            objfile = extname(srcfile, '.pbc');
        runit.push('-o');
        runit.push(objfile);
        runit.push(pirfile);
        retval = spawnw(runit);
        // Delete the generated pir file.
        try {
            os.rm(pirfile);
        }
        catch (e)
        {
            cry('WARNING: cannot delete temporary PIR file: ', e['message']);
        }
        break;
    default:
        ; // Otherwise, nothing to do.
    }
    retval = (retval & 0xFF00) / 256;
    exit(retval);
}
